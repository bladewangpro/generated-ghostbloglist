<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=theme-color content="#FFFFFF"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Objc 对象的今生今世 | prometheus</title><meta name=description content="Explore in every moment of the hard thinking"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Objc 对象的今生今世"><meta property="og:description" content="前言 在面向对象编程中，我们每天都在创建对象，用对象描述着整个世界，然而对象是如何从孕育到销毁的呢？
目录  1.孕育对象 2.对象的出生 3.对象的成长 4.对象的销毁 5.总结  一.孕育对象 每天开发我们都在alloc对象，而alloc方法做了些什么呢？
+ (id)alloc { return _objc_rootAlloc(self); } 所有对象alloc都会调用这个root的方法
id _objc_rootAlloc(Class cls) { return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/); } 这个方法又会去调用callAlloc方法
static ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false) { if (checkNil && !cls) return nil; #if __OBJC2__  if (! cls->ISA()->hasCustomAWZ()) { // No alloc/allocWithZone implementation. Go straight to the allocator.  // fixme store hasCustomAWZ in the non-meta class and  // add it to canAllocFast's summary  if (cls->canAllocFast()) { // No ctors, raw isa, etc."><meta property="og:type" content="article"><meta property="og:url" content="https://new.halfrost.com/objc_life/"><meta property="article:published_time" content="2016-10-30T17:11:38+00:00"><meta property="article:modified_time" content="2016-10-30T17:11:38+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Objc 对象的今生今世"><meta name=twitter:description content="前言 在面向对象编程中，我们每天都在创建对象，用对象描述着整个世界，然而对象是如何从孕育到销毁的呢？
目录  1.孕育对象 2.对象的出生 3.对象的成长 4.对象的销毁 5.总结  一.孕育对象 每天开发我们都在alloc对象，而alloc方法做了些什么呢？
+ (id)alloc { return _objc_rootAlloc(self); } 所有对象alloc都会调用这个root的方法
id _objc_rootAlloc(Class cls) { return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/); } 这个方法又会去调用callAlloc方法
static ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false) { if (checkNil && !cls) return nil; #if __OBJC2__  if (! cls->ISA()->hasCustomAWZ()) { // No alloc/allocWithZone implementation. Go straight to the allocator.  // fixme store hasCustomAWZ in the non-meta class and  // add it to canAllocFast's summary  if (cls->canAllocFast()) { // No ctors, raw isa, etc."><link rel=stylesheet href=/css/style-white.min.css><link rel=manifest href=/manifest.json><link rel=stylesheet href=/prism.css><link href=/images/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=/images/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=/images/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=/images/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=/images/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=/images/apple-touch-icon-512x512.png rel=apple-touch-icon sizes=512x512><link href=/images/apple-touch-icon-1024x1024.png rel=apple-touch-icon sizes=1024x1024><script async>if('serviceWorker'in navigator){navigator.serviceWorker.register("\/serviceworker-v1.min.a64912b78d282eab1ad3715a0943da21616e5f326f8afea27034784ad445043b.js").then(function(){if(navigator.serviceWorker.controller){console.log('Assets cached by the controlling service worker.');}else{console.log('Please reload this page to allow the service worker to handle network operations.');}}).catch(function(error){console.log('ERROR: '+error);});}else{console.log('Service workers are not supported in the current browser.');}</script><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://new.halfrost.com/images/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-82753806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="single-max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a><a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a><a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast');" style=display:none><i class="fas fa-chevron-up fa-lg"></i></a><span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://new.halfrost.com/realm_ios/><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li><li><a class=icon href=https://new.halfrost.com/reactivecocoa_racsignal/><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li><li><a class=icon href=#><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f"><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&text=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&title=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&is_video=false&description=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f"><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&title=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&title=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&title=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-stumbleupon" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&title=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-digg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&name=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96&description=%e5%89%8d%e8%a8%80%20%e5%9c%a8%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b%e4%b8%ad%ef%bc%8c%e6%88%91%e4%bb%ac%e6%af%8f%e5%a4%a9%e9%83%bd%e5%9c%a8%e5%88%9b%e5%bb%ba%e5%af%b9%e8%b1%a1%ef%bc%8c%e7%94%a8%e5%af%b9%e8%b1%a1%e6%8f%8f%e8%bf%b0%e7%9d%80%e6%95%b4%e4%b8%aa%e4%b8%96%e7%95%8c%ef%bc%8c%e7%84%b6%e8%80%8c%e5%af%b9%e8%b1%a1%e6%98%af%e5%a6%82%e4%bd%95%e4%bb%8e%e5%ad%95%e8%82%b2%e5%88%b0%e9%94%80%e6%af%81%e7%9a%84%e5%91%a2%ef%bc%9f%0a%e7%9b%ae%e5%bd%95%20%201.%e5%ad%95%e8%82%b2%e5%af%b9%e8%b1%a1%202.%e5%af%b9%e8%b1%a1%e7%9a%84%e5%87%ba%e7%94%9f%203.%e5%af%b9%e8%b1%a1%e7%9a%84%e6%88%90%e9%95%bf%204.%e5%af%b9%e8%b1%a1%e7%9a%84%e9%94%80%e6%af%81%205.%e6%80%bb%e7%bb%93%20%20%e4%b8%80.%e5%ad%95%e8%82%b2%e5%af%b9%e8%b1%a1%20%e6%af%8f%e5%a4%a9%e5%bc%80%e5%8f%91%e6%88%91%e4%bb%ac%e9%83%bd%e5%9c%a8alloc%e5%af%b9%e8%b1%a1%ef%bc%8c%e8%80%8calloc%e6%96%b9%e6%b3%95%e5%81%9a%e4%ba%86%e4%ba%9b%e4%bb%80%e4%b9%88%e5%91%a2%ef%bc%9f%0a%2b%20%28id%29alloc%20%7b%20return%20_objc_rootAlloc%28self%29%3b%20%7d%20%e6%89%80%e6%9c%89%e5%af%b9%e8%b1%a1alloc%e9%83%bd%e4%bc%9a%e8%b0%83%e7%94%a8%e8%bf%99%e4%b8%aaroot%e7%9a%84%e6%96%b9%e6%b3%95%0aid%20_objc_rootAlloc%28Class%20cls%29%20%7b%20return%20callAlloc%28cls%2c%20false%2f%2acheckNil%2a%2f%2c%20true%2f%2aallocWithZone%2a%2f%29%3b%20%7d%20%e8%bf%99%e4%b8%aa%e6%96%b9%e6%b3%95%e5%8f%88%e4%bc%9a%e5%8e%bb%e8%b0%83%e7%94%a8callAlloc%e6%96%b9%e6%b3%95%0astatic%20ALWAYS_INLINE%20id%20callAlloc%28Class%20cls%2c%20bool%20checkNil%2c%20bool%20allocWithZone%3dfalse%29%20%7b%20if%20%28checkNil%20%26amp%3b%26amp%3b%20%21cls%29%20return%20nil%3b%20%23if%20__OBJC2__%20%c2%a0if%20%28%21%20cls-%26gt%3bISA%28%29-%26gt%3bhasCustomAWZ%28%29%29%20%7b%20%2f%2f%20No%20alloc%2fallocWithZone%20implementation.%20Go%20straight%20to%20the%20allocator.%20%c2%a0%2f%2f%20fixme%20store%20hasCustomAWZ%20in%20the%20non-meta%20class%20and%c2%a0%c2%a0%2f%2f%20add%20it%20to%20canAllocFast%26%2339%3bs%20summary%20%c2%a0if%20%28cls-%26gt%3bcanAllocFast%28%29%29%20%7b%20%2f%2f%20No%20ctors%2c%20raw%20isa%2c%20etc."><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&t=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div><div id=toc><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#目录>目录</a></li><li><a href=#二对象的出生>二.对象的出生</a></li><li><a href=#三对象的生长>三.对象的生长</a></li><li><a href=#四对象的销毁>四.对象的销毁</a></li><li><a href=#总结>总结</a></li></ul></li></ul></li></ul></nav></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">Objc 对象的今生今世</h1><div class=meta><div class=postdate><time datetime="2016-10-30 17:11:38 +0000 UTC" itemprop=datePublished>Oct 30</time></div><div class=article-category><i class="fas fa-archive"></i><a class=category-link href=/categories/ios>iOS</a>
,
<a class=category-link href=/categories/objc>objc</a></div><div class=article-tag><i class="fas fa-tag"></i><a class=tag-link href=/tags/ios rel=tag>iOS</a>
,
<a class=tag-link href=/tags/objc rel=tag>objc</a></div></div></header><div class=content itemprop=articleBody><h4 id=前言>前言</h4><p>在面向对象编程中，我们每天都在创建对象，用对象描述着整个世界，然而对象是如何从孕育到销毁的呢？</p><h4 id=目录>目录</h4><ul><li>1.孕育对象</li><li>2.对象的出生</li><li>3.对象的成长</li><li>4.对象的销毁</li><li>5.总结</li></ul><h5 id=一孕育对象>一.孕育对象</h5><p><img src=https://img.halfrost.com/Blog/ArticleImage/30_1.png alt></p><p>每天开发我们都在alloc对象，而alloc方法做了些什么呢？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>alloc</span> {
    <span style=color:#66d9ef>return</span> _objc_rootAlloc(self);
}

</code></pre></div><p>所有对象alloc都会调用这个root的方法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>id</span> <span style=color:#a6e22e>_objc_rootAlloc</span>(<span style=color:#66d9ef>Class</span> cls)
{
    <span style=color:#66d9ef>return</span> callAlloc(cls, false<span style=color:#75715e>/*checkNil*/</span>, true<span style=color:#75715e>/*allocWithZone*/</span>);
}

</code></pre></div><p>这个方法又会去调用callAlloc方法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> ALWAYS_INLINE <span style=color:#66d9ef>id</span> <span style=color:#a6e22e>callAlloc</span>(<span style=color:#66d9ef>Class</span> cls, <span style=color:#66d9ef>bool</span> checkNil, <span style=color:#66d9ef>bool</span> allocWithZone<span style=color:#f92672>=</span>false)
{
    <span style=color:#66d9ef>if</span> (checkNil <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>cls) <span style=color:#66d9ef>return</span> nil;

<span style=color:#75715e>#if __OBJC2__
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> cls<span style=color:#f92672>-&gt;</span>ISA()<span style=color:#f92672>-&gt;</span>hasCustomAWZ()) {
        <span style=color:#75715e>// No alloc/allocWithZone implementation. Go straight to the allocator.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// fixme store hasCustomAWZ in the non-meta class and 
</span><span style=color:#75715e></span>        <span style=color:#75715e>// add it to canAllocFast&#39;s summary
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (cls<span style=color:#f92672>-&gt;</span>canAllocFast()) {
            <span style=color:#75715e>// No ctors, raw isa, etc. Go straight to the metal.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>bool</span> dtor <span style=color:#f92672>=</span> cls<span style=color:#f92672>-&gt;</span>hasCxxDtor();
            <span style=color:#66d9ef>id</span> obj <span style=color:#f92672>=</span> (<span style=color:#66d9ef>id</span>)calloc(<span style=color:#ae81ff>1</span>, cls<span style=color:#f92672>-&gt;</span>bits.fastInstanceSize());
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>obj) <span style=color:#66d9ef>return</span> callBadAllocHandler(cls);
            obj<span style=color:#f92672>-&gt;</span>initInstanceIsa(cls, dtor);
            <span style=color:#66d9ef>return</span> obj;
        }
        <span style=color:#66d9ef>else</span> {
            <span style=color:#75715e>// Has ctor or raw isa or something. Use the slower path.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>id</span> obj <span style=color:#f92672>=</span> class_createInstance(cls, <span style=color:#ae81ff>0</span>);
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>obj) <span style=color:#66d9ef>return</span> callBadAllocHandler(cls);
            <span style=color:#66d9ef>return</span> obj;
        }
    }
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// No shortcuts available.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (allocWithZone) <span style=color:#66d9ef>return</span> [cls allocWithZone:nil];
    <span style=color:#66d9ef>return</span> [cls alloc];
}

</code></pre></div><p>由于入参 checkNil = false，所以不会返回nil。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>hasCustomAWZ</span>() {
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span> bits.hasDefaultAWZ();
    }

</code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/30_2.png alt></p><p>在<a href=https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/images/objc-method-after-realize-class.png>这张图</a>，我们可以看到在对象的数据段data中，class_rw_t中有一个flags。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>hasDefaultAWZ</span>( ) {
        <span style=color:#66d9ef>return</span> data()<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> RW_HAS_DEFAULT_AWZ;
    }

<span style=color:#75715e>#define RW_HAS_DEFAULT_AWZ    (1&lt;&lt;16)
</span><span style=color:#75715e></span>
</code></pre></div><p>RW_HAS_DEFAULT_AWZ 这个是用来标示当前的class或者是superclass是否有默认的alloc/allocWithZone:。值得注意的是，这个值会存储在metaclass 中。</p><p>hasDefaultAWZ( )方法是用来判断当前class是否有默认的allocWithZone。</p><p>如果cls->ISA()->hasCustomAWZ()返回YES，意味着有默认的allocWithZone方法，那么就直接对class进行allocWithZone，申请内存空间。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>if</span> (allocWithZone) <span style=color:#66d9ef>return</span> [cls allocWithZone:nil];

</code></pre></div><p>allocWithZone会去调用rootAllocWithZone</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>allocWithZone:</span>(<span style=color:#66d9ef>struct</span> _NSZone <span style=color:#f92672>*</span>)zone {
    <span style=color:#66d9ef>return</span> _objc_rootAllocWithZone(self, (malloc_zone_t <span style=color:#f92672>*</span>)zone);
}

</code></pre></div><p>接下来就仔细看看_objc_rootAllocWithZone的具体实现</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>id</span> <span style=color:#a6e22e>_objc_rootAllocWithZone</span>(<span style=color:#66d9ef>Class</span> cls, malloc_zone_t <span style=color:#f92672>*</span>zone)
{
    <span style=color:#66d9ef>id</span> obj;

<span style=color:#75715e>#if __OBJC2__
</span><span style=color:#75715e></span>    <span style=color:#75715e>// allocWithZone under __OBJC2__ ignores the zone parameter
</span><span style=color:#75715e></span>    (<span style=color:#66d9ef>void</span>)zone;
    obj <span style=color:#f92672>=</span> class_createInstance(cls, <span style=color:#ae81ff>0</span>);
<span style=color:#75715e>#else
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>zone <span style=color:#f92672>||</span> UseGC) {
        obj <span style=color:#f92672>=</span> class_createInstance(cls, <span style=color:#ae81ff>0</span>);
    }
    <span style=color:#66d9ef>else</span> {
        obj <span style=color:#f92672>=</span> class_createInstanceFromZone(cls, <span style=color:#ae81ff>0</span>, zone);
    }
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>obj) obj <span style=color:#f92672>=</span> callBadAllocHandler(cls);
    <span style=color:#66d9ef>return</span> obj;
}


</code></pre></div><p>在__OBJC2__中，直接调用class_createInstance(cls, 0);方法去创建对象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>id</span>  <span style=color:#a6e22e>class_createInstance</span>(<span style=color:#66d9ef>Class</span> cls, size_t extraBytes)
{
    <span style=color:#66d9ef>return</span> _class_createInstanceFromZone(cls, extraBytes, nil);
}

</code></pre></div><p>关于_class_createInstanceFromZone方法这里先不详细分析，下面再详细分析，先理清程序脉络。</p><p>在objc的老版本中要先去看看zone是否有空间，是否用了垃圾回收，如果没有空间，或者用了垃圾回收，就会调用class_createInstance(cls, 0)方法获取对象，否则调用class_createInstanceFromZone(cls, 0, zone);获取对象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>id</span> <span style=color:#a6e22e>class_createInstanceFromZone</span>(<span style=color:#66d9ef>Class</span> cls, size_t extraBytes, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>zone)
{
    <span style=color:#66d9ef>return</span> _class_createInstanceFromZone(cls, extraBytes, zone);
}

</code></pre></div><p>可以看到，创建对象最终调用的函数都是_class_createInstanceFromZone，不管objc的版本是新版还是旧版。</p><p>如果创建成功就返回objc，如果创建失败，就会调用callBadAllocHandler方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>id</span> <span style=color:#a6e22e>callBadAllocHandler</span>(<span style=color:#66d9ef>Class</span> cls)
{
    <span style=color:#75715e>// fixme add re-entrancy protection in case allocation fails inside handler
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> (<span style=color:#f92672>*</span>badAllocHandler)(cls);
}

<span style=color:#66d9ef>static</span> <span style=color:#a6e22e>id</span>(<span style=color:#f92672>*</span>badAllocHandler)(<span style=color:#66d9ef>Class</span>) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>defaultBadAllocHandler;

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>id</span> <span style=color:#a6e22e>defaultBadAllocHandler</span>(<span style=color:#66d9ef>Class</span> cls)
{
    _objc_fatal(<span style=color:#e6db74>&#34;attempt to allocate object of class &#39;%s&#39; failed&#34;</span>, 
                cls<span style=color:#f92672>-&gt;</span>nameForLogging());
}

</code></pre></div><p>创建对象失败后，最终会调用_objc_fatal输出"attempt to allocate object of class failed"创建对象失败。</p><p>到此就完成了callAlloc中hasCustomAWZ( )返回YES的情况。那么hasCustomAWZ( )函数返回NO，情况是怎么样的呢？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> cls<span style=color:#f92672>-&gt;</span>ISA()<span style=color:#f92672>-&gt;</span>hasCustomAWZ()) {
        <span style=color:#75715e>// No alloc/allocWithZone implementation. Go straight to the allocator.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// fixme store hasCustomAWZ in the non-meta class and 
</span><span style=color:#75715e></span>        <span style=color:#75715e>// add it to canAllocFast&#39;s summary
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (cls<span style=color:#f92672>-&gt;</span>canAllocFast()) {
            <span style=color:#75715e>// No ctors, raw isa, etc. Go straight to the metal.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>bool</span> dtor <span style=color:#f92672>=</span> cls<span style=color:#f92672>-&gt;</span>hasCxxDtor();
            <span style=color:#66d9ef>id</span> obj <span style=color:#f92672>=</span> (<span style=color:#66d9ef>id</span>)calloc(<span style=color:#ae81ff>1</span>, cls<span style=color:#f92672>-&gt;</span>bits.fastInstanceSize());
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>obj) <span style=color:#66d9ef>return</span> callBadAllocHandler(cls);
            obj<span style=color:#f92672>-&gt;</span>initInstanceIsa(cls, dtor);
            <span style=color:#66d9ef>return</span> obj;
        }
        <span style=color:#66d9ef>else</span> {
            <span style=color:#75715e>// Has ctor or raw isa or something. Use the slower path.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>id</span> obj <span style=color:#f92672>=</span> class_createInstance(cls, <span style=color:#ae81ff>0</span>);
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>obj) <span style=color:#66d9ef>return</span> callBadAllocHandler(cls);
            <span style=color:#66d9ef>return</span> obj;
        }
    }

</code></pre></div><p>这一段是hasCustomAWZ( )返回NO的情况，对应的是当前class没有默认的allocWithZone的情况。</p><p>在没有默认的allocWithZone的情况下，还需要再次判断当前的class是否支持快速alloc。如果可以，直接调用calloc函数，申请1块bits.fastInstanceSize()大小的内存空间，如果创建失败，也会调用callBadAllocHandler函数。</p><p>如果创建成功，就去初始化Isa指针和dtor。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>hasCxxDtor</span>() {
        <span style=color:#66d9ef>return</span> data()<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> RW_HAS_CXX_DTOR;
    }

<span style=color:#75715e>// class or superclass has .cxx_destruct implementation
</span><span style=color:#75715e></span><span style=color:#75715e>#define RW_HAS_CXX_DTOR       (1&lt;&lt;17)
</span><span style=color:#75715e></span>
</code></pre></div><p>dtor是用来判断当前class或者superclass是否有.cxx_destruct函数的实现。</p><p>如果当前的class不支持快速alloc，那么就乖乖的去调用class_createInstance(cls, 0);方法去创建一个新的对象。</p><p>小结一下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/30_3.png alt></p><p>经过上面的一系列判断，“孕育对象”的过程最终落在了_class_createInstanceFromZone函数上了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#a6e22e>__attribute__</span>((always_inline))  <span style=color:#66d9ef>id</span> _class_createInstanceFromZone(<span style=color:#66d9ef>Class</span> cls, size_t extraBytes, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>zone, 
                              <span style=color:#66d9ef>bool</span> cxxConstruct <span style=color:#f92672>=</span> true, 
                              size_t <span style=color:#f92672>*</span>outAllocatedSize <span style=color:#f92672>=</span> nil)
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>cls) <span style=color:#66d9ef>return</span> nil;

    assert(cls<span style=color:#f92672>-&gt;</span>isRealized());

    <span style=color:#75715e>// Read class&#39;s info bits all at once for performance
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> hasCxxCtor <span style=color:#f92672>=</span> cls<span style=color:#f92672>-&gt;</span>hasCxxCtor();
    <span style=color:#66d9ef>bool</span> hasCxxDtor <span style=color:#f92672>=</span> cls<span style=color:#f92672>-&gt;</span>hasCxxDtor();
    <span style=color:#66d9ef>bool</span> fast <span style=color:#f92672>=</span> cls<span style=color:#f92672>-&gt;</span>canAllocIndexed();

    size_t size <span style=color:#f92672>=</span> cls<span style=color:#f92672>-&gt;</span>instanceSize(extraBytes);
    <span style=color:#66d9ef>if</span> (outAllocatedSize) <span style=color:#f92672>*</span>outAllocatedSize <span style=color:#f92672>=</span> size;

    <span style=color:#66d9ef>id</span> obj;
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>UseGC  <span style=color:#f92672>&amp;&amp;</span>  <span style=color:#f92672>!</span>zone  <span style=color:#f92672>&amp;&amp;</span>  fast) {
        obj <span style=color:#f92672>=</span> (<span style=color:#66d9ef>id</span>)calloc(<span style=color:#ae81ff>1</span>, size);
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>obj) <span style=color:#66d9ef>return</span> nil;
        obj<span style=color:#f92672>-&gt;</span>initInstanceIsa(cls, hasCxxDtor);
    } 
    <span style=color:#66d9ef>else</span> {
<span style=color:#75715e>#if SUPPORT_GC
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (UseGC) {
            obj <span style=color:#f92672>=</span> (<span style=color:#66d9ef>id</span>)auto_zone_allocate_object(gc_zone, size,
                                                AUTO_OBJECT_SCANNED, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
        } <span style=color:#66d9ef>else</span> 
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (zone) {
            obj <span style=color:#f92672>=</span> (<span style=color:#66d9ef>id</span>)malloc_zone_calloc ((malloc_zone_t <span style=color:#f92672>*</span>)zone, <span style=color:#ae81ff>1</span>, size);
        } <span style=color:#66d9ef>else</span> {
            obj <span style=color:#f92672>=</span> (<span style=color:#66d9ef>id</span>)calloc(<span style=color:#ae81ff>1</span>, size);
        }
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>obj) <span style=color:#66d9ef>return</span> nil;

        <span style=color:#75715e>// Use non-indexed isa on the assumption that they might be 
</span><span style=color:#75715e></span>        <span style=color:#75715e>// doing something weird with the zone or RR.
</span><span style=color:#75715e></span>        obj<span style=color:#f92672>-&gt;</span>initIsa(cls);
    }

    <span style=color:#66d9ef>if</span> (cxxConstruct <span style=color:#f92672>&amp;&amp;</span> hasCxxCtor) {
        obj <span style=color:#f92672>=</span> _objc_constructOrFree(obj, cls);
    }

    <span style=color:#66d9ef>return</span> obj;
}

</code></pre></div><p>ctor 和 dtor 分别是什么呢？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>hasCxxCtor</span>() {
        <span style=color:#75715e>// addSubclass() propagates this flag from the superclass.
</span><span style=color:#75715e></span>        assert(isRealized());
        <span style=color:#66d9ef>return</span> bits.hasCxxCtor();
    }

    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>hasCxxCtor</span>() {
        <span style=color:#66d9ef>return</span> data()<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> RW_HAS_CXX_CTOR;
    }

<span style=color:#75715e>#define RW_HAS_CXX_CTOR       (1&lt;&lt;18)
</span><span style=color:#75715e></span>
</code></pre></div><p>ctor是判断当前class或者superclass 是否有.cxx_construct构造方法的实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>hasCxxDtor</span>() {
        <span style=color:#75715e>// addSubclass() propagates this flag from the superclass.
</span><span style=color:#75715e></span>        assert(isRealized());
        <span style=color:#66d9ef>return</span> bits.hasCxxDtor();
    }

    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>hasCxxDtor</span>() {
        <span style=color:#66d9ef>return</span> data()<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> RW_HAS_CXX_DTOR;
    }

<span style=color:#75715e>#define RW_HAS_CXX_DTOR       (1&lt;&lt;17)
</span><span style=color:#75715e></span>
</code></pre></div><p>dtor是判断判断当前class或者superclass 是否有.cxx_destruct析构方法的实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    size_t <span style=color:#a6e22e>instanceSize</span>(size_t extraBytes) {
        size_t size <span style=color:#f92672>=</span> alignedInstanceSize() <span style=color:#f92672>+</span> extraBytes;
        <span style=color:#75715e>// CF requires all objects be at least 16 bytes.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>16</span>) size <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>;
        <span style=color:#66d9ef>return</span> size;
    }

    uint32_t <span style=color:#a6e22e>alignedInstanceSize</span>() {
        <span style=color:#66d9ef>return</span> word_align(unalignedInstanceSize());
    }

    uint32_t <span style=color:#a6e22e>unalignedInstanceSize</span>() {
        assert(isRealized());
        <span style=color:#66d9ef>return</span> data()<span style=color:#f92672>-&gt;</span>ro<span style=color:#f92672>-&gt;</span>instanceSize;
    }

</code></pre></div><p>实例大小 instanceSize会存储在类的 isa_t结构体中，然后经过对齐最后返回。</p><p>注意：Core Foundation 需要所有的对象的大小都必须大于或等于 16 字节。</p><p>在获取对象大小之后，直接调用calloc函数就可以为对象分配内存空间了。</p><p>关于calloc函数</p><blockquote><p>The calloc( ) function contiguously allocates enough space for count objects that are size bytes of memory each and returns a pointer to the allocated memory. The allocated memory is filled with bytes of value zero.</p></blockquote><p>这个函数也是为什么我们申请出来的对象，初始值是0或者nil的原因。因为这个calloc( )函数会默认的把申请出来的空间初始化为0或者nil。</p><p>申请完内存空间之后，还需要再初始化Isa指针。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
obj<span style=color:#f92672>-&gt;</span>initInstanceIsa(cls, hasCxxDtor);

obj<span style=color:#f92672>-&gt;</span>initIsa(cls);

</code></pre></div><p>初始化Isa指针有这上面两个函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span>  objc_object<span style=color:#f92672>::</span>initInstanceIsa(<span style=color:#66d9ef>Class</span> cls, <span style=color:#66d9ef>bool</span> hasCxxDtor)
{
    assert(<span style=color:#f92672>!</span>UseGC);
    assert(<span style=color:#f92672>!</span>cls<span style=color:#f92672>-&gt;</span>requiresRawIsa());
    assert(hasCxxDtor <span style=color:#f92672>==</span> cls<span style=color:#f92672>-&gt;</span>hasCxxDtor());

    initIsa(cls, true, hasCxxDtor);
}


<span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span>  objc_object<span style=color:#f92672>::</span>initIsa(<span style=color:#66d9ef>Class</span> cls)
{
    initIsa(cls, false, false);
}

</code></pre></div><p>从上述源码中，我们也能看出，最终都是调用了initIsa函数，只不过入参不同。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span>  objc_object<span style=color:#f92672>::</span>initIsa(<span style=color:#66d9ef>Class</span> cls, <span style=color:#66d9ef>bool</span> indexed, <span style=color:#66d9ef>bool</span> hasCxxDtor) 
{ 
    assert(<span style=color:#f92672>!</span>isTaggedPointer()); 
    
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>indexed) {
        isa.cls <span style=color:#f92672>=</span> cls;
    } <span style=color:#66d9ef>else</span> {
        assert(<span style=color:#f92672>!</span>DisableIndexedIsa);
        isa.bits <span style=color:#f92672>=</span> ISA_MAGIC_VALUE;
        <span style=color:#75715e>// isa.magic is part of ISA_MAGIC_VALUE
</span><span style=color:#75715e></span>        <span style=color:#75715e>// isa.indexed is part of ISA_MAGIC_VALUE
</span><span style=color:#75715e></span>        isa.has_cxx_dtor <span style=color:#f92672>=</span> hasCxxDtor;
        isa.shiftcls <span style=color:#f92672>=</span> (uintptr_t)cls <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>;
    }
}

</code></pre></div><p>初始化的过程就是对isa_t结构体初始化的过程。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e># if __arm64__
</span><span style=color:#75715e>#   define ISA_MASK        0x0000000ffffffff8ULL
</span><span style=color:#75715e>#   define ISA_MAGIC_MASK  0x000003f000000001ULL
</span><span style=color:#75715e>#   define ISA_MAGIC_VALUE 0x000001a000000001ULL
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> {
        uintptr_t indexed           : <span style=color:#ae81ff>1</span>;
        uintptr_t has_assoc         : <span style=color:#ae81ff>1</span>;
        uintptr_t has_cxx_dtor      : <span style=color:#ae81ff>1</span>;
        uintptr_t shiftcls          : <span style=color:#ae81ff>33</span>; <span style=color:#75715e>// MACH_VM_MAX_ADDRESS 0x1000000000
</span><span style=color:#75715e></span>        uintptr_t magic             : <span style=color:#ae81ff>6</span>;
        uintptr_t weakly_referenced : <span style=color:#ae81ff>1</span>;
        uintptr_t deallocating      : <span style=color:#ae81ff>1</span>;
        uintptr_t has_sidetable_rc  : <span style=color:#ae81ff>1</span>;
        uintptr_t extra_rc          : <span style=color:#ae81ff>19</span>;
<span style=color:#75715e>#       define RC_ONE   (1ULL&lt;&lt;45)
</span><span style=color:#75715e>#       define RC_HALF  (1ULL&lt;&lt;18)
</span><span style=color:#75715e></span>    };

</code></pre></div><p>具体初始化的过程请参见这篇<a href=http://www.jianshu.com/p/9d649ce6d0b8>神经病院Objective-C Runtime入院第一天——isa和Class</a></p><blockquote><p><strong>将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0</strong>。
绝大多数机器的架构都是 <a href=https://en.wikipedia.org/wiki/Byte_addressing>byte-addressable</a> 的，但是对象的内存地址必须对齐到字节的倍数，这样可以提高代码运行的性能，在 iPhone5s 中虚拟地址为 33 位，所以用于对齐的最后三位比特为 000，我们只会用其中的 30 位来表示对象的地址。</p></blockquote><p>至此，孕育对象的过程就完成了。</p><h4 id=二对象的出生>二.对象的出生</h4><p><img src=https://img.halfrost.com/Blog/ArticleImage/30_4.png alt></p><p>一旦当我们调用init方法的时候，对象就会“出生”了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>init</span> {
    <span style=color:#66d9ef>return</span> _objc_rootInit(self);
}

</code></pre></div><p>init会调用_objc_rootInit方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>id</span> <span style=color:#a6e22e>_objc_rootInit</span>(<span style=color:#66d9ef>id</span> obj)
{
    <span style=color:#75715e>// In practice, it will be hard to rely on this function.
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Many classes do not properly chain -init calls.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> obj;
}

</code></pre></div><p>而_objc_rootInit方法的作用也仅仅就是返回了当前对象而已。</p><h4 id=三对象的生长>三.对象的生长</h4><p><img src=https://img.halfrost.com/Blog/ArticleImage/30_5.png alt></p><p>关于对象的生长，其实是想谈谈对象初始化之后，访问它的属性和方法，它们在内存中的样子。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>#import &lt;Foundation/Foundation.h&gt;
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>Student</span> : <span style=color:#a6e22e>NSObject</span>
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>strong</span> , <span style=color:#66d9ef>nonatomic</span>) NSString <span style=color:#f92672>*</span>name;
+(<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>study</span>;
-(<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>run</span>;
<span style=color:#66d9ef>@end</span>


<span style=color:#75715e>#import &#34;Student.h&#34;
</span><span style=color:#75715e></span><span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>Student</span>

+(<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>study</span>
{
    NSLog(<span style=color:#e6db74>@&#34;Study&#34;</span>); 
}

-(<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>run</span>
{
    NSLog(<span style=color:#e6db74>@&#34;Run&#34;</span>);
}
<span style=color:#66d9ef>@end</span>

</code></pre></div><p>这里我们新建一个Student类，来举例说明。这个类很简单，只有一个name的属性，加上一个类方法，和一个实例方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
        Student  <span style=color:#f92672>*</span>stu <span style=color:#f92672>=</span> [[Student alloc]init];
        
        NSLog(<span style=color:#e6db74>@&#34;Student&#39;s class is %@&#34;</span>, [stu <span style=color:#66d9ef>class</span>]);
        NSLog(<span style=color:#e6db74>@&#34;Student&#39;s meta class is %@&#34;</span>, object_getClass([stu <span style=color:#66d9ef>class</span>]));
        NSLog(<span style=color:#e6db74>@&#34;Student&#39;s meta class&#39;s superclass is %@&#34;</span>, object_getClass(object_getClass([stu <span style=color:#66d9ef>class</span>])));
        
        <span style=color:#66d9ef>Class</span> currentClass <span style=color:#f92672>=</span> [Student <span style=color:#66d9ef>class</span>];
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>)
        {
            NSLog(<span style=color:#e6db74>@&#34;Following the isa pointer %d times gives %p %@&#34;</span>, i, currentClass,currentClass);
            currentClass <span style=color:#f92672>=</span> object_getClass(currentClass);
        }
        
        NSLog(<span style=color:#e6db74>@&#34;NSObject&#39;s class is %p&#34;</span>, [NSObject <span style=color:#66d9ef>class</span>]);
        NSLog(<span style=color:#e6db74>@&#34;NSObject&#39;s meta class is %p&#34;</span>, object_getClass([NSObject <span style=color:#66d9ef>class</span>]));

</code></pre></div><p>写出上述的代码，分析一下结构。</p><p>输出如下:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

Student<span style=color:#960050;background-color:#1e0010>&#39;</span>s <span style=color:#66d9ef>class</span> is Student
Student<span style=color:#960050;background-color:#1e0010>&#39;</span>s meta <span style=color:#66d9ef>class</span> is Student
Student<span style=color:#960050;background-color:#1e0010>&#39;</span>s meta <span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>&#39;</span>s superclass is NSObject
Following the isa pointer <span style=color:#ae81ff>1</span> times gives <span style=color:#ae81ff>0x100004d90</span> Student
Following the isa pointer <span style=color:#ae81ff>2</span> times gives <span style=color:#ae81ff>0x100004d68</span> Student
Following the isa pointer <span style=color:#ae81ff>3</span> times gives <span style=color:#ae81ff>0x7fffba0b20f0</span> NSObject
Following the isa pointer <span style=color:#ae81ff>4</span> times gives <span style=color:#ae81ff>0x7fffba0b20f0</span> NSObject
NSObject<span style=color:#960050;background-color:#1e0010>&#39;</span>s <span style=color:#66d9ef>class</span> is <span style=color:#ae81ff>0x7fffba0b2140</span>
NSObject<span style=color:#960050;background-color:#1e0010>&#39;</span>s meta <span style=color:#66d9ef>class</span> is <span style=color:#ae81ff>0x7fffba0b20f0</span>

</code></pre></div><p>经过上面的打印结果，我们可以知道，一个类的实例的isa是指向它的class，如下图：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/30_6.png alt></p><p>一个类的实例，虚线指向灰色的区域，灰色的区域是一个Class pair，里面包含两个东西，一个是类，另一个是meta-class。类的isa指向meta-class。由于student是继承NSObject，所以Student的class的meta-class的superclass是NSObject。</p><p>为了弄清楚这3个东西里面分别存了些什么，我们进一步的打印一些信息。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

+ (NSArray <span style=color:#f92672>*</span>)<span style=color:#a6e22e>instanceVariables</span> {
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> outCount;
    Ivar <span style=color:#f92672>*</span>ivars <span style=color:#f92672>=</span> class_copyIvarList([self <span style=color:#66d9ef>class</span>], <span style=color:#f92672>&amp;</span>outCount);
    NSMutableArray <span style=color:#f92672>*</span>result <span style=color:#f92672>=</span> [NSMutableArray array];
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> outCount; i<span style=color:#f92672>++</span>) {
        NSString <span style=color:#f92672>*</span>type <span style=color:#f92672>=</span> [NSString decodeType:ivar_getTypeEncoding(ivars[i])];
        NSString <span style=color:#f92672>*</span>name <span style=color:#f92672>=</span> [NSString stringWithCString:ivar_getName(ivars[i]) encoding:NSUTF8StringEncoding];
        NSString <span style=color:#f92672>*</span>ivarDescription <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;%@ %@&#34;</span>, type, name];
        [result addObject:ivarDescription];
    }
    free(ivars);
    <span style=color:#66d9ef>return</span> result.count <span style=color:#f92672>?</span> [result <span style=color:#66d9ef>copy</span>] <span style=color:#f92672>:</span> nil;
}

</code></pre></div><p>从之前的打印信息我们能知道，0x100004d90是类的地址。0x100004d68是meta-class类的地址。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>po</span> [<span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>100004</span>d<span style=color:#ae81ff>90</span> <span style=color:#a6e22e>instanceVariables</span>]<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>po</span> [<span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>100004</span>d<span style=color:#ae81ff>68</span> <span style=color:#a6e22e>instanceVariables</span>]<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>打印出来：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#f92672>&lt;</span>__NSSingleObjectArrayI <span style=color:#ae81ff>0x100302460</span><span style=color:#f92672>&gt;</span>(
  NSString<span style=color:#f92672>*</span> _name
)

nil
</code></pre></div><p>从这里就知道了，属性这些是存储在类中。</p><p>接下来就是关于类方法和实例方法的认识，+号方法和-号方法的认识。</p><p>在内存中其实没有+号和-号方法的概念。做个试验：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (NSArray <span style=color:#f92672>*</span>)<span style=color:#a6e22e>ClassMethodNames</span>
{
    NSMutableArray <span style=color:#f92672>*</span> array <span style=color:#f92672>=</span> [NSMutableArray array];
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> methodCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    Method <span style=color:#f92672>*</span> methodList <span style=color:#f92672>=</span> class_copyMethodList([self <span style=color:#66d9ef>class</span>], <span style=color:#f92672>&amp;</span>methodCount);
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> i;
    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> methodCount; i<span style=color:#f92672>++</span>) {
        [array addObject: NSStringFromSelector(method_getName(methodList[i]))];
    }
    
    free(methodList);
    <span style=color:#66d9ef>return</span> array;
}


</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
po [<span style=color:#ae81ff>0x100004d90</span> ClassMethodNames]
po [<span style=color:#ae81ff>0x100004d68</span> ClassMethodNames]

</code></pre></div><p>打印出来：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>&lt;<span style=color:#a6e22e>__NSArrayM</span> <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>100303310</span>&gt;(<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>.<span style=color:#a6e22e>cxx_destruct</span>,<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>name</span>,<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>setName</span>:,<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>run</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>&lt;<span style=color:#a6e22e>__NSArrayM</span> <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>100303800</span>&gt;(<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>study</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>0x100004d90是类对象，里面存储的是-号方法，还有另外3个方法，getter，setter，还有.cxx_destruct方法</p><p>0x100004d68是meta-class，里面存储的是+号方法。</p><p>当然在runtime的meta-class有一处很特殊，那就是NSObject的meta-class，它的superclass是它自己本身。为了防止调用NSObject协议里面的减号方法可能会出现崩溃，比如copy的-号方法，于是在NSObject的meta-class里面把所有的NSObject的+号方法都重新实现了一遍，就是为了消息传递到这里，拦截了一遍。所以一般NSObject协议方法同一个方法都有+号和-号方法。</p><p>值得说明的是，class和meta-class都是单例。</p><p>关于对象，所有的对象在内存里面都有一个isa，isa就是一个小“雷达”，有了它，就可以在runtime下给一个对象发送消息了。</p><p>所以对象的实质：Objc中的对象是一个指向ClassObject地址的变量，即 id obj = &ClassObject 。</p><p>关于对象的属性实质是，void *ivar = &obj + offset(N)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    NSString <span style=color:#f92672>*</span>myName <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;halfrost&#34;</span>;
    NSLog(<span style=color:#e6db74>@&#34;myName 地址 = %p , 大小 = %lu  &#34;</span>,<span style=color:#f92672>&amp;</span>myName ,<span style=color:#66d9ef>sizeof</span>(myName));
    
    <span style=color:#66d9ef>id</span> cls <span style=color:#f92672>=</span> [Student <span style=color:#66d9ef>class</span>];
    NSLog(<span style=color:#e6db74>@&#34;Student class = %@ 地址 = %p , 大小 = %lu&#34;</span>, cls, <span style=color:#f92672>&amp;</span>cls,<span style=color:#66d9ef>sizeof</span>(cls));
    
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>obj <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>cls;
    NSLog(<span style=color:#e6db74>@&#34;Void *obj = %@ 地址 = %p , 大小 = %lu&#34;</span>, obj,<span style=color:#f92672>&amp;</span>obj, <span style=color:#66d9ef>sizeof</span>(obj));
    
    NSLog(<span style=color:#e6db74>@&#34;%@  %p&#34;</span>,((<span style=color:#66d9ef>__bridge</span> Student <span style=color:#f92672>*</span>)obj).name,((<span style=color:#66d9ef>__bridge</span> Student <span style=color:#f92672>*</span>)obj).name);

</code></pre></div><p>输出</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>myName</span> <span style=color:#a6e22e>地址</span> = <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>562</span>eeaa<span style=color:#ae81ff>8</span> , <span style=color:#a6e22e>大小</span> = <span style=color:#ae81ff>8</span>  <span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>Student</span> <span style=color:#a6e22e>class</span> = <span style=color:#a6e22e>Student</span> <span style=color:#a6e22e>地址</span> = <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>562</span>eeaa<span style=color:#ae81ff>0</span> , <span style=color:#a6e22e>大小</span> = <span style=color:#ae81ff>8</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>Void</span> *<span style=color:#a6e22e>obj</span> = &lt;<span style=color:#a6e22e>Student</span>: <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>562</span>eeaa<span style=color:#ae81ff>0</span>&gt; <span style=color:#a6e22e>地址</span> = <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>562</span>eea<span style=color:#ae81ff>98</span> , <span style=color:#a6e22e>大小</span> = <span style=color:#ae81ff>8</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>halfrost</span>  <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>10</span>a<span style=color:#ae81ff>25</span>c<span style=color:#ae81ff>068</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>从这个例子就可以说明，对象的实质就是指向类对象的地址变量，从上面例子里面obj就可以看出， id obj = &ClassObject ，cls是Student的类对象，所以obj是Student的对象。</p><p>类对象是在main函数执行之前就加载进内存的，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法（动态添加 Class、swizzle 等等才能生效）</p><p>具体可以看这篇文章<a href=http://blog.sunnyxx.com/2014/08/30/objc-pre-main/>iOS 程序 main 函数之前发生了什么</a></p><p>还是回到例子中来，关于对象的属性，就是obj的地址加上偏移量，就可以访问到，上述的例子中，obj地址是0x7fff562eea98，往下偏移8，到了class的地址，0x7fff562eeaa0，再往下偏移8，就到了name属性的地址，0x7fff562eeaa8。在name中存储的是字符串的首地址，根据打印信息也看到了，存储的是一个指针，指向的0x10a25c068的地址。</p><p>如果我们打印一下这个地址：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/30_9.png alt></p><p>就会发现里面存的就是我们的字符串。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/30_10.png alt></p><p>总结一下就是上面这张图，每个对象的isa都存的是Class的内存地址，Class是在main函数执行之前就加载进内存的，并且由Runtime所管理。所以只需要构造一个指向Class的指针，即isa，就可以成为一个对象。</p><p>而对象的属性，就是在对象的首地址上进行的偏移。如上图，当知道对象的首地址是0x7fff562eea98，那么偏移8个字节就到了isa，再偏移8个字节就到了name属性了。对象的属性就是在内存中偏移寻址取值的过程。</p><h4 id=四对象的销毁>四.对象的销毁</h4><p><img src=https://img.halfrost.com/Blog/ArticleImage/30_7.png alt></p><p>对象的销毁就是调用dealloc方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>dealloc</span> {
    _objc_rootDealloc(self);
}

</code></pre></div><p>dealloc方法会调用_objc_rootDealloc方法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>_objc_rootDealloc</span>(<span style=color:#66d9ef>id</span> obj)
{
    assert(obj);

    obj<span style=color:#f92672>-&gt;</span>rootDealloc();
}


<span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> objc_object<span style=color:#f92672>::</span>rootDealloc()
{
    assert(<span style=color:#f92672>!</span>UseGC);
    <span style=color:#66d9ef>if</span> (isTaggedPointer()) <span style=color:#66d9ef>return</span>;

    <span style=color:#66d9ef>if</span> (isa.indexed  <span style=color:#f92672>&amp;&amp;</span>  
        <span style=color:#f92672>!</span>isa.weakly_referenced  <span style=color:#f92672>&amp;&amp;</span>  
        <span style=color:#f92672>!</span>isa.has_assoc  <span style=color:#f92672>&amp;&amp;</span>  
        <span style=color:#f92672>!</span>isa.has_cxx_dtor  <span style=color:#f92672>&amp;&amp;</span>  
        <span style=color:#f92672>!</span>isa.has_sidetable_rc)
    {
        assert(<span style=color:#f92672>!</span>sidetable_present());
        free(this);
    } 
    <span style=color:#66d9ef>else</span> {
        object_dispose((<span style=color:#66d9ef>id</span>)this);
    }
}

</code></pre></div><p>如果是TaggedPointer，直接return。</p><p>indexed是代表是否开启isa指针优化。weakly_referenced代表对象被指向或者曾经指向一个 ARC 的弱变量。has_assoc代表对象含有或者曾经含有关联引用。has_cxx_dtor之前提到过了，是析构器。has_sidetable_rc判断该对象的引用计数是否过大。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>id</span>  <span style=color:#a6e22e>object_dispose</span>(<span style=color:#66d9ef>id</span> obj)
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>obj) <span style=color:#66d9ef>return</span> nil;

    objc_destructInstance(obj);
    
<span style=color:#75715e>#if SUPPORT_GC
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (UseGC) {
        auto_zone_retain(gc_zone, obj); <span style=color:#75715e>// gc free expects rc==1
</span><span style=color:#75715e></span>    }
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
    free(obj);

    <span style=color:#66d9ef>return</span> nil;
}

</code></pre></div><p>object_dispose会调用objc_destructInstance。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#75715e>/***********************************************************************
</span><span style=color:#75715e>* objc_destructInstance
</span><span style=color:#75715e>* Destroys an instance without freeing memory. 
</span><span style=color:#75715e>* Calls C++ destructors.
</span><span style=color:#75715e>* Calls ARR ivar cleanup.
</span><span style=color:#75715e>* Removes associative references.
</span><span style=color:#75715e>* Returns `obj`. Does nothing if `obj` is nil.
</span><span style=color:#75715e>* Be warned that GC DOES NOT CALL THIS. If you edit this, also edit finalize.
</span><span style=color:#75715e>* CoreFoundation and other clients do call this under GC.
</span><span style=color:#75715e>**********************************************************************/</span>
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>objc_destructInstance</span>(<span style=color:#66d9ef>id</span> obj) 
{
    <span style=color:#66d9ef>if</span> (obj) {
        <span style=color:#75715e>// Read all of the flags at once for performance.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>bool</span> cxx <span style=color:#f92672>=</span> obj<span style=color:#f92672>-&gt;</span>hasCxxDtor();
        <span style=color:#66d9ef>bool</span> assoc <span style=color:#f92672>=</span> <span style=color:#f92672>!</span>UseGC <span style=color:#f92672>&amp;&amp;</span> obj<span style=color:#f92672>-&gt;</span>hasAssociatedObjects();
        <span style=color:#66d9ef>bool</span> dealloc <span style=color:#f92672>=</span> <span style=color:#f92672>!</span>UseGC;

        <span style=color:#75715e>// This order is important.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (cxx) object_cxxDestruct(obj);
        <span style=color:#66d9ef>if</span> (assoc) _object_remove_assocations(obj);
        <span style=color:#66d9ef>if</span> (dealloc) obj<span style=color:#f92672>-&gt;</span>clearDeallocating();
    }

    <span style=color:#66d9ef>return</span> obj;
}

</code></pre></div><p>销毁一个对象，靠的是底层的C++析构函数完成的。还需要移除associative的引用。</p><p>接下来就依次详细看看销毁对象的3个方法。</p><h5 id=1object_cxxdestruct>1.object_cxxDestruct</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>object_cxxDestruct</span>(<span style=color:#66d9ef>id</span> obj)
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>obj) <span style=color:#66d9ef>return</span>;
    <span style=color:#66d9ef>if</span> (obj<span style=color:#f92672>-&gt;</span>isTaggedPointer()) <span style=color:#66d9ef>return</span>;
    object_cxxDestructFromClass(obj, obj<span style=color:#f92672>-&gt;</span>ISA());
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>object_cxxDestructFromClass</span>(<span style=color:#66d9ef>id</span> obj, <span style=color:#66d9ef>Class</span> cls)
{
    <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>dtor)(<span style=color:#66d9ef>id</span>);

    <span style=color:#75715e>// Call cls&#39;s dtor first, then superclasses&#39;s dtors.
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>for</span> ( ; cls; cls <span style=color:#f92672>=</span> cls<span style=color:#f92672>-&gt;</span>superclass) {
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>cls<span style=color:#f92672>-&gt;</span>hasCxxDtor()) <span style=color:#66d9ef>return</span>; 
        dtor <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span>(<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>id</span>))
            lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct);
        <span style=color:#66d9ef>if</span> (dtor <span style=color:#f92672>!=</span> (<span style=color:#66d9ef>void</span>(<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>id</span>))_objc_msgForward_impcache) {
            <span style=color:#66d9ef>if</span> (PrintCxxCtors) {
                _objc_inform(<span style=color:#e6db74>&#34;CXX: calling C++ destructors for class %s&#34;</span>, 
                             cls<span style=color:#f92672>-&gt;</span>nameForLogging());
            }
            (<span style=color:#f92672>*</span>dtor)(obj);
        }
    }
}


</code></pre></div><p>从子类开始沿着继承链一直找到父类，向上搜寻SEL_cxx_destruct
这个selector，找到函数实现(void (*)(id)(函数指针)并执行。</p><p>以下引用<a href=http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/>ARC下dealloc过程及.cxx_destruct的探究</a>的内容：</p><p>从<a href=http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03>这篇文章</a>中：</p><blockquote><p>ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed.</p></blockquote><p>和《Effective Objective-C 2.0》中提到的：</p><blockquote><p>When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.</p></blockquote><p>可以了解到，.cxx_destruct方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作。</p><p>在ARC中dealloc方法在最后一次release后被调用，但此时实例变量（Ivars）并未释放，<strong>父类的dealloc的方法将在子类dealloc方法返回后自动调用</strong>。ARC下对象的实例变量在根类[NSObject dealloc]中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）</p><p>经过@sunnyxx文中的研究：
1.ARC下对象的成员变量于编译器插入的.cxx_desctruct方法自动释放。
2.ARC下[super dealloc]方法也由编译器自动插入。</p><p>至于.cxx_destruct方法的实现，还请看@sunnyxx 那篇文章里面详细的分析。</p><h5 id=2_object_remove_assocations>2._object_remove_assocations</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>_object_remove_assocations</span>(<span style=color:#66d9ef>id</span> object) {
    vector<span style=color:#f92672>&lt;</span> ObjcAssociation,ObjcAllocator<span style=color:#f92672>&lt;</span>ObjcAssociation<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> elements;
    {
        AssociationsManager manager;
        AssociationsHashMap <span style=color:#f92672>&amp;</span>associations(manager.associations());
        <span style=color:#66d9ef>if</span> (associations.size() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span>;
        disguised_ptr_t disguised_object <span style=color:#f92672>=</span> DISGUISE(object);
        AssociationsHashMap<span style=color:#f92672>::</span>iterator i <span style=color:#f92672>=</span> associations.find(disguised_object);
        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>!=</span> associations.end()) {
            <span style=color:#75715e>// copy all of the associations that need to be removed.
</span><span style=color:#75715e></span>            ObjectAssociationMap <span style=color:#f92672>*</span>refs <span style=color:#f92672>=</span> i<span style=color:#f92672>-&gt;</span>second;
            <span style=color:#66d9ef>for</span> (ObjectAssociationMap<span style=color:#f92672>::</span>iterator j <span style=color:#f92672>=</span> refs<span style=color:#f92672>-&gt;</span>begin(), end <span style=color:#f92672>=</span> refs<span style=color:#f92672>-&gt;</span>end(); j <span style=color:#f92672>!=</span> end; <span style=color:#f92672>++</span>j) {
                elements.push_back(j<span style=color:#f92672>-&gt;</span>second);
            }
            <span style=color:#75715e>// remove the secondary table.
</span><span style=color:#75715e></span>            delete refs;
            associations.erase(i);
        }
    }
    <span style=color:#75715e>// the calls to releaseValue() happen outside of the lock.
</span><span style=color:#75715e></span>    for_each(elements.begin(), elements.end(), ReleaseValue());
}


</code></pre></div><p>在移除关联对象object的时候，会先去判断object的isa_t中的第二位has_assoc的值，当object 存在并且object->hasAssociatedObjects( )值为1的时候，才会去调用_object_remove_assocations方法。</p><p>_object_remove_assocations方法的目的是删除第二张ObjcAssociationMap表，即删除所有的关联对象。删除第二张表，就需要在第一张AssociationsHashMap表中遍历查找。这里会把第二张ObjcAssociationMap表中所有的ObjcAssociation对象都存到一个数组elements里面，然后调用associations.erase( )删除第二张表。最后再遍历elements数组，把ObjcAssociation对象依次释放。</p><p>这里移除的方式和Associated Object关联对象里面的remove方法是完全一样的。</p><h5 id=3cleardeallocating->3.clearDeallocating( )</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> objc_object<span style=color:#f92672>::</span>clearDeallocating()
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isa.indexed) {
        <span style=color:#75715e>// Slow path for raw pointer isa.
</span><span style=color:#75715e></span>        sidetable_clearDeallocating();
    }
    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (isa.weakly_referenced  <span style=color:#f92672>||</span>  isa.has_sidetable_rc) {
        <span style=color:#75715e>// Slow path for non-pointer isa with weak refs and/or side table data.
</span><span style=color:#75715e></span>        clearDeallocating_slow();
    }

    assert(<span style=color:#f92672>!</span>sidetable_present());
}

</code></pre></div><p>这里涉及到了2个clear函数，接下来一个个的看。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>void</span> objc_object<span style=color:#f92672>::</span>sidetable_clearDeallocating()
{
    SideTable<span style=color:#f92672>&amp;</span> table <span style=color:#f92672>=</span> SideTables()[this];

    <span style=color:#75715e>// clear any weak table items
</span><span style=color:#75715e></span>    <span style=color:#75715e>// clear extra retain count and deallocating bit
</span><span style=color:#75715e></span>    <span style=color:#75715e>// (fixme warn or abort if extra retain count == 0 ?)
</span><span style=color:#75715e></span>    table.lock();
    RefcountMap<span style=color:#f92672>::</span>iterator it <span style=color:#f92672>=</span> table.refcnts.find(this);
    <span style=color:#66d9ef>if</span> (it <span style=color:#f92672>!=</span> table.refcnts.end()) {
        <span style=color:#66d9ef>if</span> (it<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>&amp;</span> SIDE_TABLE_WEAKLY_REFERENCED) {
            weak_clear_no_lock(<span style=color:#f92672>&amp;</span>table.weak_table, (<span style=color:#66d9ef>id</span>)this);
        }
        table.refcnts.erase(it);
    }
    table.unlock();
}

</code></pre></div><p>遍历SideTable，循环调用weak_clear_no_lock函数。</p><p>weakly_referenced代表对象被指向或者曾经指向一个 ARC 的弱变量。has_sidetable_rc判断该对象的引用计数是否过大。如果其中有一个为YES，则调用clearDeallocating_slow()方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#75715e>// Slow path of clearDeallocating() 
</span><span style=color:#75715e>// for objects with indexed isa
</span><span style=color:#75715e>// that were ever weakly referenced 
</span><span style=color:#75715e>// or whose retain count ever overflowed to the side table.
</span><span style=color:#75715e></span>NEVER_INLINE <span style=color:#66d9ef>void</span> objc_object<span style=color:#f92672>::</span>clearDeallocating_slow()
{
    assert(isa.indexed  <span style=color:#f92672>&amp;&amp;</span>  (isa.weakly_referenced <span style=color:#f92672>||</span> isa.has_sidetable_rc));

    SideTable<span style=color:#f92672>&amp;</span> table <span style=color:#f92672>=</span> SideTables()[this];
    table.lock();
    <span style=color:#66d9ef>if</span> (isa.weakly_referenced) {
        weak_clear_no_lock(<span style=color:#f92672>&amp;</span>table.weak_table, (<span style=color:#66d9ef>id</span>)this);
    }
    <span style=color:#66d9ef>if</span> (isa.has_sidetable_rc) {
        table.refcnts.erase(this);
    }
    table.unlock();
}


</code></pre></div><p>clearDeallocating_slow也会最终调用weak_clear_no_lock方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#75715e>/** 
</span><span style=color:#75715e> * Called by dealloc; nils out all weak pointers that point to the 
</span><span style=color:#75715e> * provided object so that they can no longer be used.
</span><span style=color:#75715e> * 
</span><span style=color:#75715e> * @param weak_table 
</span><span style=color:#75715e> * @param referent The object being deallocated. 
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>void</span>  <span style=color:#a6e22e>weak_clear_no_lock</span>(weak_table_t <span style=color:#f92672>*</span>weak_table, <span style=color:#66d9ef>id</span> referent_id) 
{
    objc_object <span style=color:#f92672>*</span>referent <span style=color:#f92672>=</span> (objc_object <span style=color:#f92672>*</span>)referent_id;

    weak_entry_t <span style=color:#f92672>*</span>entry <span style=color:#f92672>=</span> weak_entry_for_referent(weak_table, referent);
    <span style=color:#66d9ef>if</span> (entry <span style=color:#f92672>==</span> nil) {
        <span style=color:#75715e>/// XXX shouldn&#39;t happen, but does with mismatched CF/objc
</span><span style=color:#75715e></span>        <span style=color:#75715e>//printf(&#34;XXX no entry for clear deallocating %p\n&#34;, referent);
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span>;
    }

    <span style=color:#75715e>// zero out references
</span><span style=color:#75715e></span>    weak_referrer_t <span style=color:#f92672>*</span>referrers;
    size_t count;
    
    <span style=color:#66d9ef>if</span> (entry<span style=color:#f92672>-&gt;</span>out_of_line) {
        referrers <span style=color:#f92672>=</span> entry<span style=color:#f92672>-&gt;</span>referrers;
        count <span style=color:#f92672>=</span> TABLE_SIZE(entry);
    } 
    <span style=color:#66d9ef>else</span> {
        referrers <span style=color:#f92672>=</span> entry<span style=color:#f92672>-&gt;</span>inline_referrers;
        count <span style=color:#f92672>=</span> WEAK_INLINE_COUNT;
    }
    
    <span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> count; <span style=color:#f92672>++</span>i) {
        objc_object <span style=color:#f92672>**</span>referrer <span style=color:#f92672>=</span> referrers[i];
        <span style=color:#66d9ef>if</span> (referrer) {
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>referrer <span style=color:#f92672>==</span> referent) {
                <span style=color:#f92672>*</span>referrer <span style=color:#f92672>=</span> nil;
            }
            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>referrer) {
                _objc_inform(<span style=color:#e6db74>&#34;__weak variable at %p holds %p instead of %p. &#34;</span>
                             <span style=color:#e6db74>&#34;This is probably incorrect use of &#34;</span>
                             <span style=color:#e6db74>&#34;objc_storeWeak() and objc_loadWeak(). &#34;</span>
                             <span style=color:#e6db74>&#34;Break on objc_weak_error to debug.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, 
                             referrer, (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#f92672>*</span>referrer, (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)referent);
                objc_weak_error();
            }
        }
    }
    
    weak_entry_remove(weak_table, entry);
}


</code></pre></div><p>这个函数会在weak_table中，清空引用计数表并清除弱引用表，将所有weak引用指nil。</p><h4 id=总结>总结</h4><p><img src=https://img.halfrost.com/Blog/ArticleImage/30_8.png alt></p><p>这篇文章详细的分析了objc对象 从 出生 到 最终销毁，它的今生今世全部在此。还请大家多多指点。</p><img src=https://img.halfrost.com/wechat-qr-code.png></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div id=toc-footer style=display:none><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#目录>目录</a></li><li><a href=#二对象的出生>二.对象的出生</a></li><li><a href=#三对象的生长>三.对象的生长</a></li><li><a href=#四对象的销毁>四.对象的销毁</a></li><li><a href=#总结>总结</a></li></ul></li></ul></li></ul></nav></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f"><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&text=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&title=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&is_video=false&description=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f"><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&title=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&title=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&title=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-stumbleupon fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&title=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-digg fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&name=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96&description=%e5%89%8d%e8%a8%80%20%e5%9c%a8%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b%e4%b8%ad%ef%bc%8c%e6%88%91%e4%bb%ac%e6%af%8f%e5%a4%a9%e9%83%bd%e5%9c%a8%e5%88%9b%e5%bb%ba%e5%af%b9%e8%b1%a1%ef%bc%8c%e7%94%a8%e5%af%b9%e8%b1%a1%e6%8f%8f%e8%bf%b0%e7%9d%80%e6%95%b4%e4%b8%aa%e4%b8%96%e7%95%8c%ef%bc%8c%e7%84%b6%e8%80%8c%e5%af%b9%e8%b1%a1%e6%98%af%e5%a6%82%e4%bd%95%e4%bb%8e%e5%ad%95%e8%82%b2%e5%88%b0%e9%94%80%e6%af%81%e7%9a%84%e5%91%a2%ef%bc%9f%0a%e7%9b%ae%e5%bd%95%20%201.%e5%ad%95%e8%82%b2%e5%af%b9%e8%b1%a1%202.%e5%af%b9%e8%b1%a1%e7%9a%84%e5%87%ba%e7%94%9f%203.%e5%af%b9%e8%b1%a1%e7%9a%84%e6%88%90%e9%95%bf%204.%e5%af%b9%e8%b1%a1%e7%9a%84%e9%94%80%e6%af%81%205.%e6%80%bb%e7%bb%93%20%20%e4%b8%80.%e5%ad%95%e8%82%b2%e5%af%b9%e8%b1%a1%20%e6%af%8f%e5%a4%a9%e5%bc%80%e5%8f%91%e6%88%91%e4%bb%ac%e9%83%bd%e5%9c%a8alloc%e5%af%b9%e8%b1%a1%ef%bc%8c%e8%80%8calloc%e6%96%b9%e6%b3%95%e5%81%9a%e4%ba%86%e4%ba%9b%e4%bb%80%e4%b9%88%e5%91%a2%ef%bc%9f%0a%2b%20%28id%29alloc%20%7b%20return%20_objc_rootAlloc%28self%29%3b%20%7d%20%e6%89%80%e6%9c%89%e5%af%b9%e8%b1%a1alloc%e9%83%bd%e4%bc%9a%e8%b0%83%e7%94%a8%e8%bf%99%e4%b8%aaroot%e7%9a%84%e6%96%b9%e6%b3%95%0aid%20_objc_rootAlloc%28Class%20cls%29%20%7b%20return%20callAlloc%28cls%2c%20false%2f%2acheckNil%2a%2f%2c%20true%2f%2aallocWithZone%2a%2f%29%3b%20%7d%20%e8%bf%99%e4%b8%aa%e6%96%b9%e6%b3%95%e5%8f%88%e4%bc%9a%e5%8e%bb%e8%b0%83%e7%94%a8callAlloc%e6%96%b9%e6%b3%95%0astatic%20ALWAYS_INLINE%20id%20callAlloc%28Class%20cls%2c%20bool%20checkNil%2c%20bool%20allocWithZone%3dfalse%29%20%7b%20if%20%28checkNil%20%26amp%3b%26amp%3b%20%21cls%29%20return%20nil%3b%20%23if%20__OBJC2__%20%c2%a0if%20%28%21%20cls-%26gt%3bISA%28%29-%26gt%3bhasCustomAWZ%28%29%29%20%7b%20%2f%2f%20No%20alloc%2fallocWithZone%20implementation.%20Go%20straight%20to%20the%20allocator.%20%c2%a0%2f%2f%20fixme%20store%20hasCustomAWZ%20in%20the%20non-meta%20class%20and%c2%a0%c2%a0%2f%2f%20add%20it%20to%20canAllocFast%26%2339%3bs%20summary%20%c2%a0if%20%28cls-%26gt%3bcanAllocFast%28%29%29%20%7b%20%2f%2f%20No%20ctors%2c%20raw%20isa%2c%20etc."><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fobjc_life%2f&t=Objc%20%e5%af%b9%e8%b1%a1%e7%9a%84%e4%bb%8a%e7%94%9f%e4%bb%8a%e4%b8%96"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu class=icon href=# onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden=true></i>Menu</a>
<a id=toc class=icon href=# onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden=true></i>TOC</a>
<a id=share class=icon href=# onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden=true></i>share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i>Top</a></div></div></div><footer id=footer><div class=footer-left><p class=copyright style=float:left;margin-bottom:0><a href=https://github.com/halfrost/Halfrost-Field class=github-repo style=height:18px><span class=gadget-github></span>Star</a>
Copyright &copy;halfrost 2016 - 2021
<a href=http://www.miit.gov.cn/>鄂ICP备16014744号</a></p><br><p class="copyright statistics" style=margin-bottom:20px><span id=busuanzi_container_site_pv>Cumulative Page Views <span id=busuanzi_value_site_pv></span>| Unique Visitors <span id=busuanzi_value_site_uv></span></span></p></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/main.min.f870a4d110314b9e50e65f8ac982dc1c9c376c8f1a5083d39c62cfc49073f011.js></script><script async src=/prism.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>
<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=theme-color content="#FFFFFF"><meta http-equiv=x-ua-compatible content="IE=edge"><title>本站开始支持 QUIC | prometheus</title><meta name=description content="Explore in every moment of the hard thinking"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="本站开始支持 QUIC"><meta property="og:description" content="一. QUIC 是什么 QUIC 是 Quick UDP Internet Connections 的缩写，谷歌发明的新传输协议。与 TCP 相比，QUIC 可以减少延迟。从表面上看，QUIC 非常类似于在 UDP 上实现的 TCP + TLS + HTTP/2。由于 TCP 是在操作系统内核和中间件固件中实现的，因此对 TCP 进行重大更改几乎是不可能的。但是，由于 QUIC 建立在 UDP 之上，因此没有这种限制。QUIC 可以实现可靠传输，而且相比于 TCP，它的流控功能在用户空间而不在内核空间，那么使用者就 不受限于 CUBIC 或是 BBR，而是可以自由选择，甚至根据应用场景自由调整优化。
QUIC 与现有 TCP + TLS + HTTP/2 方案相比，有以下几点主要特征：
 利用缓存，显著减少连接建立时间 改善拥塞控制，拥塞控制从内核空间到用户空间 没有 head of line 阻塞的多路复用 前向纠错，减少重传 连接平滑迁移，网络状态的变更不会影响连接断线。  QUIC 在 UDP 之上，如果想要和 TCP/IP 体系类比，那么就是上图。QUIC 可以类比 TCP/IP 中的 TLS 一层。但是功能又不完全是 TLS ，还有一部分 HTTP/2 ，下面还包括一部分 TCP 的功能，比如 拥塞控制、丢包恢复、流量控制等特性。"><meta property="og:type" content="article"><meta property="og:url" content="https://new.halfrost.com/quic_start/"><meta property="article:published_time" content="2018-07-22T00:33:00+00:00"><meta property="article:modified_time" content="2018-07-22T00:33:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="本站开始支持 QUIC"><meta name=twitter:description content="一. QUIC 是什么 QUIC 是 Quick UDP Internet Connections 的缩写，谷歌发明的新传输协议。与 TCP 相比，QUIC 可以减少延迟。从表面上看，QUIC 非常类似于在 UDP 上实现的 TCP + TLS + HTTP/2。由于 TCP 是在操作系统内核和中间件固件中实现的，因此对 TCP 进行重大更改几乎是不可能的。但是，由于 QUIC 建立在 UDP 之上，因此没有这种限制。QUIC 可以实现可靠传输，而且相比于 TCP，它的流控功能在用户空间而不在内核空间，那么使用者就 不受限于 CUBIC 或是 BBR，而是可以自由选择，甚至根据应用场景自由调整优化。
QUIC 与现有 TCP + TLS + HTTP/2 方案相比，有以下几点主要特征：
 利用缓存，显著减少连接建立时间 改善拥塞控制，拥塞控制从内核空间到用户空间 没有 head of line 阻塞的多路复用 前向纠错，减少重传 连接平滑迁移，网络状态的变更不会影响连接断线。  QUIC 在 UDP 之上，如果想要和 TCP/IP 体系类比，那么就是上图。QUIC 可以类比 TCP/IP 中的 TLS 一层。但是功能又不完全是 TLS ，还有一部分 HTTP/2 ，下面还包括一部分 TCP 的功能，比如 拥塞控制、丢包恢复、流量控制等特性。"><link rel=stylesheet href=/css/style-white.min.css><link rel=manifest href=/manifest.json><link rel=stylesheet href=/prism.css><link href=/images/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=/images/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=/images/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=/images/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=/images/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=/images/apple-touch-icon-512x512.png rel=apple-touch-icon sizes=512x512><link href=/images/apple-touch-icon-1024x1024.png rel=apple-touch-icon sizes=1024x1024><script async>if('serviceWorker'in navigator){navigator.serviceWorker.register("\/serviceworker-v1.min.a64912b78d282eab1ad3715a0943da21616e5f326f8afea27034784ad445043b.js").then(function(){if(navigator.serviceWorker.controller){console.log('Assets cached by the controlling service worker.');}else{console.log('Please reload this page to allow the service worker to handle network operations.');}}).catch(function(error){console.log('ERROR: '+error);});}else{console.log('Service workers are not supported in the current browser.');}</script><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://new.halfrost.com/images/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-82753806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="single-max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a><a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a><a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast');" style=display:none><i class="fas fa-chevron-up fa-lg"></i></a><span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://new.halfrost.com/tls1-3_start/><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li><li><a class=icon href=https://new.halfrost.com/cryptography_overview/><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li><li><a class=icon href=#><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f"><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&text=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&title=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&is_video=false&description=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fquic_start%2f"><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&title=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&title=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&title=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-stumbleupon" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&title=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-digg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&name=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC&description=%e4%b8%80.%20QUIC%20%e6%98%af%e4%bb%80%e4%b9%88%20QUIC%20%e6%98%af%20Quick%20UDP%20Internet%20Connections%20%e7%9a%84%e7%bc%a9%e5%86%99%ef%bc%8c%e8%b0%b7%e6%ad%8c%e5%8f%91%e6%98%8e%e7%9a%84%e6%96%b0%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae%e3%80%82%e4%b8%8e%20TCP%20%e7%9b%b8%e6%af%94%ef%bc%8cQUIC%20%e5%8f%af%e4%bb%a5%e5%87%8f%e5%b0%91%e5%bb%b6%e8%bf%9f%e3%80%82%e4%bb%8e%e8%a1%a8%e9%9d%a2%e4%b8%8a%e7%9c%8b%ef%bc%8cQUIC%20%e9%9d%9e%e5%b8%b8%e7%b1%bb%e4%bc%bc%e4%ba%8e%e5%9c%a8%20UDP%20%e4%b8%8a%e5%ae%9e%e7%8e%b0%e7%9a%84%20TCP%20%2b%20TLS%20%2b%20HTTP%2f2%e3%80%82%e7%94%b1%e4%ba%8e%20TCP%20%e6%98%af%e5%9c%a8%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%86%85%e6%a0%b8%e5%92%8c%e4%b8%ad%e9%97%b4%e4%bb%b6%e5%9b%ba%e4%bb%b6%e4%b8%ad%e5%ae%9e%e7%8e%b0%e7%9a%84%ef%bc%8c%e5%9b%a0%e6%ad%a4%e5%af%b9%20TCP%20%e8%bf%9b%e8%a1%8c%e9%87%8d%e5%a4%a7%e6%9b%b4%e6%94%b9%e5%87%a0%e4%b9%8e%e6%98%af%e4%b8%8d%e5%8f%af%e8%83%bd%e7%9a%84%e3%80%82%e4%bd%86%e6%98%af%ef%bc%8c%e7%94%b1%e4%ba%8e%20QUIC%20%e5%bb%ba%e7%ab%8b%e5%9c%a8%20UDP%20%e4%b9%8b%e4%b8%8a%ef%bc%8c%e5%9b%a0%e6%ad%a4%e6%b2%a1%e6%9c%89%e8%bf%99%e7%a7%8d%e9%99%90%e5%88%b6%e3%80%82QUIC%20%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93%ef%bc%8c%e8%80%8c%e4%b8%94%e7%9b%b8%e6%af%94%e4%ba%8e%20TCP%ef%bc%8c%e5%ae%83%e7%9a%84%e6%b5%81%e6%8e%a7%e5%8a%9f%e8%83%bd%e5%9c%a8%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e8%80%8c%e4%b8%8d%e5%9c%a8%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%ef%bc%8c%e9%82%a3%e4%b9%88%e4%bd%bf%e7%94%a8%e8%80%85%e5%b0%b1%20%e4%b8%8d%e5%8f%97%e9%99%90%e4%ba%8e%20CUBIC%20%e6%88%96%e6%98%af%20BBR%ef%bc%8c%e8%80%8c%e6%98%af%e5%8f%af%e4%bb%a5%e8%87%aa%e7%94%b1%e9%80%89%e6%8b%a9%ef%bc%8c%e7%94%9a%e8%87%b3%e6%a0%b9%e6%8d%ae%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e8%87%aa%e7%94%b1%e8%b0%83%e6%95%b4%e4%bc%98%e5%8c%96%e3%80%82%0aQUIC%20%e4%b8%8e%e7%8e%b0%e6%9c%89%20TCP%20%2b%20TLS%20%2b%20HTTP%2f2%20%e6%96%b9%e6%a1%88%e7%9b%b8%e6%af%94%ef%bc%8c%e6%9c%89%e4%bb%a5%e4%b8%8b%e5%87%a0%e7%82%b9%e4%b8%bb%e8%a6%81%e7%89%b9%e5%be%81%ef%bc%9a%0a%20%e5%88%a9%e7%94%a8%e7%bc%93%e5%ad%98%ef%bc%8c%e6%98%be%e8%91%97%e5%87%8f%e5%b0%91%e8%bf%9e%e6%8e%a5%e5%bb%ba%e7%ab%8b%e6%97%b6%e9%97%b4%20%e6%94%b9%e5%96%84%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%ef%bc%8c%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e4%bb%8e%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e5%88%b0%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%20%e6%b2%a1%e6%9c%89%20head%20of%20line%20%e9%98%bb%e5%a1%9e%e7%9a%84%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8%20%e5%89%8d%e5%90%91%e7%ba%a0%e9%94%99%ef%bc%8c%e5%87%8f%e5%b0%91%e9%87%8d%e4%bc%a0%20%e8%bf%9e%e6%8e%a5%e5%b9%b3%e6%bb%91%e8%bf%81%e7%a7%bb%ef%bc%8c%e7%bd%91%e7%bb%9c%e7%8a%b6%e6%80%81%e7%9a%84%e5%8f%98%e6%9b%b4%e4%b8%8d%e4%bc%9a%e5%bd%b1%e5%93%8d%e8%bf%9e%e6%8e%a5%e6%96%ad%e7%ba%bf%e3%80%82%20%20QUIC%20%e5%9c%a8%20UDP%20%e4%b9%8b%e4%b8%8a%ef%bc%8c%e5%a6%82%e6%9e%9c%e6%83%b3%e8%a6%81%e5%92%8c%20TCP%2fIP%20%e4%bd%93%e7%b3%bb%e7%b1%bb%e6%af%94%ef%bc%8c%e9%82%a3%e4%b9%88%e5%b0%b1%e6%98%af%e4%b8%8a%e5%9b%be%e3%80%82QUIC%20%e5%8f%af%e4%bb%a5%e7%b1%bb%e6%af%94%20TCP%2fIP%20%e4%b8%ad%e7%9a%84%20TLS%20%e4%b8%80%e5%b1%82%e3%80%82%e4%bd%86%e6%98%af%e5%8a%9f%e8%83%bd%e5%8f%88%e4%b8%8d%e5%ae%8c%e5%85%a8%e6%98%af%20TLS%20%ef%bc%8c%e8%bf%98%e6%9c%89%e4%b8%80%e9%83%a8%e5%88%86%20HTTP%2f2%20%ef%bc%8c%e4%b8%8b%e9%9d%a2%e8%bf%98%e5%8c%85%e6%8b%ac%e4%b8%80%e9%83%a8%e5%88%86%20TCP%20%e7%9a%84%e5%8a%9f%e8%83%bd%ef%bc%8c%e6%af%94%e5%a6%82%20%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e3%80%81%e4%b8%a2%e5%8c%85%e6%81%a2%e5%a4%8d%e3%80%81%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e7%ad%89%e7%89%b9%e6%80%a7%e3%80%82"><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&t=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div><div id=toc><nav id=TableOfContents><ul><li><a href=#一-quic-是什么>一. QUIC 是什么</a></li><li><a href=#二-为什么要部署-quic>二. 为什么要部署 QUIC</a></li><li><a href=#三-实现-quic-前置条件>三. 实现 QUIC 前置条件</a><ul><li><a href=#1-首次连接>1. 首次连接</a></li><li><a href=#2-后续连接>2. 后续连接</a></li><li><a href=#3-连接失败>3. 连接失败</a></li></ul></li><li><a href=#四-部署-quic-方案>四. 部署 QUIC 方案</a><ul><li><a href=#一-nginx-配置响应头>(一). nginx 配置响应头</a></li><li><a href=#二-实现-quic-协议>(二). 实现 QUIC 协议</a><ul><li><a href=#1-chromium>1. Chromium</a></li><li><a href=#2-proto-quic>2. proto-quic</a></li><li><a href=#3-goquic>3. goquic</a></li><li><a href=#4-quic-go>4. quic-go</a></li></ul></li></ul></li><li><a href=#五-部署>五. 部署</a></li><li><a href=#六-验证-quic>六. 验证 QUIC</a><ul><li><a href=#1-验证端口>1. 验证端口</a></li><li><a href=#2-chrome-开启-quic-特性>2. chrome 开启 QUIC 特性</a></li><li><a href=#3-安装-http2-and-spdy-indicator-插件>3. 安装 HTTP/2 and SPDY indicator 插件</a></li><li><a href=#4-chrome-developer-tools>4. chrome developer tools</a></li><li><a href=#5-chrome-net-internals>5. chrome net-internals</a></li><li><a href=#6-wireshark-抓包>6. wireshark 抓包</a></li></ul></li><li><a href=#七-一些踩坑实践>七. 一些“踩坑”实践</a><ul><li><a href=#1---add-host-命令>1. &ndash;add-host 命令</a></li><li><a href=#2-修改-dockerfile>2. 修改 dockerfile</a></li></ul></li><li><a href=#八-答疑-q--a>八. 答疑 Q & A</a></li><li><a href=#九-最后>九. 最后</a></li></ul></nav></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">本站开始支持 QUIC</h1><div class=meta><div class=postdate><time datetime="2018-07-22 00:33:00 +0000 UTC" itemprop=datePublished>Jul 22</time></div><div class=article-category><i class="fas fa-archive"></i><a class=category-link href=/categories/quic>QUIC</a>
,
<a class=category-link href=/categories/protocol>Protocol</a></div><div class=article-tag><i class="fas fa-tag"></i><a class=tag-link href=/tags/quic rel=tag>QUIC</a>
,
<a class=tag-link href=/tags/protocol rel=tag>Protocol</a></div></div></header><div class=content itemprop=articleBody><h2 id=一-quic-是什么>一. QUIC 是什么</h2><p>QUIC 是 Quick UDP Internet Connections 的缩写，谷歌发明的新传输协议。与 TCP 相比，QUIC 可以减少延迟。从表面上看，QUIC 非常类似于在 UDP 上实现的 TCP + TLS + HTTP/2。由于 TCP 是在操作系统内核和中间件固件中实现的，因此对 TCP 进行重大更改几乎是不可能的。但是，由于 QUIC 建立在 UDP 之上，因此没有这种限制。QUIC 可以实现可靠传输，而且相比于 TCP，它的流控功能在用户空间而不在内核空间，那么使用者就 不受限于 CUBIC 或是 BBR，而是可以自由选择，甚至根据应用场景自由调整优化。</p><p>QUIC 与现有 TCP + TLS + HTTP/2 方案相比，有以下几点主要特征：</p><ul><li>利用缓存，显著减少连接建立时间</li><li>改善拥塞控制，拥塞控制从内核空间到用户空间</li><li>没有 head of line 阻塞的多路复用</li><li>前向纠错，减少重传</li><li>连接平滑迁移，网络状态的变更不会影响连接断线。</li></ul><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_1.png alt></p><p>QUIC 在 UDP 之上，如果想要和 TCP/IP 体系类比，那么就是上图。QUIC 可以类比 TCP/IP 中的 TLS 一层。但是功能又不完全是 TLS ，还有一部分 HTTP/2 ，下面还包括一部分 TCP 的功能，比如 拥塞控制、丢包恢复、流量控制等特性。</p><h2 id=二-为什么要部署-quic>二. 为什么要部署 QUIC</h2><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_5.png alt></p><p>本站笔者已经部署了 TLS 1.3，再次握手可以达到 0-RTT 了，速度已经比较快了，但是为何笔者还要再部署一套 QUIC 呢？</p><ol><li>HTTP + TLS 的首次握手还是需要花费多次 RTT，仍有优化空间</li><li>手机在弱网环境下，TCP head of line 阻塞和 TLS record HOF 加剧了网络恶化</li><li>HTTPS 一套方案过于单一，如果部署多套链路，系统可用性更高</li></ol><p>其实最重要的一点还是速度快。如果经常用 Google 服务的用户就会观察到，Google 目前主要业务都已经部署了 QUIC，并且支持了 4 个大版本，quic-44、quic-43、quic-39、quic-35（同时支持多个版本主要是为了兼容多个版本 chrome 浏览器，目前最新的 chrome 浏览器 68 - 70 都只有 quic-44，而低版本的 62 - 66 都只有 quic-39，为了各个版本的用户，也只能支持这么多版本了）。</p><p>另外还有一点，如果是 HTTP/2 的开发者，一定会知道，HTTP/2 and SPDY indicator 这个谷歌官方插件。如果只是普通的 HTTP/2 + TLS，这个插件会显示蓝色，并显示“ HTTP/2-enabled(h2) ”；但是如果开启了 QUIC，那么它会显示成炫酷的绿色，并显示“SPDY-enabled(http/2+quic/39)”，绿色表示网络通道更加畅通。</p><p>好了，说了这么多理由了，那接下来看看如何部署吧。</p><h2 id=三-实现-quic-前置条件>三. 实现 QUIC 前置条件</h2><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_3.png alt></p><p>要想在浏览器上实现 QUIC ，有一些前置条件。由于现在好像只有 chrome 浏览器支持 QUIC 协议，所以下面的条件是针对 chrome 浏览器的。</p><h3 id=1-首次连接>1. 首次连接</h3><p>当 Chrome 向之前从未发过请求的服务端发出请求时，它不知道对方是否支持 QUIC，因此先通过 TCP 发送第一个请求。服务器响应该请求以后，要发送 Alt-Svc HTTP 响应头告诉 chrome 它支持 QUIC。 （例如，响应头中 &ldquo;alt-svc: quic=&rdquo;:443&rdquo;; ma=2592000; v="44,43,39,35&rdquo; 告诉 Chrome 服务端支持端口443上的QUIC，且支持的版本号是 44，43，39，35，max-age 为 2592000 秒）。 现在 Chrome 知道服务端支持 QUIC，于是尝试使用 QUIC 来进行下一个请求。发出请求后，Chrome 将采取 QUIC 和 TCP 竞争的方式与服务端建立连接。（建立这些连接，但是不发送请求）如果第一个请求通过 TCP 发出，TCP 赢得竞争，第二个请求将通过 TCP 发出。 在随后的某个时刻，QUIC 如果一旦连接成功，将来所有请求都将通过 QUIC 连接发送。</p><p><strong>所以 QUIC 的协议发现过程是通过识别响应头中的特殊字段实现的</strong>。</p><h3 id=2-后续连接>2. 后续连接</h3><p>Chrome 始终原生支持 QUIC，并且启用 QUIC 的服务器会一直支持 0-RTT 握手。当 Chrome 向之前使用过 QUIC 的服务器发出请求时，它还会与 TCP 进行竞争。 由于 Chrome 将能够进行 0-RTT 握手，因此 QUIC 还会立即获胜，并且继续在 QUIC 连接上发出请求。</p><h3 id=3-连接失败>3. 连接失败</h3><p>如果 QUIC 握手失败（例如，如果UDP被阻止，或者服务器与 chrome 的 QUIC 版本不兼容），则 Chrome 会将 QUIC 标记为该主机已损坏 broken。任何正在进行的请求都将通过 TCP 重新发送。 虽然 QUIC 被标记为主机已损坏，所以不会立即尝试 QUIC 连接了。5分钟后，损坏的连接将过期的 QUIC 标记为“最近破坏”。当向服务器发出下一个请求时，Chrome 又将继续让 TCP 和 QUIC 进行竞争。由于QUIC“最近被破坏”，因此将禁用 0-RTT 握手。如果握手再次失败，则 QUIC 将在此次再次标记为该连接已损坏 10 分钟，将 QUIC 标记为已损坏的前一周期的 2 倍，如此往后都会不断的标记为 2 倍。如果握手成功，请求将通过 QUIC 发送，QUIC 将不再标记为“最近损坏”。</p><p>另外还有一点需要注意的是 QUIC 必须要同时部署在 TCP / UDP 443 端口上。没有理由，这算是规定。具体可以看这个帖子<a href=https://github.com/quicwg/base-drafts/issues/929>Why MUST a server use the same port for HTTP/QUIC?</a></p><p>知道这些以后，QUIC 的部署方案也就出来了。</p><h2 id=四-部署-quic-方案>四. 部署 QUIC 方案</h2><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_2.png alt></p><p>由于 nginx 的生态比较完善，因为部署 QUIC 完全抛弃 nginx ，这有点本末倒置了。但是当前 nginx 还没有支持 QUIC，那我们怎么能提前体验 QUIC 呢？分两步来部署。</p><h3 id=一-nginx-配置响应头>(一). nginx 配置响应头</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=color:#66d9ef>add_header</span> <span style=color:#e6db74>alt-svc</span> <span style=color:#e6db74>&#39;quic=&#34;:443&#34;</span>; <span style=color:#66d9ef>ma=2592000</span>; <span style=color:#66d9ef>v=&#34;39&#34;&#39;</span>;
</code></pre></div><p>这一步比较简单，目的是为了告诉 chrome 浏览器当前服务器支持 QUIC。</p><h3 id=二-实现-quic-协议>(二). 实现 QUIC 协议</h3><p>整个 QUIC 协议比较复杂，想自己完全实现一套对笔者来说还比较困难。所以先看看开源实现有哪些：</p><h4 id=1-chromium>1. Chromium</h4><p>这个是官方支持的。优点自然很多，Google 官方维护基本没有坑，随时可以跟随 chrome 更新到最新版本。不过编译 Chromium 比较麻烦，它有单独的一套编译工具。暂时不考虑这个方案。</p><h4 id=2-proto-quic>2. proto-quic</h4><p>从 chromium 剥离的一个 QUIC 协议部分，但是其 github 主页已宣布不再支持，仅作实验使用。不考虑这个方案。</p><h4 id=3-goquic>3. goquic</h4><p>goquic 封装了 libquic 的 go 语言封装，而 libquic 也是从 chromium 剥离的，好几年不维护了，仅支持到 quic-36， goquic 提供一个反向代理，测试发现由于 QUIC 版本太低，最新 chrome 浏览器已无法支持。不考虑这个方案。</p><h4 id=4-quic-go>4. quic-go</h4><p>quic-go 是完全用 go 写的 QUIC 协议栈，开发很活跃，已在 Caddy 中使用，MIT 许可，目前看是比较好的方案。</p><p>于是可以确定方案是最后一个，采用 caddy 来部署实现 QUIC。</p><p>部署方案如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_7.png alt></p><p>nginx 还是继续使用，不过 nginx 只用来响应 TCP/443 端口，UDP/443 交给 caddy 来响应。nginx 返回响应头告诉 chrome 浏览器支持 QUIC，然后 caddy 作为反向代理 proxy 来转发。</p><h2 id=五-部署>五. 部署</h2><p>caddy 这个项目本意并不是专门用来实现 QUIC 的，它是用来实现一个免签的 HTTPS web 服务器的。caddy 会自动续签证书。QUIC 只是它的一个附属功能(不过好像用它来实现 QUIC 的人更多🤣)。</p><p>如果直接在服务器上面运行 caddy ，会报一个错误：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>Activating privacy features... done.
<span style=color:#ae81ff>2018</span><span style=color:#f92672>/</span><span style=color:#ae81ff>07</span><span style=color:#f92672>/</span><span style=color:#ae81ff>22</span> <span style=color:#ae81ff>14</span><span style=color:#f92672>:</span><span style=color:#ae81ff>03</span><span style=color:#f92672>:</span><span style=color:#ae81ff>15</span> listen tcp :<span style=color:#ae81ff>443</span><span style=color:#f92672>:</span> bind: address already in use
</code></pre></div><p>原来 caddy 也会监听 TCP/443 ，所以要首先解决这个问题，我们只需要 caddy 监听 UDP/443，把 caddy 的 TCP/443 功能“屏蔽”掉。这里比较好的方法就是用 docker 来实现。因为 docker 容器的网段和宿主机的网段默认是隔离的。</p><p>那我们就新建一个 docker 吧。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#a6e22e>FROM ubuntu</span><span style=color:#f92672>:</span>latest
<span style=color:#960050;background-color:#1e0010>LABEL</span> maintainer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ydz@627@gmail.com&#34;</span>

<span style=color:#960050;background-color:#1e0010>RUN</span> <span style=color:#960050;background-color:#1e0010>apt-get</span> <span style=color:#960050;background-color:#1e0010>update</span>

<span style=color:#960050;background-color:#1e0010>RUN</span> <span style=color:#960050;background-color:#1e0010>set</span> <span style=color:#960050;background-color:#1e0010>-x</span>  <span style=color:#960050;background-color:#1e0010>\</span>
	<span style=color:#960050;background-color:#1e0010>&amp;&amp;</span> <span style=color:#960050;background-color:#1e0010>apt-get</span> <span style=color:#960050;background-color:#1e0010>install</span> <span style=color:#960050;background-color:#1e0010>curl</span> <span style=color:#960050;background-color:#1e0010>-y</span> <span style=color:#960050;background-color:#1e0010>\</span>
	<span style=color:#a6e22e>&amp;&amp; curl https</span><span style=color:#f92672>:</span>//getcaddy.com | bash -s personal &amp;&amp; which caddy

</code></pre></div><p>如果不想再做了，可以直接 pull 一下笔者 docker pub 里面的这个镜像，REPOSITORY：halfrost/blog，TAG：caddy-0.0.1。</p><p>然后要新建一个 caddy 的配置文件</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#a6e22e>https</span><span style=color:#f92672>:</span>//halfrost.com
<span style=color:#960050;background-color:#1e0010>gzip</span>
<span style=color:#960050;background-color:#1e0010>tls</span> <span style=color:#960050;background-color:#1e0010>/conf/chained.pem</span> <span style=color:#960050;background-color:#1e0010>/conf/domain.key</span>

<span style=color:#a6e22e>proxy / http</span><span style=color:#f92672>:</span>//127.0.0.1:2368 {
  header_upstream Host <span style=color:#f92672>{</span>host<span style=color:#f92672>}</span>
  header_upstream X-Real-IP <span style=color:#f92672>{</span>remote<span style=color:#f92672>}</span>
  header_upstream X-Forwarded-For <span style=color:#f92672>{</span>remote<span style=color:#f92672>}</span>
  header_upstream X-Forwarded-Proto <span style=color:#f92672>{</span>scheme<span style=color:#f92672>}</span>
<span style=color:#960050;background-color:#1e0010>}</span>

<span style=color:#960050;background-color:#1e0010>log</span> <span style=color:#960050;background-color:#1e0010>/caddy-conf/caddy_blog.log</span>
<span style=color:#960050;background-color:#1e0010>errors</span> <span style=color:#960050;background-color:#1e0010>/caddy-conf/caddy_errors.log</span>
</code></pre></div><p>上面文件中具体的 HTTPS 的证书路径，还有 log 和 error 的路径根据个人喜好配置。</p><p>接下来就可以启动 docker 啦。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker container run -d -p 443:443/udp --name halfrost-blog -v /www/ssl:/conf -v /www/caddy:/caddy-conf halfrost/blog:caddy-0.0.1 caddy -quic -conf /caddy-conf/caddy.conf
</code></pre></div><p>上面这个命令解释一下：</p><p>-p 就是映射的端口，把宿主机的 443/udp ，映射到 docker 的 443 端口</p><p>-name 就是给这个 docker 起一个名字，如果不设置，会随机生成一个名字。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                    NAMES
<span style=color:#ae81ff>366</span>d4b392ed0        halfrost<span style=color:#f92672>/</span>blog:caddy<span style=color:#f92672>-</span><span style=color:#ae81ff>0.0.1</span>         <span style=color:#e6db74>&#34;caddy -quic -conf...&#34;</span>   <span style=color:#ae81ff>10</span> hours ago        Up <span style=color:#ae81ff>10</span> hours         <span style=color:#ae81ff>0.0.0.0</span><span style=color:#f92672>:</span><span style=color:#ae81ff>443</span><span style=color:#f92672>-&gt;</span><span style=color:#ae81ff>443</span><span style=color:#f92672>/</span>udp     halfrost<span style=color:#f92672>-</span>blog
</code></pre></div><p>-v 是挂载一些目录，冒号前面是宿主机的目录，冒号后面是 docker 里面的目录。</p><p>最后的 -conf 加载宿主机的 conf 文件。</p><p>如果 docker 启动失败了，查看一下 docker 的 log，看一下启动失败的原因：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker logs -f -t --tail <span style=color:#ae81ff>10</span> 366d4b392ed0
</code></pre></div><p>至此，服务端的操作全部完成了。</p><h2 id=六-验证-quic>六. 验证 QUIC</h2><h3 id=1-验证端口>1. 验证端口</h3><p>先验证一下 caddy 是否在监听 UDP/443：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>netstat -anp | grep <span style=color:#e6db74>&#34;443&#34;</span>

tcp        <span style=color:#ae81ff>0</span>      <span style=color:#ae81ff>0</span> 0.0.0.0:443             0.0.0.0:*               LISTEN      9748/nginx: master
tcp        <span style=color:#ae81ff>0</span>      <span style=color:#ae81ff>0</span> 172.16.9.240:443        101.86.117.100:54518    TIME_WAIT   -
tcp        <span style=color:#ae81ff>0</span>      <span style=color:#ae81ff>0</span> 172.16.9.240:443        124.90.178.236:33162    FIN_WAIT2   -
tcp        <span style=color:#ae81ff>0</span>      <span style=color:#ae81ff>0</span> 172.16.9.240:64854      140.205.230.3:443       TIME_WAIT   -
udp6       <span style=color:#ae81ff>0</span>      <span style=color:#ae81ff>0</span> :::443                  :::*                                5629/./caddy
</code></pre></div><p>可以看到确实在监听 UDP/443</p><h3 id=2-chrome-开启-quic-特性>2. chrome 开启 QUIC 特性</h3><p>再开启 chrome 的 QUIC 特性</p><p>在 chrome://flags/ 中找到 Experimental 中 QUIC protocol, 设置为Enabled. 重启浏览器生效。</p><h3 id=3-安装-http2-and-spdy-indicator-插件>3. 安装 HTTP/2 and SPDY indicator 插件</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_8.png alt></p><p>在 chrome store 里面安装 HTTP/2 and SPDY indicator 插件。这个插件在前面提到过了，如果开启了 QUIC，这个插件会很明显的显示为绿色。如上图右上角，可以看见绿色的闪电⚡️，即代表已经开启了 QUIC。</p><h3 id=4-chrome-developer-tools>4. chrome developer tools</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_9.png alt></p><p>在 chrome 的 develop tools 工具里面，打开 security 选项卡，在 connection 项里面会看到 QUIC，如果显示的是 QUIC，代表开启 QUIC。</p><h3 id=5-chrome-net-internals>5. chrome net-internals</h3><p>打开 chrome://net-internals/#quic 页面</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_10.png alt></p><p>如果你看到了 QUIC sessins，则开启成功。</p><p>左侧 Alt-svc 里面会记录所有支持 QUIC 的相应头。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_11.png alt></p><p>在上面的字典里，还会记录下次尝试的时间。如果之前出现了 broken，可以在这个页面清空这里的所有记录。清空方法是在这个页面点击右上角的小三角，里面有一项“Clear cache”，清空以后 chrome 在下次请求的时候就会立即尝试 QUIC 了。</p><p><strong>更新：</strong></p><p>新版的 Chrome 68 以上版本，net-internals 中没有笔者上面截图的页面了，这些工具都转到了 chrome://net-export/ 这个页面了。笔者写这篇文章的时候 Chrome 还是 67 的版本。</p><p>chrome://net-export/ 这个页面需要先把请求记录下来，存成 json 文件。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_15.png alt></p><p>记录完成以后会出现下面这个页面：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_16.png alt></p><p>然后在 https://netlog-viewer.appspot.com/ 这里解析 json 文件。解析出来以后就能看到左边的那些工具了。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_18.png alt></p><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_17.png alt></p><p>至于如何清除 Alt-svc 的 cache，这个笔者还没有找到实时清除的方法，笔者现在都是在 dev-tool 里面点击清理 Network 中的 Disable cache 和 Application 中的 Clear storage。可能清除 Alt-svc 的 cache 目前还没有实现出来，如果以后笔者发现方法了，还会再回来更新这段话，如果读者看到这里知道如何清除 Alt-svc 中的 Alternate Service Mappings，也麻烦留言评论分享一下。不过不清除 Alt-svc 中的 cache 对开启 QUIC 影响不大，只是在 broken 以后需要多等待 5 分钟的过期时间(如果能立即清除 cache 就不用等这个 5 分钟了)。</p><h3 id=6-wireshark-抓包>6. wireshark 抓包</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_12.png alt></p><p>最后的办法就是可以用 wireshark 进行抓包，观察发送的包是不是都是 GQUIC 的，如果是，就代表开启成功。</p><h2 id=七-一些踩坑实践>七. 一些“踩坑”实践</h2><p>看到这里读者可能觉得本文就结束了。确实，进行到这里 QUIC 已经开启成功，并且验证完毕了。但是为何还有这一节呢？笔者最后的方案其实不是上述描述的，因为中间出现了一些蛋疼的情景，导致最终没有选用 docker 的方案。当然笔者的情况比较特殊，这里分享一下，仅仅是记录一下解决问题的过程。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_4.png alt></p><p>笔者的浏览器版本是最新的 68，并且也安装了金丝雀，版本是 70 。在部署完 QUIC 以后，疯狂刷新，死活见不到绿色的小闪电⚡️。无奈最终只能采取抓包的方式查问题。抓包发现，chrome 68 的版本默认带的是 quic-43 的实现，在握手的时候会失败。于是就不会开启 QUIC 了。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_14.png alt></p><p>上图可以看见握手失败了。</p><p>于是笔者为了验证 QUIC 开启成功，下载了一个老的版本 65。但是却出现了另外一个问题，打开页面出现 “502 Bad Gateway”。并且在
chrome://net-internals/#alt-svc 页面看见了 broken。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_13.png alt></p><p>出现 broken 就说明了 UDP 通道不通。</p><p>UDP 通道不通可能是几个原因：阿里云或者运营商某个环节屏蔽了 UDP 包；服务端 QUIC 服务挂了，或者博客端口挂了。</p><p>先验证一下服务端 caddy 有没有挂，打印了一下 docker log，没有发现 caddy 崩溃。查看了 ghost ，也没有发现崩溃。</p><p>再检验一下 UDP 包是否没有发送过来。</p><p>笔者服务器是 centOS 的，用 netcat 来检测 UDP 通道。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ yum install nc
$ nc --udp --listen <span style=color:#ae81ff>6111</span>
</code></pre></div><p>在本地连接服务器：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ nc -u &lt;server ip&gt; <span style=color:#ae81ff>6111</span>
</code></pre></div><p>本地发送一串字符串，如果服务端也显示了相同的字符串，代表中间没有防火墙。经过验证，整个 UDP 通道是通的。</p><blockquote><p>注意这里，如果对方没有收到包，不一定能说明 UDP 通道是不通的。因为如果对端开启了防火墙，防火墙把包 DROP 了，那么是收不到 ICMP 端口不可达消息的，那么使用 nc 命令就会发现实际不通的端口是通的。仔细想想 UDP 的原理就清楚了，UDP 不像 TCP 一样需要 ACK，所以过一段时间没收到端口不可达，UDP 就认为端口是通的，但是实际上 UDP 数据被防火墙 DROP 了。</p></blockquote><p>这个时候笔者有点懵。静下心来再仔细分析一下 caddy 的日志：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>11/Aug/2018:13:12:24 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:12:24 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:12:24 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:12:24 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:12:24 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:12:25 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:12:26 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /serviceworker-v1.js<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:12:26 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:12:27 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /serviceworker-v1.js<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:14:12 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /serviceworker-v1.js.map<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:14:12 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /assets/dist/sw-toolbox.js.map<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:14:14 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:14:16 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:14:17 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:14:27 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:14:29 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /rss/<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:14:30 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
11/Aug/2018:13:14:31 +0000 <span style=color:#f92672>[</span>ERROR <span style=color:#ae81ff>502</span> /<span style=color:#f92672>]</span> dial tcp 127.0.0.1:2368: connect: connection refused
</code></pre></div><p>从日志上也看不出具体是什么错误。一直报 502，连接拒绝。</p><p>登录到服务器，模拟一下请求试试：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ curl -X GET 127.0.0.1:2368
</code></pre></div><p>输出了博客首页 index.html ，说明 ghost 的 node 服务也没有挂啊，一切正常。那究竟是什么问题导致 502 错误呢？</p><p>我们是把宿主机的 UDP/443 端口转发到 docker 内的 443 端口，然后反向代理请求到 127.0.0.1：2368 端口，目前还需要排查的一点就是在 docker 内部是否能代理成功呢？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker exec -it 775c7c9ee1e1 /bin/bash

进入到 docker 内部了。

/# curl -X GET http://127.0.0.1:2368

curl: <span style=color:#f92672>(</span>7<span style=color:#f92672>)</span> Failed to connect to 127.0.0.1 port 2368: Connection refused
</code></pre></div><p>这里报错了，看到这里，就可以定位到问题的原因了。之所以 caddy 会报 502 错误，原因是因为 caddy 在 docker 内部无法访问到宿主机的 127.0.0.1：2368 端口。</p><p>在 docker 内部再验证一下, /etc/hosts/ 文件里面的内容</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
192.168.0.4	366d4b392ed0
</code></pre></div><p>可以看到 docker 内部也有一个 127.0.0.1，所以之前代理写的 127.0.0.1 并没有转发到宿主机上，而是被这里的 hosts 文件拦截在本地了。那如何从 docker 内部访问到宿主机呢？宿主机的 IP 是什么呢？</p><p>继续在 docker 内部执行 ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>/# apt-get install iproute2
/# apt-get install net-tools
/# netstat -nr | grep <span style=color:#e6db74>&#39;^0\.0\.0\.0&#39;</span> | awk <span style=color:#e6db74>&#39;{print $2}&#39;</span>

192.168.0.1
</code></pre></div><p>输出 192.168.0.1 代表在 docker 这个网段的网关是 192.168.0.1。那么我们可以通过这个 IP 访问到外面宿主机的服务么？答案是可以的。</p><p>那难道每次我们都需要进入到 docker 里面执行这样一句话查看宿主机的 IP 么？答案当然是否定的。有两种方法可以解决这个 IP 问题。</p><h3 id=1---add-host-命令>1. &ndash;add-host 命令</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ HOST_IP<span style=color:#f92672>=</span><span style=color:#e6db74>`</span>ip -4 addr show scope global dev docker0 | grep inet | awk <span style=color:#e6db74>&#39;{print \$2}&#39;</span> | cut -d / -f 1<span style=color:#e6db74>`</span>

$ docker run --add-host outside:$HOST_IP --name busybox -it busybox /bin/sh

/ <span style=color:#75715e># cat /etc/hosts</span>
127.0.0.1    localhost  
::1    localhost ip6-localhost ip6-loopback
fe00::0    ip6-localnet  
ff00::0    ip6-mcastprefix  
ff02::1    ip6-allnodes  
ff02::2    ip6-allrouters  
172.17.0.1    outside &lt;---- THIS ONE!  
172.17.0.3    a8300156a695
</code></pre></div><h3 id=2-修改-dockerfile>2. 修改 dockerfile</h3><p>在 dockerfile 最后加入一行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>RUN ip -4 route list match 0/0 | awk <span style=color:#e6db74>&#39;{print $3 &#34;host.docker.internal&#34;}&#39;</span> &gt;&gt; /etc/hosts
</code></pre></div><p>一般 docker 生成有 3 种网络类型：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker network ls

NETWORK ID          NAME                DRIVER              SCOPE
a6211ef82668        bridge              bridge              local
bb6cb9901ca2        host                host                local
c25d8f9f4ae3        none                null                local

</code></pre></div><p>默认是 bridge 的，所以可以通过 docker 所在网段的网关访问到宿主机。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker network inspect bridge

<span style=color:#f92672>[</span>
    <span style=color:#f92672>{</span>
        <span style=color:#e6db74>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;bridge&#34;</span>,
        <span style=color:#e6db74>&#34;Id&#34;</span>: <span style=color:#e6db74>&#34;a6211ef82668f63c117d63fdc666a79dea8f3868bdc80434b9f00a05c9ae9d9b&#34;</span>,
        <span style=color:#e6db74>&#34;Created&#34;</span>: <span style=color:#e6db74>&#34;2018-07-26T22:24:42.881531018+08:00&#34;</span>,
        <span style=color:#e6db74>&#34;Scope&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>,
        <span style=color:#e6db74>&#34;Driver&#34;</span>: <span style=color:#e6db74>&#34;bridge&#34;</span>,
        <span style=color:#e6db74>&#34;EnableIPv6&#34;</span>: false,
        <span style=color:#e6db74>&#34;IPAM&#34;</span>: <span style=color:#f92672>{</span>
            <span style=color:#e6db74>&#34;Driver&#34;</span>: <span style=color:#e6db74>&#34;default&#34;</span>,
            <span style=color:#e6db74>&#34;Options&#34;</span>: null,
            <span style=color:#e6db74>&#34;Config&#34;</span>: <span style=color:#f92672>[</span>
                <span style=color:#f92672>{</span>
                    <span style=color:#e6db74>&#34;Subnet&#34;</span>: <span style=color:#e6db74>&#34;192.168.0.0/20&#34;</span>,
                    <span style=color:#e6db74>&#34;Gateway&#34;</span>: <span style=color:#e6db74>&#34;192.168.0.1&#34;</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>]</span>
        <span style=color:#f92672>}</span>,
        <span style=color:#e6db74>&#34;Internal&#34;</span>: false,
        <span style=color:#e6db74>&#34;Attachable&#34;</span>: false,
        <span style=color:#e6db74>&#34;Ingress&#34;</span>: false,
        <span style=color:#e6db74>&#34;Containers&#34;</span>: <span style=color:#f92672>{</span>
            <span style=color:#e6db74>&#34;0592382ce0319a58be1eaa07a612ee75092b192337871632b9b2af9baa8f2233&#34;</span>: <span style=color:#f92672>{</span>
                <span style=color:#e6db74>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;serene_brahmagupta&#34;</span>,
                <span style=color:#e6db74>&#34;EndpointID&#34;</span>: <span style=color:#e6db74>&#34;97349fed924efb4d49173943e0daff0459f0d8df373c639710c81f9efa0f7965&#34;</span>,
                <span style=color:#e6db74>&#34;MacAddress&#34;</span>: <span style=color:#e6db74>&#34;02:42:c0:a8:00:02&#34;</span>,
                <span style=color:#e6db74>&#34;IPv4Address&#34;</span>: <span style=color:#e6db74>&#34;192.168.0.2/20&#34;</span>,
                <span style=color:#e6db74>&#34;IPv6Address&#34;</span>: <span style=color:#e6db74>&#34;&#34;</span>
            <span style=color:#f92672>}</span>,
            <span style=color:#e6db74>&#34;366d4b392ed071186c6442228442a929b20656242b75021beab6eaa7afbc352b&#34;</span>: <span style=color:#f92672>{</span>
                <span style=color:#e6db74>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;halfrost-blog&#34;</span>,
                <span style=color:#e6db74>&#34;EndpointID&#34;</span>: <span style=color:#e6db74>&#34;13c186ae9c460a87280593c3083f644bdbcd718e993b4ba3ee5a8efc66ae82c8&#34;</span>,
                <span style=color:#e6db74>&#34;MacAddress&#34;</span>: <span style=color:#e6db74>&#34;02:42:c0:a8:00:04&#34;</span>,
                <span style=color:#e6db74>&#34;IPv4Address&#34;</span>: <span style=color:#e6db74>&#34;192.168.0.4/20&#34;</span>,
                <span style=color:#e6db74>&#34;IPv6Address&#34;</span>: <span style=color:#e6db74>&#34;&#34;</span>
            <span style=color:#f92672>}</span>,
            <span style=color:#e6db74>&#34;66b36b776c6f390dfb81f055e38e276cbab9e97fe1aa7736e50b08c04e4d9635&#34;</span>: <span style=color:#f92672>{</span>
                <span style=color:#e6db74>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;infallible_saha&#34;</span>,
                <span style=color:#e6db74>&#34;EndpointID&#34;</span>: <span style=color:#e6db74>&#34;18ea99dc8e5add8867d6933717b682701f01452439e699274a8b71a053c673df&#34;</span>,
                <span style=color:#e6db74>&#34;MacAddress&#34;</span>: <span style=color:#e6db74>&#34;02:42:c0:a8:00:03&#34;</span>,
                <span style=color:#e6db74>&#34;IPv4Address&#34;</span>: <span style=color:#e6db74>&#34;192.168.0.3/20&#34;</span>,
                <span style=color:#e6db74>&#34;IPv6Address&#34;</span>: <span style=color:#e6db74>&#34;&#34;</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>,
        <span style=color:#e6db74>&#34;Options&#34;</span>: <span style=color:#f92672>{</span>
            <span style=color:#e6db74>&#34;com.docker.network.bridge.default_bridge&#34;</span>: <span style=color:#e6db74>&#34;true&#34;</span>,
            <span style=color:#e6db74>&#34;com.docker.network.bridge.enable_icc&#34;</span>: <span style=color:#e6db74>&#34;true&#34;</span>,
            <span style=color:#e6db74>&#34;com.docker.network.bridge.enable_ip_masquerade&#34;</span>: <span style=color:#e6db74>&#34;true&#34;</span>,
            <span style=color:#e6db74>&#34;com.docker.network.bridge.host_binding_ipv4&#34;</span>: <span style=color:#e6db74>&#34;0.0.0.0&#34;</span>,
            <span style=color:#e6db74>&#34;com.docker.network.bridge.name&#34;</span>: <span style=color:#e6db74>&#34;docker0&#34;</span>,
            <span style=color:#e6db74>&#34;com.docker.network.driver.mtu&#34;</span>: <span style=color:#e6db74>&#34;1500&#34;</span>
        <span style=color:#f92672>}</span>,
        <span style=color:#e6db74>&#34;Labels&#34;</span>: <span style=color:#f92672>{}</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>]</span>

</code></pre></div><p>笔者把代理改成了 192.168.0.1：2368，依旧连接拒绝。代表还是访问方式不对。通过查询 ghost 文档，发现 2368 端口没有对外暴露，默认只能在宿主机上访问。所以不同网段之间不能访问到 2368 这个 node 服务的。</p><p>排查到这里，有 2 种选择，选择一，更改 ghost 的服务端口，改到 0.0.0.0：2368，不过这样改，ghost 里面很多配置都要更改。选择二，让 caddy docker 和宿主机在同一个网段。</p><p>笔者选择了第二种方案。</p><p>让 docker 和 宿主机在同一个网段可以通过启动的时候指定 <code>--network=host</code>，这样 docker 和宿主机就在同一个网段了。不过这样又会出现新的问题。之前映射关系就不对了。因为这样 caddy 也会监听宿主机的 TCP/443 端口，如此一来我们之前用 docker 摆脱监听同一个端口的目的就没有意义了。</p><p>到这里，笔者还是决定放弃 docker 的方案。那只有改 caddy 源码的方案了。</p><p>下载 caddy 源码，在 caddy/caddyhttp/httpserver/server.go 文件中，找到 Listen 这个函数里面，把其中一行注释掉，换成：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// ln, err := net.Listen(&#34;tcp&#34;, s.Server.Addr)
</span><span style=color:#75715e></span><span style=color:#a6e22e>ln</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#e6db74>&#34;127.0.0.1:61234&#34;</span>)
<span style=color:#75715e>// 随便写一个大一点的没有被占用的端口就可以
</span></code></pre></div><p>就是把原本的 443 地址换成一个没用的地址，然后重新编译。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#a6e22e>cd</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>GOPATH</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>mholt</span><span style=color:#f92672>/</span><span style=color:#a6e22e>caddy</span><span style=color:#f92672>/</span><span style=color:#a6e22e>caddy</span>
<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>build</span>.<span style=color:#66d9ef>go</span> <span style=color:#f92672>--</span><span style=color:#a6e22e>goos</span>=<span style=color:#a6e22e>linux</span> <span style=color:#f92672>--</span><span style=color:#a6e22e>goarch</span>=<span style=color:#a6e22e>amd64</span>
</code></pre></div><p>顺利编译完成以后，就能在已经开了 nginx 的情况下正常启动 Caddy 了。为了能让Caddy变成一个守护进程运行在后台，可以使用 nohup 命令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ nohup sudo ./caddy -quic -conf ./conf  &gt;/dev/null 2&gt;&amp;<span style=color:#ae81ff>1</span> &amp;
</code></pre></div><p>至此，笔者的 QUIC “完美”的部署好了。</p><h2 id=八-答疑-q--a>八. 答疑 Q & A</h2><p>Q: 我刷新了好几次，怎么还是没有你博客上绿色的小闪电⚡️？
A: 首先要看你的 chrome 版本是不是 62-65 之间，如果高于这个版本或者低于这个版本，都会导致 QUIC 握手失败，进而无法进行 QUIC 通讯。因为 62-65 版本之间支持了是 quic-39，而目前 caddy 最新只支持到了 quic-39。</p><p>其次还需要看看你本地是否开启了类似 surge 全局翻墙软件，如果开启了类似这些软件，一般都会系统代理你本机的所有请求，那么所有的请求都是来自 127.0.0.1:XXXX，这样也不会触发 UDP 的请求了。所以要关闭 Surge “设置为系统代理” 这个设置。</p><p>最后，可以看看 chrome://net-internals/#alt-svc 页面里面有 broken 的情况，如果有，可以清除了以后立即刷新再看看。</p><p>Q: caddy 为何不支持最新版的 quic 协议？
A: 这个问题可以看它的 issue，作者在今天 1-4 月，每个月都会更新一个新版本，并且持续的更近 quic 协议的更新。直到 5 月以后，就再也没有发布新版了。作者说要先重构 2 个引入的库的方式，不然以后越开发越乱。一直等到现在 quic-44 了，caddy 还没有更新上来。只能再等等了。</p><p>Q: QUIC 如何调试？
A: 这个问题问的好，笔者也考虑查看 QUIC 里面加密包的内容。不过目前还没有方式可以查看。TLS 可以通过保存协商密钥来查看加密内容，但是 QUIC 目前好像还不行(至少笔者还没有在网上搜到相关的内容)</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/100_12.png alt></p><p>wireshark 抓包目前只能看到前期握手的明文，握手以后的包都是加密内容。所以调试 QUIC 的问题还有待进一步研究。</p><h2 id=九-最后>九. 最后</h2><p><del>当前 caddy 最新只能支持到 quic-39，并且也不能同时兼容多个版本。最新的 chrome 已经支持到最新的 quic-44 了，只能静静等待 caddy 更新了。</del></p><p>经过一次更新，笔者的博客已经支持 quic-44、quic-43、quic-39 三个主流版本了。欢迎大家体验。</p><p>另外，在移动互联网时代，如果客户端也想享受到 QUIC 带来的优势的话，光依靠 Chrome 浏览器可不行，谷歌提供了 cronet 这个库，它是 chromium 网络协议栈的封装，可以用于 Android 和 iOS 平台，可以很方便集成到手机 APP 中。利用这个库，可以和服务端进行 QUIC 的通讯。</p><p>最后可以推荐大家看新浪微博今年 2018 Qcon 上分享的<a href=https://pic.huodongjia.com/ganhuodocs/2018-04-28/1524906080.9.pdf>在 QUIC 上的一些实践心得</a>。</p><p>关于 QUIC 协议的更详尽的分析，笔者会在接下来的文章中细致讲解。</p><hr><p>Reference：</p><p><a href=https://www.chromium.org/quic>QUIC 官方介绍</a><br><a href=https://my.oschina.net/u/347901/blog/1647385>Web服务器快速启用QUIC协议</a>
<a href=https://github.com/y123456yz/reading-and-annotate-quic>reading-and-annotate-quic</a><br><a href=https://www.yinchengli.com/2018/06/10/quic/>怎么把网站升级到QUIC以及QUIC特性分析</a>
<a href=https://liudanking.com/beautiful-life/%E6%9C%AC%E7%AB%99%E5%BC%80%E5%90%AF%E6%94%AF%E6%8C%81-quic-%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E9%85%8D%E7%BD%AE/>本站开启支持 QUIC 的方法与配置</a></p><blockquote><p>GitHub Repo：<a href=https://github.com/halfrost/Halfrost-Field>Halfrost-Field</a></p><p>Follow: <a href=https://github.com/halfrost>halfrost · GitHub</a></p><p>Source: <a href=https://halfrost.com/quic_start/>https://halfrost.com/quic_start/</a></p></blockquote><img src=https://img.halfrost.com/wechat-qr-code.png></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div id=toc-footer style=display:none><nav id=TableOfContents><ul><li><a href=#一-quic-是什么>一. QUIC 是什么</a></li><li><a href=#二-为什么要部署-quic>二. 为什么要部署 QUIC</a></li><li><a href=#三-实现-quic-前置条件>三. 实现 QUIC 前置条件</a><ul><li><a href=#1-首次连接>1. 首次连接</a></li><li><a href=#2-后续连接>2. 后续连接</a></li><li><a href=#3-连接失败>3. 连接失败</a></li></ul></li><li><a href=#四-部署-quic-方案>四. 部署 QUIC 方案</a><ul><li><a href=#一-nginx-配置响应头>(一). nginx 配置响应头</a></li><li><a href=#二-实现-quic-协议>(二). 实现 QUIC 协议</a><ul><li><a href=#1-chromium>1. Chromium</a></li><li><a href=#2-proto-quic>2. proto-quic</a></li><li><a href=#3-goquic>3. goquic</a></li><li><a href=#4-quic-go>4. quic-go</a></li></ul></li></ul></li><li><a href=#五-部署>五. 部署</a></li><li><a href=#六-验证-quic>六. 验证 QUIC</a><ul><li><a href=#1-验证端口>1. 验证端口</a></li><li><a href=#2-chrome-开启-quic-特性>2. chrome 开启 QUIC 特性</a></li><li><a href=#3-安装-http2-and-spdy-indicator-插件>3. 安装 HTTP/2 and SPDY indicator 插件</a></li><li><a href=#4-chrome-developer-tools>4. chrome developer tools</a></li><li><a href=#5-chrome-net-internals>5. chrome net-internals</a></li><li><a href=#6-wireshark-抓包>6. wireshark 抓包</a></li></ul></li><li><a href=#七-一些踩坑实践>七. 一些“踩坑”实践</a><ul><li><a href=#1---add-host-命令>1. &ndash;add-host 命令</a></li><li><a href=#2-修改-dockerfile>2. 修改 dockerfile</a></li></ul></li><li><a href=#八-答疑-q--a>八. 答疑 Q & A</a></li><li><a href=#九-最后>九. 最后</a></li></ul></nav></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f"><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&text=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&title=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&is_video=false&description=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fquic_start%2f"><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&title=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&title=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&title=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-stumbleupon fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&title=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-digg fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&name=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC&description=%e4%b8%80.%20QUIC%20%e6%98%af%e4%bb%80%e4%b9%88%20QUIC%20%e6%98%af%20Quick%20UDP%20Internet%20Connections%20%e7%9a%84%e7%bc%a9%e5%86%99%ef%bc%8c%e8%b0%b7%e6%ad%8c%e5%8f%91%e6%98%8e%e7%9a%84%e6%96%b0%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae%e3%80%82%e4%b8%8e%20TCP%20%e7%9b%b8%e6%af%94%ef%bc%8cQUIC%20%e5%8f%af%e4%bb%a5%e5%87%8f%e5%b0%91%e5%bb%b6%e8%bf%9f%e3%80%82%e4%bb%8e%e8%a1%a8%e9%9d%a2%e4%b8%8a%e7%9c%8b%ef%bc%8cQUIC%20%e9%9d%9e%e5%b8%b8%e7%b1%bb%e4%bc%bc%e4%ba%8e%e5%9c%a8%20UDP%20%e4%b8%8a%e5%ae%9e%e7%8e%b0%e7%9a%84%20TCP%20%2b%20TLS%20%2b%20HTTP%2f2%e3%80%82%e7%94%b1%e4%ba%8e%20TCP%20%e6%98%af%e5%9c%a8%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%86%85%e6%a0%b8%e5%92%8c%e4%b8%ad%e9%97%b4%e4%bb%b6%e5%9b%ba%e4%bb%b6%e4%b8%ad%e5%ae%9e%e7%8e%b0%e7%9a%84%ef%bc%8c%e5%9b%a0%e6%ad%a4%e5%af%b9%20TCP%20%e8%bf%9b%e8%a1%8c%e9%87%8d%e5%a4%a7%e6%9b%b4%e6%94%b9%e5%87%a0%e4%b9%8e%e6%98%af%e4%b8%8d%e5%8f%af%e8%83%bd%e7%9a%84%e3%80%82%e4%bd%86%e6%98%af%ef%bc%8c%e7%94%b1%e4%ba%8e%20QUIC%20%e5%bb%ba%e7%ab%8b%e5%9c%a8%20UDP%20%e4%b9%8b%e4%b8%8a%ef%bc%8c%e5%9b%a0%e6%ad%a4%e6%b2%a1%e6%9c%89%e8%bf%99%e7%a7%8d%e9%99%90%e5%88%b6%e3%80%82QUIC%20%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93%ef%bc%8c%e8%80%8c%e4%b8%94%e7%9b%b8%e6%af%94%e4%ba%8e%20TCP%ef%bc%8c%e5%ae%83%e7%9a%84%e6%b5%81%e6%8e%a7%e5%8a%9f%e8%83%bd%e5%9c%a8%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e8%80%8c%e4%b8%8d%e5%9c%a8%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%ef%bc%8c%e9%82%a3%e4%b9%88%e4%bd%bf%e7%94%a8%e8%80%85%e5%b0%b1%20%e4%b8%8d%e5%8f%97%e9%99%90%e4%ba%8e%20CUBIC%20%e6%88%96%e6%98%af%20BBR%ef%bc%8c%e8%80%8c%e6%98%af%e5%8f%af%e4%bb%a5%e8%87%aa%e7%94%b1%e9%80%89%e6%8b%a9%ef%bc%8c%e7%94%9a%e8%87%b3%e6%a0%b9%e6%8d%ae%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e8%87%aa%e7%94%b1%e8%b0%83%e6%95%b4%e4%bc%98%e5%8c%96%e3%80%82%0aQUIC%20%e4%b8%8e%e7%8e%b0%e6%9c%89%20TCP%20%2b%20TLS%20%2b%20HTTP%2f2%20%e6%96%b9%e6%a1%88%e7%9b%b8%e6%af%94%ef%bc%8c%e6%9c%89%e4%bb%a5%e4%b8%8b%e5%87%a0%e7%82%b9%e4%b8%bb%e8%a6%81%e7%89%b9%e5%be%81%ef%bc%9a%0a%20%e5%88%a9%e7%94%a8%e7%bc%93%e5%ad%98%ef%bc%8c%e6%98%be%e8%91%97%e5%87%8f%e5%b0%91%e8%bf%9e%e6%8e%a5%e5%bb%ba%e7%ab%8b%e6%97%b6%e9%97%b4%20%e6%94%b9%e5%96%84%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%ef%bc%8c%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e4%bb%8e%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e5%88%b0%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%20%e6%b2%a1%e6%9c%89%20head%20of%20line%20%e9%98%bb%e5%a1%9e%e7%9a%84%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8%20%e5%89%8d%e5%90%91%e7%ba%a0%e9%94%99%ef%bc%8c%e5%87%8f%e5%b0%91%e9%87%8d%e4%bc%a0%20%e8%bf%9e%e6%8e%a5%e5%b9%b3%e6%bb%91%e8%bf%81%e7%a7%bb%ef%bc%8c%e7%bd%91%e7%bb%9c%e7%8a%b6%e6%80%81%e7%9a%84%e5%8f%98%e6%9b%b4%e4%b8%8d%e4%bc%9a%e5%bd%b1%e5%93%8d%e8%bf%9e%e6%8e%a5%e6%96%ad%e7%ba%bf%e3%80%82%20%20QUIC%20%e5%9c%a8%20UDP%20%e4%b9%8b%e4%b8%8a%ef%bc%8c%e5%a6%82%e6%9e%9c%e6%83%b3%e8%a6%81%e5%92%8c%20TCP%2fIP%20%e4%bd%93%e7%b3%bb%e7%b1%bb%e6%af%94%ef%bc%8c%e9%82%a3%e4%b9%88%e5%b0%b1%e6%98%af%e4%b8%8a%e5%9b%be%e3%80%82QUIC%20%e5%8f%af%e4%bb%a5%e7%b1%bb%e6%af%94%20TCP%2fIP%20%e4%b8%ad%e7%9a%84%20TLS%20%e4%b8%80%e5%b1%82%e3%80%82%e4%bd%86%e6%98%af%e5%8a%9f%e8%83%bd%e5%8f%88%e4%b8%8d%e5%ae%8c%e5%85%a8%e6%98%af%20TLS%20%ef%bc%8c%e8%bf%98%e6%9c%89%e4%b8%80%e9%83%a8%e5%88%86%20HTTP%2f2%20%ef%bc%8c%e4%b8%8b%e9%9d%a2%e8%bf%98%e5%8c%85%e6%8b%ac%e4%b8%80%e9%83%a8%e5%88%86%20TCP%20%e7%9a%84%e5%8a%9f%e8%83%bd%ef%bc%8c%e6%af%94%e5%a6%82%20%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e3%80%81%e4%b8%a2%e5%8c%85%e6%81%a2%e5%a4%8d%e3%80%81%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e7%ad%89%e7%89%b9%e6%80%a7%e3%80%82"><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fquic_start%2f&t=%e6%9c%ac%e7%ab%99%e5%bc%80%e5%a7%8b%e6%94%af%e6%8c%81%20QUIC"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu class=icon href=# onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden=true></i>Menu</a>
<a id=toc class=icon href=# onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden=true></i>TOC</a>
<a id=share class=icon href=# onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden=true></i>share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i>Top</a></div></div></div><footer id=footer><div class=footer-left><p class=copyright style=float:left;margin-bottom:0><a href=https://github.com/halfrost/Halfrost-Field class=github-repo style=height:18px><span class=gadget-github></span>Star</a>
Copyright &copy;halfrost 2016 - 2021
<a href=http://www.miit.gov.cn/>鄂ICP备16014744号</a></p><br><p class="copyright statistics" style=margin-bottom:20px><span id=busuanzi_container_site_pv>Cumulative Page Views <span id=busuanzi_value_site_pv></span>| Unique Visitors <span id=busuanzi_value_site_uv></span></span></p></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/main.min.f870a4d110314b9e50e65f8ac982dc1c9c376c8f1a5083d39c62cfc49073f011.js></script><script async src=/prism.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>
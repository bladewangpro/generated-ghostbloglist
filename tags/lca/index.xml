<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LCA on prometheus</title><link>https://new.halfrost.com/tags/lca/</link><description>Recent content in LCA on prometheus</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>halfrost</copyright><lastBuildDate>Fri, 20 Oct 2017 03:18:00 +0000</lastBuildDate><atom:link href="https://new.halfrost.com/tags/lca/index.xml" rel="self" type="application/rss+xml"/><item><title>Google S2 中的四叉树求 LCA 最近公共祖先</title><link>https://new.halfrost.com/go_s2_lowest_common_ancestor/</link><pubDate>Fri, 20 Oct 2017 03:18:00 +0000</pubDate><guid>https://new.halfrost.com/go_s2_lowest_common_ancestor/</guid><description>一. 寻找父亲节点和孩子节点 首先需要回顾一下希尔伯特曲线的生成方式，具体代码见笔者上篇文章的分析，在这个分析中，有4个方向比较重要，接下来的分析需要，所以把这4个方向的图搬过来。
在举例之前还需要说明一点，有些网站提供的二进制转换，并没有标明有符号还是无符号的转换，这样就会导致使用者的一些误解。笔者开始并没有发现这个问题，导致掉入了这个坑，好一会才转过弯来。笔者在网上查询了很多在线转换计算器的工具，都发现了这个问题。比如常见的在线进制转换http://tool.oschina.net/hexconvert，随便找两个64位的二进制数，有符号的和无符号的分别转换成十进制，或者反过来转换，你会惊喜的发现，两次结果居然相同！例如你输入 3932700003016900608 和 3932700003016900600，你会发现转换成二进制以后结果都是 11011010010011110000011101000100000000000000000000000000000000。但是很明显这两个数不同。
假如 3932700003016900608 是无符号的，3932700003016900600 是有符号的，正确的结果应该如下：
// 3932700003016900608 11011010010011110000011101000100000000000000000000000000000000 // 3932700003016900600 11011010010011110000011101000011111111111111111111111111111000 差距明显很大。这种例子其实还有很多，随便再举出几组：无符号的 3932700011606835200 和有符号的 3932700011606835000；无符号的 3932700020196769792 和有符号的 3932700020196770000；无符号的 3932700028786704384 和有符号的 3932700028786704400……可以举的例子很多，这里就不再举了。
利用网上的这个工具，十进制转二进制是无符号的转换，二进制转十进制就会变成有符号的转换了。而 Google S2 默认是无符号的 CellID，所以用有符号的 CellID 会出现错误。所以转换中需要注意一下。笔者之前没有发现这一点的时候出现了一些问题，后来突然发现了这一点，茅塞顿开。
好了，进入正题。接下来直接看一个例子，笔者用例子来说明每个 Cell 之间的关系，以及如何查找父亲节点的。
假设有上图这4个连在一起的 Cell。先根据经纬度把 CellID 计算出来。
对应的4个 CellID 分别是：
由于前两位都是0，所以其实可以省略，但是为了读者看的更清晰，笔者还是补全了64位，前面2个0还是补上 // 3932700003016900608 右上 0011011010010011110000011101000100000000000000000000000000000000 // 3932700011606835200 左上 0011011010010011110000011101001100000000000000000000000000000000 // 3932700020196769792 左下 0011011010010011110000011101010100000000000000000000000000000000 // 3932700028786704384 右下 0011011010010011110000011101011100000000000000000000000000000000 在前篇文章里面我们也分析了 Cell 64位的结构，这里是4个 Level 14的 Cell，所以末尾有 64 - 3 - 1 - 14 * 2 = 32 个 0 。从末尾往前的第33位是一个1，第34位，第35位是我们重点需要关注的。可以看到分别是00，01，10，11 。正好是连续的4个二进制。</description></item></channel></rss>
<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=theme-color content="#FFFFFF"><meta http-equiv=x-ua-compatible content="IE=edge"><title>深入浅出 FlatBuffers 之 Encode | prometheus</title><meta name=description content="Explore in every moment of the hard thinking"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="深入浅出 FlatBuffers 之 Encode"><meta property="og:description" content="一. FlatBuffers 生成二进制流 FlatBuffers 的使用和 Protocol buffers 基本类似。只不过功能比 Protocol buffers 多了一个解析 JSON 的功能。
 编写 schema 文件，描述数据结构和接口定义。 用 flatc 编译，生成相应语言的代码文件。 解析 JSON 数据，把数据存储成对应的 schema，并存入 FlatBuffers 二进制文件中。 使用 FlatBuffers 支持的语言（如C ++，Java等）生成的文件进行开发。  接下来简单的定义一个 schema 文件，来看看 FlatBuffers 的使用。
// Example IDL file for our monster's schema. namespace MyGame.Sample; enum Color:byte { Red = 0, Green, Blue = 2 } union Equipment { Weapon } // Optionally add more tables. struct Vec3 { x:float; y:float; z:float; } table Monster { pos:Vec3; // Struct."><meta property="og:type" content="article"><meta property="og:url" content="https://new.halfrost.com/flatbuffers_encode/"><meta property="article:published_time" content="2018-06-10T09:06:00+00:00"><meta property="article:modified_time" content="2018-06-10T09:06:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="深入浅出 FlatBuffers 之 Encode"><meta name=twitter:description content="一. FlatBuffers 生成二进制流 FlatBuffers 的使用和 Protocol buffers 基本类似。只不过功能比 Protocol buffers 多了一个解析 JSON 的功能。
 编写 schema 文件，描述数据结构和接口定义。 用 flatc 编译，生成相应语言的代码文件。 解析 JSON 数据，把数据存储成对应的 schema，并存入 FlatBuffers 二进制文件中。 使用 FlatBuffers 支持的语言（如C ++，Java等）生成的文件进行开发。  接下来简单的定义一个 schema 文件，来看看 FlatBuffers 的使用。
// Example IDL file for our monster's schema. namespace MyGame.Sample; enum Color:byte { Red = 0, Green, Blue = 2 } union Equipment { Weapon } // Optionally add more tables. struct Vec3 { x:float; y:float; z:float; } table Monster { pos:Vec3; // Struct."><link rel=stylesheet href=/css/style-white.min.css><link rel=manifest href=/manifest.json><link rel=stylesheet href=/prism.css><link href=/images/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=/images/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=/images/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=/images/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=/images/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=/images/apple-touch-icon-512x512.png rel=apple-touch-icon sizes=512x512><link href=/images/apple-touch-icon-1024x1024.png rel=apple-touch-icon sizes=1024x1024><script async>if('serviceWorker'in navigator){navigator.serviceWorker.register("\/serviceworker-v1.min.a64912b78d282eab1ad3715a0943da21616e5f326f8afea27034784ad445043b.js").then(function(){if(navigator.serviceWorker.controller){console.log('Assets cached by the controlling service worker.');}else{console.log('Please reload this page to allow the service worker to handle network operations.');}}).catch(function(error){console.log('ERROR: '+error);});}else{console.log('Service workers are not supported in the current browser.');}</script><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://new.halfrost.com/images/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-82753806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="single-max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a><a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a><a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast');" style=display:none><i class="fas fa-chevron-up fa-lg"></i></a><span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://new.halfrost.com/flatbuffers_schema/><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li><li><a class=icon href=https://new.halfrost.com/flatbuffers_flexbuffers/><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li><li><a class=icon href=#><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f"><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&text=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&is_video=false&description=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f"><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-stumbleupon" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-digg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&name=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode&description=%e4%b8%80.%20FlatBuffers%20%e7%94%9f%e6%88%90%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%b5%81%20FlatBuffers%20%e7%9a%84%e4%bd%bf%e7%94%a8%e5%92%8c%20Protocol%20buffers%20%e5%9f%ba%e6%9c%ac%e7%b1%bb%e4%bc%bc%e3%80%82%e5%8f%aa%e4%b8%8d%e8%bf%87%e5%8a%9f%e8%83%bd%e6%af%94%20Protocol%20buffers%20%e5%a4%9a%e4%ba%86%e4%b8%80%e4%b8%aa%e8%a7%a3%e6%9e%90%20JSON%20%e7%9a%84%e5%8a%9f%e8%83%bd%e3%80%82%0a%20%e7%bc%96%e5%86%99%20schema%20%e6%96%87%e4%bb%b6%ef%bc%8c%e6%8f%8f%e8%bf%b0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%92%8c%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89%e3%80%82%20%e7%94%a8%20flatc%20%e7%bc%96%e8%af%91%ef%bc%8c%e7%94%9f%e6%88%90%e7%9b%b8%e5%ba%94%e8%af%ad%e8%a8%80%e7%9a%84%e4%bb%a3%e7%a0%81%e6%96%87%e4%bb%b6%e3%80%82%20%e8%a7%a3%e6%9e%90%20JSON%20%e6%95%b0%e6%8d%ae%ef%bc%8c%e6%8a%8a%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e6%88%90%e5%af%b9%e5%ba%94%e7%9a%84%20schema%ef%bc%8c%e5%b9%b6%e5%ad%98%e5%85%a5%20FlatBuffers%20%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6%e4%b8%ad%e3%80%82%20%e4%bd%bf%e7%94%a8%20FlatBuffers%20%e6%94%af%e6%8c%81%e7%9a%84%e8%af%ad%e8%a8%80%ef%bc%88%e5%a6%82C%20%2b%2b%ef%bc%8cJava%e7%ad%89%ef%bc%89%e7%94%9f%e6%88%90%e7%9a%84%e6%96%87%e4%bb%b6%e8%bf%9b%e8%a1%8c%e5%bc%80%e5%8f%91%e3%80%82%20%20%e6%8e%a5%e4%b8%8b%e6%9d%a5%e7%ae%80%e5%8d%95%e7%9a%84%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%20schema%20%e6%96%87%e4%bb%b6%ef%bc%8c%e6%9d%a5%e7%9c%8b%e7%9c%8b%20FlatBuffers%20%e7%9a%84%e4%bd%bf%e7%94%a8%e3%80%82%0a%2f%2f%20Example%20IDL%20file%20for%20our%20monster%27s%20schema.%20namespace%20MyGame.Sample%3b%20enum%20Color%3abyte%20%7b%20Red%20%3d%200%2c%20Green%2c%20Blue%20%3d%202%20%7d%20union%20Equipment%20%7b%20Weapon%20%7d%20%2f%2f%20Optionally%20add%20more%20tables.%20struct%20Vec3%20%7b%20x%3afloat%3b%20y%3afloat%3b%20z%3afloat%3b%20%7d%20table%20Monster%20%7b%20pos%3aVec3%3b%20%2f%2f%20Struct."><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&t=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div><div id=toc><nav id=TableOfContents><ul><li><a href=#一-flatbuffers-生成二进制流>一. FlatBuffers 生成二进制流</a></li><li><a href=#二-flatbuffers-读取二进制流>二. FlatBuffers 读取二进制流</a></li><li><a href=#三-可变的-flatbuffers>三. 可变的 FlatBuffers</a></li><li><a href=#四-flatbuffers-编码原理>四. FlatBuffers 编码原理</a><ul><li><a href=#1-新建-flatbufferbuilder>1. 新建 FlatBufferBuilder</a></li><li><a href=#2-序列化标量数据>2. 序列化标量数据</a></li><li><a href=#3-序列化数组>3. 序列化数组</a></li><li><a href=#4-序列化-string>4. 序列化 string</a></li><li><a href=#5-序列化-struct>5. 序列化 struct</a></li><li><a href=#6-序列化-table>6. 序列化 table</a></li><li><a href=#7-结束序列化>7. 结束序列化</a></li></ul></li><li><a href=#五-flatbuffers-解码原理>五. FlatBuffers 解码原理</a></li><li><a href=#六-flatbuffers-性能>六. FlatBuffers 性能</a></li><li><a href=#六-flatbuffers-优缺点>六. FlatBuffers 优缺点</a></li><li><a href=#七-最后>七. 最后</a></li></ul></nav></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">深入浅出 FlatBuffers 之 Encode</h1><div class=meta><div class=postdate><time datetime="2018-06-10 09:06:00 +0000 UTC" itemprop=datePublished>Jun 10</time></div><div class=article-category><i class="fas fa-archive"></i><a class=category-link href=/categories/flatbuffers>FlatBuffers</a>
,
<a class=category-link href=/categories/protocol>Protocol</a></div><div class=article-tag><i class="fas fa-tag"></i><a class=tag-link href=/tags/flatbuffers rel=tag>FlatBuffers</a>
,
<a class=tag-link href=/tags/protocol rel=tag>Protocol</a></div></div></header><div class=content itemprop=articleBody><h2 id=一-flatbuffers-生成二进制流>一. FlatBuffers 生成二进制流</h2><p>FlatBuffers 的使用和 Protocol buffers 基本类似。只不过功能比 Protocol buffers 多了一个解析 JSON 的功能。</p><ul><li>编写 schema 文件，描述数据结构和接口定义。</li><li>用 flatc 编译，生成相应语言的代码文件。</li><li>解析 JSON 数据，把数据存储成对应的 schema，并存入 FlatBuffers 二进制文件中。</li><li>使用 FlatBuffers 支持的语言（如C ++，Java等）生成的文件进行开发。</li></ul><p>接下来简单的定义一个 schema 文件，来看看 FlatBuffers 的使用。</p><pre><code class=language-schema data-lang=schema>// Example IDL file for our monster's schema.
namespace MyGame.Sample;
enum Color:byte { Red = 0, Green, Blue = 2 }
union Equipment { Weapon } // Optionally add more tables.
struct Vec3 {
  x:float;
  y:float;
  z:float;
}
table Monster {
  pos:Vec3; // Struct.
  mana:short = 150;
  hp:short = 100;
  name:string;
  friendly:bool = false (deprecated);
  inventory:[ubyte];  // Vector of scalars.
  color:Color = Blue; // Enum.
  weapons:[Weapon];   // Vector of tables.
  equipped:Equipment; // Union.
  path:[Vec3];        // Vector of structs.
}
table Weapon {
  name:string;
  damage:short;
}
root_type Monster;
</code></pre><p>用 flatc 编译之后，利用生成的文件就可以开始开发了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
        <span style=color:#a6e22e>flatbuffers</span> <span style=color:#e6db74>&#34;github.com/google/flatbuffers/go&#34;</span>
        <span style=color:#a6e22e>sample</span> <span style=color:#e6db74>&#34;MyGame/Sample&#34;</span>
)

<span style=color:#75715e>// 创建 `FlatBufferBuilder` 实例, 用它来开始创建 FlatBuffers ，初始化大小 1024
</span><span style=color:#75715e>// buffer 的大小会根据需要自动增长，所以不必担心空间不够
</span><span style=color:#75715e></span><span style=color:#a6e22e>builder</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>NewBuilder</span>(<span style=color:#ae81ff>1024</span>)

<span style=color:#a6e22e>weaponOne</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>CreateString</span>(<span style=color:#e6db74>&#34;Sword&#34;</span>)
<span style=color:#a6e22e>weaponTwo</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>CreateString</span>(<span style=color:#e6db74>&#34;Axe&#34;</span>)
<span style=color:#75715e>// 创建第一把武器，剑
</span><span style=color:#75715e></span><span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>WeaponStart</span>(<span style=color:#a6e22e>builder</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>Weapon</span>.<span style=color:#a6e22e>AddName</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>weaponOne</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>Weapon</span>.<span style=color:#a6e22e>AddDamage</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#ae81ff>3</span>)
<span style=color:#a6e22e>sword</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>WeaponEnd</span>(<span style=color:#a6e22e>builder</span>)
<span style=color:#75715e>// 创建第二把武器，斧
</span><span style=color:#75715e></span><span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>WeaponStart</span>(<span style=color:#a6e22e>builder</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>Weapon</span>.<span style=color:#a6e22e>AddName</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>weaponTwo</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>Weapon</span>.<span style=color:#a6e22e>AddDamage</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#ae81ff>5</span>)
<span style=color:#a6e22e>axe</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>WeaponEnd</span>(<span style=color:#a6e22e>builder</span>)

</code></pre></div><p>在序列化 Monster 之前，我们需要首先序列化包含在 Monster 其中的所有对象，即我们使用深度优先，先根遍历序列化数据树。这在任何树结构上通常很容易实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 对 name 字段赋值
</span><span style=color:#75715e></span><span style=color:#a6e22e>name</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>CreateString</span>(<span style=color:#e6db74>&#34;Orc&#34;</span>)

<span style=color:#75715e>// 这里需要注意的是，由于是 PrependByte，前置字节，所以循环的时候需要反向迭代
</span><span style=color:#75715e></span><span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterStartInventoryVector</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#ae81ff>10</span>)
<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>9</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>--</span> {
        <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependByte</span>(byte(<span style=color:#a6e22e>i</span>))
}
<span style=color:#a6e22e>inv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>EndVector</span>(<span style=color:#ae81ff>10</span>)
</code></pre></div><p>上面这段代码中，我们序列化了两个内置的数据类型（字符串和数组）并捕获了它们的返回值。这个值是序列化数据的偏移量，表示它们的存储位置，拿到这个偏移量以后，以便我们在向 Monster 添加字段时可以参考它们。</p><p>这里的建议是，如果要创建嵌套对象的数组（例如 tables，字符串数组或其他数组），可以先把它们的偏移量收集到临时数据结构中，然后创建一个包含其偏移量的附加数组去存储所有的偏移量。</p><p>如果不是从现有数组创建一个数组，而是逐个序列化元素，请注意顺序，buffers 是从后往前 build 的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 创建 FlatBuffer 数组，前置这些武器。
</span><span style=color:#75715e>// 注意：因为我们前置数据，所以插入的时候记得要逆序插入。
</span><span style=color:#75715e></span><span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterStartWeaponsVector</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#ae81ff>2</span>)
<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependUOffsetT</span>(<span style=color:#a6e22e>axe</span>)
<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependUOffsetT</span>(<span style=color:#a6e22e>sword</span>)
<span style=color:#a6e22e>weapons</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>EndVector</span>(<span style=color:#ae81ff>2</span>)
</code></pre></div><p>FlatBuffer 数组现在就包含了他们的偏移量。</p><p>另外需要注意的是，处理 structs 数组和 table 是完全不同的，因为 structs 完全是存储在数组中。例如，要为上面的 path 字段创建一个数组：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterStartPathVector</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#ae81ff>2</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>CreateVec3</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>2.0</span>, <span style=color:#ae81ff>3.0</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>CreateVec3</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#ae81ff>4.0</span>, <span style=color:#ae81ff>5.0</span>, <span style=color:#ae81ff>6.0</span>)
<span style=color:#a6e22e>path</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>EndVector</span>(<span style=color:#ae81ff>2</span>)
</code></pre></div><p>上面已经序列化好了非标量的字段，接下来可以继续序列化标量字段了：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 构建 monster 通过调用 `MonsterStart()` 开始， `MonsterEnd()` 结束。
</span><span style=color:#75715e></span><span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterStart</span>(<span style=color:#a6e22e>builder</span>)
<span style=color:#a6e22e>vec3</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>CreateVec3</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>2.0</span>, <span style=color:#ae81ff>3.0</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterAddPos</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>vec3</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterAddName</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>name</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterAddColor</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>ColorRed</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterAddHp</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#ae81ff>500</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterAddInventory</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>inv</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterAddWeapons</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>weapons</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterAddEquippedType</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>EquipmentWeapon</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterAddEquipped</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>axe</span>)
<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterAddPath</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>path</span>)
<span style=color:#a6e22e>orc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterEnd</span>(<span style=color:#a6e22e>builder</span>)
</code></pre></div><p>还是需要注意如何在 table 中创建 Vec3 struct。与 table 不同，struct 是标量的简单组合，它们总是以内联方式存储，就像标量本身一样。</p><p><strong>重要的提醒</strong>：与 struct 不同，您不应该嵌套序列化 table 或其他对象，这就是为什么我们在 start 之前就创建好了此 monster 引用的所有 string / vectors / table 的原因。如果您尝试在 start 和 end 之间创建它们中的任何一个，则会根据您的语言获得 assert / exception / panic。</p><p>在 schema 中定义了 hp 和 mana 的默认值，如果初始化的时候不需要改变，就不需要再把值添加到 buffer 中。这样这个字段不会写入到 buffer 中，可以节约传输消耗，减少 buffer 的大小。所以设置好一个合理的默认值可以节约一定的空间。当然，不必担心 buffer 中没有存这个值，get 的时候会从另外一个地方把默认值读取出来的。</p><p><strong>这也意味着不用担心添加了很多仅在少数实例中使用的字段，它们都默认使用默认值，是不会占用 buffer 的大小的</strong>。</p><p>在完成序列化之前，再回顾一下 FlatBuffer union Equipment。每个 FlatBuffer union 都有两部分(具体描述可以看<a href=https://halfrost.com/flatbuffers_schema/>前一篇文章</a>)。第一个是隐藏字段 <code>_type</code>，它是为了保存 union 所引用的 table 的类型而生成的。这使您可以知道在运行时投入哪种类型。第二个字段是，union 的数据。</p><p>所以我们也需要添加 2 个字段，一个是 Equipped Type，另一个是 Equipped union。具体代码在这里(上面初始化过了)：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterAddEquippedType</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>EquipmentWeapon</span>) <span style=color:#75715e>// Union type
</span><span style=color:#75715e></span><span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>MonsterAddEquipped</span>(<span style=color:#a6e22e>builder</span>, <span style=color:#a6e22e>axe</span>) <span style=color:#75715e>// Union data
</span></code></pre></div><p>创建 buffer 之后，你将会得到整个数据相对于根的偏移量，通过调用 finish 方法结束创建，这个偏移量会保存在一个变量中，如下代码，偏移量会保存在 orc 变量中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 调用 `Finish()` 方法告诉 builder，monster 构建完成。
</span><span style=color:#75715e></span><span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>Finish</span>(<span style=color:#a6e22e>orc</span>)
</code></pre></div><p>到现在，buffer 就已经构建完成了，可以通过网络发送出去，也可以经过压缩存储起来。最后通过下面这个方法完成最后一步：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 这个方法必须在 `Finish()` 方法调用之后，才能调用。
</span><span style=color:#75715e></span><span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>FinishedBytes</span>() <span style=color:#75715e>// Of type `byte[]`.
</span></code></pre></div><p>至此，可以把二进制字节写入到文件中，通过网络发送它们了。<strong>请一定要确保发送的文件模式(或者传输协议)是二进制，而不是 text</strong>。如果在 text 格式下传输 FlatBuffer，则 buffer 将会损坏，这将导致您在另外一边读取 buffer 时很难发现问题。</p><h2 id=二-flatbuffers-读取二进制流>二. FlatBuffers 读取二进制流</h2><p>上一章讲到了如何利用 FlatBuffers 把数据转为二进制流，这一节讲讲如何读取。</p><p>读取之前还是需要保证通过二进制模式读取的，其他读取方式读取都读不到正确的数据。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
        <span style=color:#a6e22e>flatbuffers</span> <span style=color:#e6db74>&#34;github.com/google/flatbuffers/go&#34;</span>
        <span style=color:#a6e22e>sample</span> <span style=color:#e6db74>&#34;MyGame/Sample&#34;</span>
)

<span style=color:#75715e>// 先准备一个二进制数组，存储 buffer 二进制流
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>buf</span> []<span style=color:#66d9ef>byte</span> = <span style=color:#75715e>/* the data you just read */</span>
<span style=color:#75715e>// 从 buffer 中拿到根访问器
</span><span style=color:#75715e></span><span style=color:#a6e22e>monster</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>GetRootAsMonster</span>(<span style=color:#a6e22e>buf</span>, <span style=color:#ae81ff>0</span>)

</code></pre></div><p>这里默认 offset 是 0，如果想要直接从 <code>builder.Bytes</code> 开始读取数据，那么需要传入一个 offset 跳过 <code>builder.Head()</code>。由于 builder 构造的时候是逆向构造的，所以 offset 肯定不会是 0 。</p><p>由于导入了 flatc 编译出来的文件，里面已经包含了 get 和 set 方法了。带有 deprecated 默认不会生成对应的方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>hp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>monster</span>.<span style=color:#a6e22e>Hp</span>()
<span style=color:#a6e22e>mana</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>monster</span>.<span style=color:#a6e22e>Mana</span>()
<span style=color:#a6e22e>name</span> <span style=color:#f92672>:=</span> string(<span style=color:#a6e22e>monster</span>.<span style=color:#a6e22e>Name</span>()) <span style=color:#75715e>// Note: `monster.Name()` returns a byte[].
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>pos</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>monster</span>.<span style=color:#a6e22e>Pos</span>(<span style=color:#66d9ef>nil</span>)
<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pos</span>.<span style=color:#a6e22e>X</span>()
<span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pos</span>.<span style=color:#a6e22e>Y</span>()
<span style=color:#a6e22e>z</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pos</span>.<span style=color:#a6e22e>Z</span>()
</code></pre></div><p>上述代码获取 pos 传入的是 nil，如果你的程序对性能要求特别高的时候，可以传入一个指针变量，这样就可以重用，减少很多因为 alloc 小对象，垃圾回收时候造成的性能问题。如果小对象特别多，还会造成 GC 相关的问题。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>invLength</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>monster</span>.<span style=color:#a6e22e>InventoryLength</span>()
<span style=color:#a6e22e>thirdItem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>monster</span>.<span style=color:#a6e22e>Inventory</span>(<span style=color:#ae81ff>2</span>)
</code></pre></div><p>数组的读取方式和一般数组用法一样的，这里就不再赘述了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>weaponLength</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>monster</span>.<span style=color:#a6e22e>WeaponsLength</span>()
<span style=color:#a6e22e>weapon</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>Weapon</span>) <span style=color:#75715e>// We need a `sample.Weapon` to pass into `monster.Weapons()`
</span><span style=color:#75715e></span>                             <span style=color:#75715e>// to capture the output of the function.
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>monster</span>.<span style=color:#a6e22e>Weapons</span>(<span style=color:#a6e22e>weapon</span>, <span style=color:#ae81ff>1</span>) {
        <span style=color:#a6e22e>secondWeaponName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>weapon</span>.<span style=color:#a6e22e>Name</span>()
        <span style=color:#a6e22e>secondWeaponDamage</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>weapon</span>.<span style=color:#a6e22e>Damage</span>()
}
</code></pre></div><p>table 的数组，和一般数组的基本用法也是一样的，唯一区别就是里面都是对象，按照对应的处理方式即可。</p><p>最后就是 union 的读取方式。我们知道 union 会包含 2 个字段，一个类型和一个数据。需要通过类型去判断反序列化什么数据。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 新建一个 `flatbuffers.Table` 去存储 `monster.Equipped()` 的结果。
</span><span style=color:#75715e></span><span style=color:#a6e22e>unionTable</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Table</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>monster</span>.<span style=color:#a6e22e>Equipped</span>(<span style=color:#a6e22e>unionTable</span>) {
        <span style=color:#a6e22e>unionType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>monster</span>.<span style=color:#a6e22e>EquippedType</span>()
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>unionType</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>EquipmentWeapon</span> {
                <span style=color:#75715e>// Create a `sample.Weapon` object that can be initialized with the contents
</span><span style=color:#75715e></span>                <span style=color:#75715e>// of the `flatbuffers.Table` (`unionTable`), which was populated by
</span><span style=color:#75715e></span>                <span style=color:#75715e>// `monster.Equipped()`.
</span><span style=color:#75715e></span>                <span style=color:#a6e22e>unionWeapon</span> = new(<span style=color:#a6e22e>sample</span>.<span style=color:#a6e22e>Weapon</span>)
                <span style=color:#a6e22e>unionWeapon</span>.<span style=color:#a6e22e>Init</span>(<span style=color:#a6e22e>unionTable</span>.<span style=color:#a6e22e>Bytes</span>, <span style=color:#a6e22e>unionTable</span>.<span style=color:#a6e22e>Pos</span>)
                <span style=color:#a6e22e>weaponName</span> = <span style=color:#a6e22e>unionWeapon</span>.<span style=color:#a6e22e>Name</span>()
                <span style=color:#a6e22e>weaponDamage</span> = <span style=color:#a6e22e>unionWeapon</span>.<span style=color:#a6e22e>Damage</span>()
        }
}
</code></pre></div><p>通过 unionType 对应不同类型，反序列化不同类型的数据。毕竟一个 union 里面只装一个 table。</p><h2 id=三-可变的-flatbuffers>三. 可变的 FlatBuffers</h2><p>从上面使用方式来看，发送方准备好 buffer 二进制流，发给使用方，使用方拿到 buffer 二进制流以后，从中读取出数据。如果使用方还想把 buffer 稍作更改传递给下一个使用方，只能重新创建一个全新的 buffer ，然后把要更改的字段在创建的时候改掉，再传给下一个使用方。</p><p>如果只是小改一个字段，导致又要重新创建一个很大的 buffer，这会非常不方便。如果要更改很多字段，可以考虑从 0 开始新建 buffer，因为这样更加高效，API 也更叫通用。</p><p>如果想创建可变的 flatbuffer，需要在 flatc 编译 schema 的时候添加 <code>--gen-mutable</code> 编译参数。</p><p>编译出来代码会使用 mutate 而不是 set 来表示这是一个特殊用例，尽量避免与构造 FlatBuffer 数据的默认方式混淆。</p><p><strong>mutating API 暂时还不支持 golang</strong>。</p><p>请注意，table 中 任何 mutate 函数都会返回布尔值，如果我们尝试设置一个不存在于 buffer 中的字段，则会返回 false。<strong>不存在于 buffer 中的字段有 2 种情况，一种情况是本身没有 set 值，另外一种情况是值和默认值相同</strong>。例如上面里面中的 mana = 150，它由于是默认值，是不会存储在 buffer 中的。如果调用 mutate 方法，将会返回 false，并且它们的值不会被修改。</p><p>解决此问题的一种方法是在 FlatBufferBuilder 上调用 ForceDefaults 以强制设置所有字段可写。这当然会增加 buffer 的大小，但这对于可变 buffer 是可以接受的。</p><p>如果这种方法还不能被接受，就调用对应的 API (&ndash;gen-object-api) 或者反射方法。目前 C++ 版本的 API 在这方面支持的最全。</p><h2 id=四-flatbuffers-编码原理>四. FlatBuffers 编码原理</h2><p>根据上面简单实用的流程，我们一步步的来看看源码。</p><h3 id=1-新建-flatbufferbuilder>1. 新建 FlatBufferBuilder</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>builder</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>NewBuilder</span>(<span style=color:#ae81ff>1024</span>)
</code></pre></div><p>第一步新建 FlatBufferBuilder，在 builder 中，会初始化最终我们序列化好的，使用 little endian 的二进制流，二进制流是从高内存地址往低内存地址写。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Builder</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#75715e>// `Bytes` gives raw access to the buffer. Most users will want to use
</span><span style=color:#75715e></span>	<span style=color:#75715e>// FinishedBytes() instead.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Bytes</span> []<span style=color:#66d9ef>byte</span>

	<span style=color:#a6e22e>minalign</span>  <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>vtable</span>    []<span style=color:#a6e22e>UOffsetT</span>
	<span style=color:#a6e22e>objectEnd</span> <span style=color:#a6e22e>UOffsetT</span>
	<span style=color:#a6e22e>vtables</span>   []<span style=color:#a6e22e>UOffsetT</span>
	<span style=color:#a6e22e>head</span>      <span style=color:#a6e22e>UOffsetT</span>
	<span style=color:#a6e22e>nested</span>    <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>finished</span>  <span style=color:#66d9ef>bool</span>
}


<span style=color:#66d9ef>type</span> (
	<span style=color:#75715e>// A SOffsetT stores a signed offset into arbitrary data.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>SOffsetT</span> <span style=color:#66d9ef>int32</span>
	<span style=color:#75715e>// A UOffsetT stores an unsigned offset into vector data.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>UOffsetT</span> <span style=color:#66d9ef>uint32</span>
	<span style=color:#75715e>// A VOffsetT stores an unsigned offset in a vtable.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>VOffsetT</span> <span style=color:#66d9ef>uint16</span>
)

</code></pre></div><p>这里有 3 个特殊的类型：SOffsetT、UOffsetT、VOffsetT。SOffsetT 存储的是一个有符号的 offset，UOffsetT 存储的是数组数据的无符号的 offset，VOffsetT 存储的是 vtable 中的无符号的 offset。</p><p>Builder 中的 Bytes 是最终序列化的二进制流。新建 FlatBufferBuilder 就是初始化 Builder 结构体：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewBuilder</span>(<span style=color:#a6e22e>initialSize</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>initialSize</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>initialSize</span> = <span style=color:#ae81ff>0</span>
	}

	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Builder</span>{}
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span> = make([]<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>initialSize</span>)
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>head</span> = <span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>initialSize</span>)
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>minalign</span> = <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtables</span> = make([]<span style=color:#a6e22e>UOffsetT</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>16</span>) <span style=color:#75715e>// sensible default capacity
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>
}
</code></pre></div><h3 id=2-序列化标量数据>2. 序列化标量数据</h3><p>标量数据包括以下这些类型：Bool、uint8、uint16、uint32、uint64、int8、int16、int32、int64、float32、float64、byte。这些类型的数据的序列化方法都是一样的，这里以 PrependInt16 为例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>PrependInt16</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int16</span>) {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Prep</span>(<span style=color:#a6e22e>SizeInt16</span>, <span style=color:#ae81ff>0</span>)
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PlaceInt16</span>(<span style=color:#a6e22e>x</span>)
}
</code></pre></div><p>具体实现就调用了 2 个函数，一个是 Prep() ，另一个是 PlaceXXX()。Prep() 是一个公共函数，序列化所有标量都会调用这个函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>Prep</span>(<span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>additionalBytes</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#75715e>// Track the biggest thing we&#39;ve ever aligned to.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span> &gt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>minalign</span> {
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>minalign</span> = <span style=color:#a6e22e>size</span>
	}
	<span style=color:#75715e>// Find the amount of alignment needed such that `size` is properly
</span><span style=color:#75715e></span>	<span style=color:#75715e>// aligned after `additionalBytes`:
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>alignSize</span> <span style=color:#f92672>:=</span> (^(len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>) <span style=color:#f92672>-</span> int(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Head</span>()) <span style=color:#f92672>+</span> <span style=color:#a6e22e>additionalBytes</span>)) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>alignSize</span> <span style=color:#f92672>&amp;=</span> (<span style=color:#a6e22e>size</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)

	<span style=color:#75715e>// Reallocate the buffer if needed:
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> int(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>head</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>alignSize</span><span style=color:#f92672>+</span><span style=color:#a6e22e>size</span><span style=color:#f92672>+</span><span style=color:#a6e22e>additionalBytes</span> {
		<span style=color:#a6e22e>oldBufSize</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>)
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>growByteBuffer</span>()
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>head</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>UOffsetT</span>(len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>) <span style=color:#f92672>-</span> <span style=color:#a6e22e>oldBufSize</span>)
	}
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Pad</span>(<span style=color:#a6e22e>alignSize</span>)
}
</code></pre></div><p>Prep() 函数的第一个入参是 size，这里的 size 是字节单位，有多少个字节大小，这里的 size 就是多少。例如 SizeUint8 = 1、SizeUint16 = 2、SizeUint32 = 4、SizeUint64 = 8。其他类型以此类推。比较特殊的 3 个 offset，大小也是固定的，SOffsetT int32，它的 size = 4；UOffsetT uint32，它的 size = 4；VOffsetT uint16，它的 size = 2。</p><p>Prep() 方法有两个作用：</p><ol><li>所有的对齐动作。</li><li>内存不足时申请额外的内存空间。</li></ol><p>在添加完 <code>additional_bytes</code> 个字节之后，还要继续添加 size 个字节。这里需要对齐的是最后这个 size 字节，实际也是要添加的对象的大小，比如 Int 就是 4 个字节。最终的效果是分配 <code>additional_bytes</code> 之后 offset 是 size 的整数倍，计算需要对齐的字节数在两句话里面实现的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>alignSize</span> <span style=color:#f92672>:=</span> (^(len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>) <span style=color:#f92672>-</span> int(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Head</span>()) <span style=color:#f92672>+</span> <span style=color:#a6e22e>additionalBytes</span>)) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>alignSize</span> <span style=color:#f92672>&amp;=</span> (<span style=color:#a6e22e>size</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</code></pre></div><p>对齐以后，如果有需要，还需要 Reallocate buffer：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>growByteBuffer</span>() {
	<span style=color:#66d9ef>if</span> (int64(len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>)) <span style=color:#f92672>&amp;</span> int64(<span style=color:#ae81ff>0xC0000000</span>)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		panic(<span style=color:#e6db74>&#34;cannot grow buffer beyond 2 gigabytes&#34;</span>)
	}
	<span style=color:#a6e22e>newLen</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newLen</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>newLen</span> = <span style=color:#ae81ff>1</span>
	}

	<span style=color:#66d9ef>if</span> cap(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>newLen</span> {
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>[:<span style=color:#a6e22e>newLen</span>]
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>extension</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>newLen</span><span style=color:#f92672>-</span>len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>))
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span> = append(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>, <span style=color:#a6e22e>extension</span><span style=color:#f92672>...</span>)
	}

	<span style=color:#a6e22e>middle</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newLen</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
	copy(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>[<span style=color:#a6e22e>middle</span>:], <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>[:<span style=color:#a6e22e>middle</span>])
}
</code></pre></div><p>growByteBuffer() 方法会扩容到原来 2 倍的大小。值得注意的是最后的 copy 操作：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>copy(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>[<span style=color:#a6e22e>middle</span>:], <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>[:<span style=color:#a6e22e>middle</span>])
</code></pre></div><p>旧的数据实际上会被 copy 到新扩容以后数组的末尾，因为 build buffer 是从后往前 build 的。</p><p>Prep() 最后一步就是在当前的 offset 中添 0：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>Pad</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PlaceByte</span>(<span style=color:#ae81ff>0</span>)
	}
}
</code></pre></div><p>在上面的例子中，hp = 500，500 的二进制是 111110100，由于当前 buffer 中是 2 个字节，所以逆序存储 500，为 1111 0100 0000 0001。根据上面提到的对齐规则，500 的类型是 Sizeint16，字节数为 2，当前偏移了 133 个字节(为何是 133 个字节，在下面会提到，这里先暂时接受这个数字)，133 + 2 = 135 个字节，不是 Sizeint16 的倍数了，所以需要字节对齐，对齐的效果就是添加 0 ，对齐到 Sizeint16 的整数倍，根据上面的规则，alignSize 算出来为 1 ，也就是要额外添加 1 个字节的 0 。</p><p>那么 500 最终在二进制流中表示的结果为 ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#ae81ff>500</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1111</span> <span style=color:#ae81ff>0100</span> <span style=color:#ae81ff>0000</span> <span style=color:#ae81ff>0001</span> <span style=color:#ae81ff>0000</span> <span style=color:#ae81ff>0000</span>
    <span style=color:#f92672>=</span> <span style=color:#ae81ff>244</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span>
</code></pre></div><p>最后还要提一下标量的默认值的问题，我们知道在 flatbuffer 中，默认值是不会存储在二进制流中，那它存储在哪里呢？它实际上会被 flatc 文件直接编译到代码文件中。我们还是以这里的 hp 为例，它的默认值为 100 。</p><p>我们在给 Monster 序列化 hp 的时候，会调用 MonsterAddHp() 方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterAddHp</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>hp</span> <span style=color:#66d9ef>int16</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependInt16Slot</span>(<span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>hp</span>, <span style=color:#ae81ff>100</span>)
}
</code></pre></div><p>具体实现就能一眼看到，默认值就直接写好了，默认值 100 会被当做入参传到 builder 中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>PrependInt16Slot</span>(<span style=color:#a6e22e>o</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>d</span> <span style=color:#66d9ef>int16</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>d</span> {
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PrependInt16</span>(<span style=color:#a6e22e>x</span>)
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Slot</span>(<span style=color:#a6e22e>o</span>)
	}
}
</code></pre></div><p>在准备插槽 Slot 的时候，如果序列化的值和默认值相当的话，是不会继续往下存入到二进制流中，对应代码就是上面这个 if 判断。只有不等于默认值，才会继续 PrependInt16() 操作。</p><p>所有标量序列化的最后一步是把 offset 记录到 vtable 中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>Slot</span>(<span style=color:#a6e22e>slotnum</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>[<span style=color:#a6e22e>slotnum</span>] = <span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>())
}
</code></pre></div><p>slotnum 是调用者会传递进来，这个值也不需要我们开发者关心，因为这个值是 flatc 自动按照 schema 生成的 num。</p><pre><code class=language-schema data-lang=schema>table Monster {
  pos:Vec3; // Struct.
  mana:short = 150;
  hp:short = 100;
  name:string;
  friendly:bool = false (deprecated);
  inventory:[ubyte];  // Vector of scalars.
  color:Color = Blue; // Enum.
  weapons:[Weapon];   // Vector of tables.
  equipped:Equipment; // Union.
  path:[Vec3];        // Vector of structs.
}
</code></pre><p>在 Monster 的定义中，hp 从 pos 往下数，从 0 开始，数到 hp 就是第 2 个，所以 hp 在 builder 的 vtable 中，排在第二个插槽的位置，vtable[2] 中存储的值就是它对应的 offset。</p><h3 id=3-序列化数组>3. 序列化数组</h3><p>数组中存储了连续的标量，并且还会存储一个 SizeUint32 代表数组的大小。数组不是内联存储在它的父类中，而是通过引用偏移 offset 的方式。</p><p>在上面的例子中，数组其实分为 3 类，标量数组，table 数组，struct 数组。其实序列化数组的时候，不用考虑里面具体装的是什么。这三种数组的序列化方法都是一样的，都是调用的下面这个方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>StartVector</span>(<span style=color:#a6e22e>elemSize</span>, <span style=color:#a6e22e>numElems</span>, <span style=color:#a6e22e>alignment</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>UOffsetT</span> {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>assertNotNested</span>()
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>nested</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Prep</span>(<span style=color:#a6e22e>SizeUint32</span>, <span style=color:#a6e22e>elemSize</span><span style=color:#f92672>*</span><span style=color:#a6e22e>numElems</span>)
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Prep</span>(<span style=color:#a6e22e>alignment</span>, <span style=color:#a6e22e>elemSize</span><span style=color:#f92672>*</span><span style=color:#a6e22e>numElems</span>) <span style=color:#75715e>// Just in case alignment &gt; int.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>()
}
</code></pre></div><p>这个方法的入参有 3 个参数，元素的大小，元素个数，对齐字节。</p><p>在上面的例子中，标量数组 InventoryVector 里面装的都是 SizeInt8 ，也就是一个字节，所以对齐也是 1 个字节(选数组里面最大的占用字节数)；table 数组 WeaponsVector 里面装的都是 Weapons 类型的 table，table 的元素大小是 string + short = 4 字节，对齐也是 4 字节；struct 数组 PathVector，里面装的都是 Path 类型的 struct，struct 的元素大小是 SizeFloat32 * 3 = 4 * 3 = 12 字节，但是对齐大小只是 4 字节。</p><p>StartVector() 方法会先判断一下当前构建是否存在嵌套的情况：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>assertNotNested</span>() {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>nested</span> {
		panic(<span style=color:#e6db74>&#34;Incorrect creation order: object must not be nested.&#34;</span>)
	}
}
</code></pre></div><p>Table/Vector/String 这三者是不能嵌套创建的，builder 中的 nested 也标记了当前是否是嵌套的状态。如果嵌套循环创建，这里就会报 panic。</p><p>接着就是两个 Prep() 操作，这里会先进行 SizeUint32 再进行 alignment 的 Prep，原因是 alignment 有可能会大于 SizeUint32。</p><p>准备好对齐空间和计算好 offset 了以后，就是往数组里面序列化放元素的过程，调用各种 PrependXXXX() 方法，（上面举例提到了 PrependInt16() 方法，其他类型都类似，这里就不再赘述了）。</p><p>数组中装载完数据以后，最后一步需要调用一次 EndVector() 方法，结束数组的序列化：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>EndVector</span>(<span style=color:#a6e22e>vectorNumElems</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>UOffsetT</span> {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>assertNested</span>()

	<span style=color:#75715e>// we already made space for this, so write without PrependUint32
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PlaceUOffsetT</span>(<span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>vectorNumElems</span>))

	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>nested</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>()
}
</code></pre></div><p>EndVector() 内部会调用 PlaceUOffsetT() 方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>PlaceUOffsetT</span>(<span style=color:#a6e22e>x</span> <span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>head</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>SizeUOffsetT</span>)
	<span style=color:#a6e22e>WriteUOffsetT</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>[<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>head</span>:], <span style=color:#a6e22e>x</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WriteUOffsetT</span>(<span style=color:#a6e22e>buf</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>n</span> <span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#a6e22e>WriteUint32</span>(<span style=color:#a6e22e>buf</span>, uint32(<span style=color:#a6e22e>n</span>))
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WriteUint32</span>(<span style=color:#a6e22e>buf</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>n</span> <span style=color:#66d9ef>uint32</span>) {
	<span style=color:#a6e22e>buf</span>[<span style=color:#ae81ff>0</span>] = byte(<span style=color:#a6e22e>n</span>)
	<span style=color:#a6e22e>buf</span>[<span style=color:#ae81ff>1</span>] = byte(<span style=color:#a6e22e>n</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span>)
	<span style=color:#a6e22e>buf</span>[<span style=color:#ae81ff>2</span>] = byte(<span style=color:#a6e22e>n</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>16</span>)
	<span style=color:#a6e22e>buf</span>[<span style=color:#ae81ff>3</span>] = byte(<span style=color:#a6e22e>n</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>24</span>)
}
</code></pre></div><p>PlaceUOffsetT() 方法主要是设置 builder 的 UOffset，SizeUOffsetT = 4 字节。把数组的长度序列化到二进制流中。数组的长度是 4 字节。</p><p>上面例子中，偏移到 InventoryVector 的 offset 是 60，添加 10 个 1 字节的标量元素以后，就到 70 字节了，由于 alignment = 1，小于 SizeUint32 = 4，所以按照 4 字节对齐，距离 70 最近的，且是 4 字节倍数的就是 72，所以对齐需要额外添加 2 字节的 0 。最终在二进制流里面的表现是 ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#ae81ff>10</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>9</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>
</code></pre></div><h3 id=4-序列化-string>4. 序列化 string</h3><p>字符串可以看成字节数组，只不过在字符串结尾处有一个空字符串标识符。字符串也不能内联存储在它的父类中，也是通过引用偏移 offset 的方式。</p><p>所以序列化 string 和序列化数组是差不多的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>CreateString</span>(<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) <span style=color:#a6e22e>UOffsetT</span> {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>assertNotNested</span>()
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>nested</span> = <span style=color:#66d9ef>true</span>

	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Prep</span>(int(<span style=color:#a6e22e>SizeUOffsetT</span>), (len(<span style=color:#a6e22e>s</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>*</span><span style=color:#a6e22e>SizeByte</span>)
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PlaceByte</span>(<span style=color:#ae81ff>0</span>)

	<span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>UOffsetT</span>(len(<span style=color:#a6e22e>s</span>))

	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>head</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>l</span>
	copy(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>[<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>head</span>:<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>head</span><span style=color:#f92672>+</span><span style=color:#a6e22e>l</span>], <span style=color:#a6e22e>s</span>)

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>EndVector</span>(len(<span style=color:#a6e22e>s</span>))
}
</code></pre></div><p>具体实现代码和序列化数组的流程基本一致，多的几步接下来一一解释。同样是先 Prep()，对齐，和数组不同的是，string 的末尾是 null 结束符，所以数组的最后一个字节要加一个字节的 0 。所以多了一句 <code>b.PlaceByte(0)</code> 。</p><p><code>copy(b.Bytes[b.head:b.head+l], s)</code> 就是把字符串复制到相应的 offset 中。</p><p>最后 <code>b.EndVector()</code> 同样是把长度再放到二进制流中。注意 2 处处理长度的地方，Prep() 中是考虑了末尾的 0，所以 Prep() 的时候 len(s) + 1，最后 EndVector() 是不考虑末尾 0 的，所以用的是 len(s)。</p><p>还是拿上面例子中具体的例子来说明。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>weaponOne</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>CreateString</span>(<span style=color:#e6db74>&#34;Sword&#34;</span>)
</code></pre></div><p>最开始我们就序列化了 Sword 字符串。这个字符串对应的 ASCII 码是，83 119 111 114 100。由于字符串末尾还要在填一个 0，所以整个字符串在二进制流中应该是 83 119 111 114 100 0 。考虑一下对齐，由于是 SizeUOffsetT = 4 字节，字符串当前的 offset 是 0，加上字符串长度 6 以后，距离 6 最近的 4 的倍数是 8，所以末尾要再添加 2 个字节的 0 。最后再加上字符串长度 5 (注意这里算长度不要包含字符串末尾的 0)</p><p>所以最终 Sword 字符串在二进制流中如下排列：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#ae81ff>5</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>83</span> <span style=color:#ae81ff>119</span> <span style=color:#ae81ff>111</span> <span style=color:#ae81ff>114</span> <span style=color:#ae81ff>100</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>
</code></pre></div><h3 id=5-序列化-struct>5. 序列化 struct</h3><p>struct 总是以内联 inline 方式存储在它们的父级（struct，table 或 vector）中，以实现最大程度的紧凑性。struct 定义了一个一致的内存布局，其中所有字段都与其大小对齐，并且 struct 与其最大标量成员对齐。这种做法完成独立于底层编译器的对齐规则，以保证跨平台兼容的布局。这个布局在生成的代码中构建。接下来看看如何构建的。</p><p>序列化 struct 十分简单，直接序列化成二进制，插入插槽即可：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>PrependStructSlot</span>(<span style=color:#a6e22e>voffset</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>d</span> <span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>d</span> {
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>assertNested</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>() {
			panic(<span style=color:#e6db74>&#34;inline data write outside of object&#34;</span>)
		}
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Slot</span>(<span style=color:#a6e22e>voffset</span>)
	}
}
</code></pre></div><p>具体实现中也会先检查一下入参里面 2 个 UOffsetT 是否相等，其次再看看当前是否有嵌套，没有嵌套还要再检查一下 UOffsetT 是否和实际序列化以后的 offset 匹配，如果以上判断都通过了，就生成插槽 —— 在 vtable 中记录 offset。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependStructSlot</span>(<span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>pos</span>), <span style=color:#ae81ff>0</span>)
</code></pre></div><p>调用的时候会计算一次 struct 的 UOffsetT (32位，4字节)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CreateVec3</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>float32</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>float32</span>, <span style=color:#a6e22e>z</span> <span style=color:#66d9ef>float32</span>) <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span> {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>Prep</span>(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>12</span>)
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependFloat32</span>(<span style=color:#a6e22e>z</span>)
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependFloat32</span>(<span style=color:#a6e22e>y</span>)
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependFloat32</span>(<span style=color:#a6e22e>x</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>Offset</span>()
}
</code></pre></div><p>由于是 float32 类型，所以 size 是 4 字节，struct 中有 3 个变量，所以总大小是 12 字节。可以看出 struct 的值是直接放入内存中的，没有进行任何处理，而且也不涉及嵌套创建的问题，因此可以内联（inline）在其他结构中。并且存储的顺序和字段的顺序一样。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#ae81ff>1.0</span> <span style=color:#960050;background-color:#1e0010>浮点类型转成二进制为：</span><span style=color:#ae81ff>00111111100000000000000000000000</span>
<span style=color:#ae81ff>2.0</span> <span style=color:#960050;background-color:#1e0010>浮点类型转成二进制为：</span><span style=color:#ae81ff>01000000000000000000000000000000</span>
<span style=color:#ae81ff>3.0</span> <span style=color:#960050;background-color:#1e0010>浮点类型转成二进制为：</span><span style=color:#ae81ff>01000000010000000000000000000000</span>

</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>128</span> <span style=color:#ae81ff>63</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>64</span>
</code></pre></div><h3 id=6-序列化-table>6. 序列化 table</h3><p>与 struct 不同，table 不是以内联 inline 的方式存储在它们的父项中，而是通过引用偏移 offset。在 table 中有一个 SOffsetT，这个是 UOffsetT 的带符号的版本，它代表的偏移量是有方向的。由于 vtable 可以存储在任何位置，所以它的 offset 应该是从存储 object 开始，减去 vtable 开始，即计算 object 和 vtable 之间的 offset。</p><p>序列化 table 要分为 3 步，第一步 StartObject ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>StartObject</span>(<span style=color:#a6e22e>numfields</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>assertNotNested</span>()
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>nested</span> = <span style=color:#66d9ef>true</span>

	<span style=color:#75715e>// use 32-bit offsets so that arithmetic doesn&#39;t overflow.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> cap(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>) &lt; <span style=color:#a6e22e>numfields</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span> = make([]<span style=color:#a6e22e>UOffsetT</span>, <span style=color:#a6e22e>numfields</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>[:<span style=color:#a6e22e>numfields</span>]
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
			<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#ae81ff>0</span>
		}
	}

	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>objectEnd</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>()
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>minalign</span> = <span style=color:#ae81ff>1</span>
}
</code></pre></div><p>序列化 table 第一步是初始化 vtable。初始化之前先做异常判断，判断是否嵌套。接着就是初始化 vtable 空间，这里初始化用 UOffsetT = UOffsetT uint32 防止溢出。StartObject() 入参是字段的个数，注意 union 是 2 个字段。</p><p>每个 table 都会有自己的 vtable，其中存储着每个字段的 offset，这个就是上面 slot 函数的作用，产出的插槽都记录到 vtable 中。vtable 相同的会共享同一份 vtable。</p><p>第二步就是添加每个字段。添加字段的顺序可以是无序的，因为 flatc 编译以后把每个字段在插槽里面的顺序以后排列好了，不会因为我们调用序列化方法的顺序而改变，举个例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterAddPos</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>pos</span> <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependStructSlot</span>(<span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>pos</span>), <span style=color:#ae81ff>0</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterAddMana</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>mana</span> <span style=color:#66d9ef>int16</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependInt16Slot</span>(<span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>mana</span>, <span style=color:#ae81ff>150</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterAddHp</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>hp</span> <span style=color:#66d9ef>int16</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependInt16Slot</span>(<span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>hp</span>, <span style=color:#ae81ff>100</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterAddName</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependUOffsetTSlot</span>(<span style=color:#ae81ff>3</span>, <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>name</span>), <span style=color:#ae81ff>0</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterAddInventory</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>inventory</span> <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependUOffsetTSlot</span>(<span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>inventory</span>), <span style=color:#ae81ff>0</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterStartInventoryVector</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>numElems</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>StartVector</span>(<span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>numElems</span>, <span style=color:#ae81ff>1</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterAddColor</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>color</span> <span style=color:#66d9ef>int8</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependInt8Slot</span>(<span style=color:#ae81ff>6</span>, <span style=color:#a6e22e>color</span>, <span style=color:#ae81ff>2</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterAddWeapons</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>weapons</span> <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependUOffsetTSlot</span>(<span style=color:#ae81ff>7</span>, <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>weapons</span>), <span style=color:#ae81ff>0</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterStartWeaponsVector</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>numElems</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>StartVector</span>(<span style=color:#ae81ff>4</span>, <span style=color:#a6e22e>numElems</span>, <span style=color:#ae81ff>4</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterAddEquippedType</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>equippedType</span> <span style=color:#66d9ef>byte</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependByteSlot</span>(<span style=color:#ae81ff>8</span>, <span style=color:#a6e22e>equippedType</span>, <span style=color:#ae81ff>0</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterAddEquipped</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>equipped</span> <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependUOffsetTSlot</span>(<span style=color:#ae81ff>9</span>, <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>equipped</span>), <span style=color:#ae81ff>0</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterAddPath</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>path</span> <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependUOffsetTSlot</span>(<span style=color:#ae81ff>10</span>, <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>path</span>), <span style=color:#ae81ff>0</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MonsterStartPathVector</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>numElems</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>StartVector</span>(<span style=color:#ae81ff>12</span>, <span style=color:#a6e22e>numElems</span>, <span style=color:#ae81ff>4</span>)
</code></pre></div><p>上面是 Monster table 中所有字段的序列化实现，我们可以看每个函数的第一个参数，对应的是在 vtable 中插槽的位置。0 - pos，1 - mana，2 - hp，3 - name，(没有 4 - friendly，因为被 deprecated 了)，5 - inventory，6 - color，7 - weapons，8 - equippedType，9 - equipped，10 - path。Monster 中总共有 11 个字段(其中有一个废弃字段，union 算 2 个字段)，最终序列化需要序列化 10 个字段。<strong>这也是为什么 id 只能往后递增，不能往前加，也不能删除废弃字段的原因，因为插槽的位置一旦定下来了，就不能改变</strong>。有了 id，字段名变更就不影响了。</p><p>另外，<strong>从序列化列表中也能看出序列化 table 中是不能嵌套序列化 table / string / vector 类型的，它们不能 inline，必须在 root 对象创建之前先创建好</strong>。inventory 是标量数组，先序列化好了以后，在 Monster 中引用 offset 的。weapons 是 table 数组，同样也是先序列化好了，再引用 offset 的。path 是 struct 同样是引用。pos 是 struct ，直接 inline 在 table 中。equipped 是 union 也是直接 inline 在 table 中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WeaponAddName</span>(<span style=color:#a6e22e>builder</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>Builder</span>, <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#a6e22e>builder</span>.<span style=color:#a6e22e>PrependUOffsetTSlot</span>(<span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>flatbuffers</span>.<span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>name</span>), <span style=color:#ae81ff>0</span>)
}
</code></pre></div><p>序列化 weapon table 中的 name，计算 offset 是计算相对位置，不是相对于 buffer 末尾的 offset，而是相对于当前写入位置的 offset：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// PrependSOffsetT prepends an SOffsetT, relative to where it will be written.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>PrependSOffsetT</span>(<span style=color:#a6e22e>off</span> <span style=color:#a6e22e>SOffsetT</span>) {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Prep</span>(<span style=color:#a6e22e>SizeSOffsetT</span>, <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// Ensure alignment is already done.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> !(<span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>off</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>()) {
		panic(<span style=color:#e6db74>&#34;unreachable: off &lt;= b.Offset()&#34;</span>)
	}
	<span style=color:#75715e>// 注意这里要计算的是相当于当前写入位置的 offset
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>off2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SOffsetT</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>()) <span style=color:#f92672>-</span> <span style=color:#a6e22e>off</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>SOffsetT</span>(<span style=color:#a6e22e>SizeSOffsetT</span>)
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PlaceSOffsetT</span>(<span style=color:#a6e22e>off2</span>)
}

<span style=color:#75715e>// PrependUOffsetT prepends an UOffsetT, relative to where it will be written.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>PrependUOffsetT</span>(<span style=color:#a6e22e>off</span> <span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Prep</span>(<span style=color:#a6e22e>SizeUOffsetT</span>, <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// Ensure alignment is already done.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> !(<span style=color:#a6e22e>off</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>()) {
		panic(<span style=color:#e6db74>&#34;unreachable: off &lt;= b.Offset()&#34;</span>)
	}
	<span style=color:#75715e>// 注意这里要计算的是相当于当前写入位置的 offset
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>off2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>() <span style=color:#f92672>-</span> <span style=color:#a6e22e>off</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>SizeUOffsetT</span>)
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PlaceUOffsetT</span>(<span style=color:#a6e22e>off2</span>)
}
</code></pre></div><p>对于其他标量类型，直接计算 offset 即可，唯独需要注意 UOffsetT、SOffsetT 这两个。</p><p>序列化 table 的最后一步就是 EndObject()：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>EndObject</span>() <span style=color:#a6e22e>UOffsetT</span> {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>assertNested</span>()
	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>WriteVtable</span>()
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>nested</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
}
</code></pre></div><p>最后结束序列化的时候，也需先判断是否嵌套。重要的是需要 WriteVtable()。在看 WriteVtable() 具体实现的时候，需要先介绍一下 vtable 的数据结构。</p><p>vtable 的元素都是 VOffsetT 类型，它是 uint16。第一个元素是 vtable 的大小（以字节为单位），包括自身。第二个是对象的大小，以字节为单位（包括 vtable 偏移量）。这个大小可以用于流式传输，知道要读取多少字节才能访问对象的所有内联 inline 字段。第三个是 N 个偏移量，其中 N 是编译构建此 buffer 的代码编译时（因此，表的大小为 N + 2）时在 schema 中声明的字段数量(包括 deprecated 字段)。每个以 SizeVOffsetT 字节为宽度。见下图：</p><p>一个 object 的第一个元素是 SOffsetT，object 和 vtable 之间的偏移量，可正可负。第二个元素就是 object 的数据 data。在读取 object 的时候，会先比较一下 SOffsetT，防止新代码读取旧数据的情况。如果要读取的字段在 offset 中超出了数组的范围，或者 vtable 的条目为 0，则表示此对象中不存在该字段，并且返回该字段的默认值。如果没有超出范围，则读取该字段的 offset。</p><p>接下来详细看看 WriteVtable() 的具体实现：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>WriteVtable</span>() (<span style=color:#a6e22e>n</span> <span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#75715e>// 1. 添加 0 对齐标量，对齐以后写入 offset，之后这一位会被距离 vtable 的 offset 重写覆盖掉
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PrependSOffsetT</span>(<span style=color:#ae81ff>0</span>)

	<span style=color:#a6e22e>objectOffset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>()
	<span style=color:#a6e22e>existingVtable</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>UOffsetT</span>(<span style=color:#ae81ff>0</span>)

	<span style=color:#75715e>// 2. 去掉末尾 0
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
	<span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>--</span> {
	}
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>[:<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]

	<span style=color:#75715e>// 3. 从 vtables 中逆向搜索已经存储过的 vtable，如果存在相同的且已经存储过的 vtable，直接找到它，索引指向它即可
</span><span style=color:#75715e></span>	<span style=color:#75715e>//    可以查看 BenchmarkVtableDeduplication 的测试结果，通过索引指向相同的 vtable，而不是新建一个，这种做法可以提高 30% 性能
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtables</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>--</span> {
		<span style=color:#75715e>// 从 vtables 筛选出一个 vtable
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>vt2Offset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtables</span>[<span style=color:#a6e22e>i</span>]
		<span style=color:#a6e22e>vt2Start</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>) <span style=color:#f92672>-</span> int(<span style=color:#a6e22e>vt2Offset</span>)
		<span style=color:#a6e22e>vt2Len</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetVOffsetT</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>[<span style=color:#a6e22e>vt2Start</span>:])

		<span style=color:#a6e22e>metadata</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>VtableMetadataFields</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>SizeVOffsetT</span>
		<span style=color:#a6e22e>vt2End</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>vt2Start</span> <span style=color:#f92672>+</span> int(<span style=color:#a6e22e>vt2Len</span>)
		<span style=color:#a6e22e>vt2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>[<span style=color:#a6e22e>vt2Start</span><span style=color:#f92672>+</span><span style=color:#a6e22e>metadata</span> : <span style=color:#a6e22e>vt2End</span>]

		<span style=color:#75715e>// 4. 比较循环到当前的 b.vtable 和 vt2，如果相同，offset 就记录到 existingVtable 中，只要找到一个就可以 break 了
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>vtableEqual</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>, <span style=color:#a6e22e>objectOffset</span>, <span style=color:#a6e22e>vt2</span>) {
			<span style=color:#a6e22e>existingVtable</span> = <span style=color:#a6e22e>vt2Offset</span>
			<span style=color:#66d9ef>break</span>
		}
	}

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>existingVtable</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#75715e>// 5. 如果找不到一个相同的 vtable，只能创建一个新的写入到 buffer 中
</span><span style=color:#75715e></span>		<span style=color:#75715e>//    写入的方式也是逆向写入，因为序列化的方向是尾优先。
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>--</span> {
			<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>off</span> <span style=color:#a6e22e>UOffsetT</span>
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
				<span style=color:#75715e>// 6. 从对象的头开始，计算后面属性的偏移量
</span><span style=color:#75715e></span>				<span style=color:#a6e22e>off</span> = <span style=color:#a6e22e>objectOffset</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>[<span style=color:#a6e22e>i</span>]
			}
			<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PrependVOffsetT</span>(<span style=color:#a6e22e>VOffsetT</span>(<span style=color:#a6e22e>off</span>))
		}

		<span style=color:#75715e>// 7. 最后写入两个 metadata 元数据字段
</span><span style=color:#75715e></span>		<span style=color:#75715e>//    第一步，先写 object 的 size 大小，包含 vtable 偏移量
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>objectSize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>objectOffset</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>objectEnd</span>
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PrependVOffsetT</span>(<span style=color:#a6e22e>VOffsetT</span>(<span style=color:#a6e22e>objectSize</span>))

		<span style=color:#75715e>// 8. 第二步，存储 vtable 的大小
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>vBytes</span> <span style=color:#f92672>:=</span> (len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>VtableMetadataFields</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>SizeVOffsetT</span>
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PrependVOffsetT</span>(<span style=color:#a6e22e>VOffsetT</span>(<span style=color:#a6e22e>vBytes</span>))

		<span style=color:#75715e>// 9. 最后一步，修改 object 中头部的距离 vtable 的 offset 值，值是 SOffsetT，4字节
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>objectStart</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SOffsetT</span>(len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>)) <span style=color:#f92672>-</span> <span style=color:#a6e22e>SOffsetT</span>(<span style=color:#a6e22e>objectOffset</span>)
		<span style=color:#a6e22e>WriteSOffsetT</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>[<span style=color:#a6e22e>objectStart</span>:],
			<span style=color:#a6e22e>SOffsetT</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>())<span style=color:#f92672>-</span><span style=color:#a6e22e>SOffsetT</span>(<span style=color:#a6e22e>objectOffset</span>))

		<span style=color:#75715e>// 10. 最后，把 vtable 存储在内存中，以便以后“去重”(相同的 vtable 不创建，修改索引即可)
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtables</span> = append(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtables</span>, <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Offset</span>())
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#75715e>// 11. 如果找到了一个相同的 vtable
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>objectStart</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SOffsetT</span>(len(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>)) <span style=color:#f92672>-</span> <span style=color:#a6e22e>SOffsetT</span>(<span style=color:#a6e22e>objectOffset</span>)
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>head</span> = <span style=color:#a6e22e>UOffsetT</span>(<span style=color:#a6e22e>objectStart</span>)

		<span style=color:#75715e>// 12. 修改 object 中头部的距离 vtable 的 offset 值，值是 SOffsetT，4字节
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>WriteSOffsetT</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>[<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>head</span>:],
			<span style=color:#a6e22e>SOffsetT</span>(<span style=color:#a6e22e>existingVtable</span>)<span style=color:#f92672>-</span><span style=color:#a6e22e>SOffsetT</span>(<span style=color:#a6e22e>objectOffset</span>))
	}

	<span style=color:#75715e>// 13. 最后销毁 b.vtable
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>vtable</span>[:<span style=color:#ae81ff>0</span>]
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>objectOffset</span>
}
</code></pre></div><p>接下来分步来解释一下：</p><p>第 1 步，添加 0 对齐标量，对齐以后写入 offset，之后这一位会被距离 vtable 的 offset 重写覆盖掉。<code>b.PrependSOffsetT(0)</code></p><p>Weapon 在 schema 中的定义如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>table</span> <span style=color:#a6e22e>Weapon</span> {
  <span style=color:#a6e22e>name</span>:<span style=color:#66d9ef>string</span>;
  <span style=color:#a6e22e>damage</span>:<span style=color:#a6e22e>short</span>;
}
</code></pre></div><p>Weapon 有 2 个字段，一个是 name，一个是 damage。name 是 string，需要在 table 创建之前创建，并且在 table 中只能引用它的 offset。我们这里先创建好了 “sword” 的 string，offset 为 12，所以在 sword 对象中，需要引用 12 这个 offset，当前 offset 为 24，减去 12，等于 12，所以这里填上 12，表示的意义是往前偏移 12 存储的数据才是这里的 name。damage 是一个 short，直接内嵌在 sword 对象中即可。加上 4 字节对齐的 2 个 0，开头还要再加上 4 字节的当前 offset 偏移量。<strong>注意，这个时候的偏移量是针对 buffer 尾来说的，还不是针对 vtable 而言的偏移量</strong>。当前 b.offset() 为 32，所以填充 4 字节的 32 。</p><p>第 3 步，从 vtables 中逆向搜索已经存储过的 vtable，如果存在相同的且已经存储过的 vtable，直接找到它，索引指向它即可。可以查看 BenchmarkVtableDeduplication 的测试结果，通过索引指向相同的 vtable，而不是新建一个，这种做法可以提高 30% 性能。</p><p>这一步就是查找 vtable。如果没有找到就新建 vtable，如果找到了就修改索引指向它。</p><p>先假设没有找到。走到第 5 步。</p><p>当前 vtable 中存的值是 [24,26]，即 sword 对象中 name 和 damage 的 offset 。从对象的头开始，计算后面属性的偏移量。<code>off = objectOffset - b.vtable[i]</code>。这里对应上面代码的第 6 步。</p><p>第 6 步到第 8 步得到的结果是下图：</p><p>从右往左计算 sword 的 offset，当前 sword 的 offset 是 32，偏移 6 个字节到 Damage 字段，继续再偏移 2 个字节到 name 字段。所以 vtable 中末尾 4 个字节为 8 0 6 0 。sword 对象整个大小为 12 字节，包括头的 offset。最后填入 vtable 的大小，8 字节大小。</p><p>最后一步需要修正 sword 对象头部的 offset，修改成距离 vtable 的 offset。由于当前 vtable 在低地址，所以 sword 对象在它的右边，offset 为正数，offset = vtable size = 8 字节。对应代码实现见第 10 步。</p><p>如果之前在 vtables 中找到了一样的 vtable，那么就在对象的头部的 offset 改成距离 vtable 的 offset 即可，对应代码第 12 步。</p><p>这里可以用 axe 对象的例子来说明找到相同 vtable 的情况。由于 sword 对象和 axe 对象都是 Weapon 类型的，所以对象内部的字段偏移结构应该是完全一样的，故共享一个结构的 vtable。sword 对象先创建，vtable 紧接在它后面，再创建的 axe 对象，所以 axe 对象头部的 offset 为负数。这里为 -12 。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#ae81ff>12</span> <span style=color:#960050;background-color:#1e0010>的原码</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>00000000</span> <span style=color:#ae81ff>00000000</span> <span style=color:#ae81ff>00000000</span> <span style=color:#ae81ff>00001100</span>
<span style=color:#ae81ff>12</span> <span style=color:#960050;background-color:#1e0010>的反码</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>11111111</span> <span style=color:#ae81ff>11111111</span> <span style=color:#ae81ff>11111111</span> <span style=color:#ae81ff>11110011</span>
<span style=color:#ae81ff>12</span> <span style=color:#960050;background-color:#1e0010>的补码</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>11111111</span> <span style=color:#ae81ff>11111111</span> <span style=color:#ae81ff>11111111</span> <span style=color:#ae81ff>11110100</span>
</code></pre></div><p>逆向存储即为 244 255 255 255 。</p><h3 id=7-结束序列化>7. 结束序列化</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Builder</span>) <span style=color:#a6e22e>Finish</span>(<span style=color:#a6e22e>rootTable</span> <span style=color:#a6e22e>UOffsetT</span>) {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>assertNotNested</span>()
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Prep</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>minalign</span>, <span style=color:#a6e22e>SizeUOffsetT</span>)
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>PrependUOffsetT</span>(<span style=color:#a6e22e>rootTable</span>)
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>finished</span> = <span style=color:#66d9ef>true</span>
}
</code></pre></div><p>结束序列化的时候，还需要执行两步操作，一是字节对齐，二是存放指向 root object 的 offset。</p><p>由于在 schema 中我们定义了 root object 为 Monster，序列化完 Monster 对象之后，又紧接着生成了它的 vtable，所以这里 root table 的 offset 为 32 。</p><p>至此，整个 Monster 就序列化完成了，最终形成的二进制 buffer 如下：</p><p>上图中二进制流上面标的数字，为字段的 offset 值。二进制流下方标识的是字段名。</p><h2 id=五-flatbuffers-解码原理>五. FlatBuffers 解码原理</h2><p>flatBuffers 解码的过程就很简单了。由于序列化的时候保存好了各个字段的 offset，反序列化的过程其实就是把数据从指定的 offset 中读取出来。</p><p>对于标量，分 2 种情况，有默认值和没有默认值。在上面的例子中，Mana 字段我们序列化的时候，就直接采用的默认值。在 flatbuffer 的二进制流中可以看到 Mana 字段都是 0 ，offset 也为 0，其实这个字段采用的是默认值，在读取的时候，会直接从 flatc 编译后的文件中记录的默认值中读取出来。</p><p>Hp 字段有默认值，但是在序列化的时候我们并没有用默认值，而是重新给他了一个新值，这个时候，二进制流中就会记录 Hp 的 offset，值也会存储在二进制流中。</p><p>反序列化的过程是把二进制流从 root table 往后读。从 vtable 中读取对应的 offset，然后在对应的 object 中找到对应的字段，如果是引用类型，string / vector / table，读取出 offset，再次寻找 offset 对应的值，读取出来。如果是非引用类型，根据 vtable 中的 offset ，找到对应的位置直接读取即可。</p><p>整个反序列化的过程零拷贝，不消耗占用任何内存资源。并且 flatbuffer 可以读取任意字段，而不是像 JSON 和 protocol buffer 需要读取整个对象以后才能获取某个字段。flatbuffer 的主要优势就在反序列化这里了。</p><h2 id=六-flatbuffers-性能>六. FlatBuffers 性能</h2><p>既然 flatbuffer 的优势在反序列化上，那我们就来对比对比，性能究竟有多强。</p><ol><li><p>编码性能：flatbuf 的编码性能要比 protobuf 低。在JSON、protobuf 和 flatbuf 之中，flatbuf 编码性能最差，JSON 介于二者之间。</p></li><li><p>编码后的数据长度：由于通常情况下，传输的数据都会做压缩。在不压缩的情况下，flatbuffer 的数据长度是最长的，理由也很简单，因为二进制流内部填充了很多字节对齐的 0，并且原始数据也没有采取特殊的压缩处理，整个数据膨胀的更大了。不管压不压缩，flatbuffer 的数据长度都是最长的。JSON 经过压缩以后，数据长度会近似于 protocol buffer。protocol buffer 由于自身编码就有压缩，再经过 GZIP 这些压缩算法压缩以后，长度始终维持最小。</p></li><li><p>解码性能：flatbuffer 是一种无需解码的二进制格式，因而解码性能要高许多，大概要比 protobuf 快几百倍的样子，因而比 JSON 快的就更多了。</p></li></ol><p>结论是，如果需要重度依赖反序列化的场景，可以考虑用 flatbuffer。protobuf 则是表现出各方面都很均衡的能力。</p><h2 id=六-flatbuffers-优缺点>六. FlatBuffers 优缺点</h2><p>读完本篇 FlatBuffers 编码原理以后，读者应该能明白以下几点：</p><p>FlatBuffers 的 API 也比较繁琐，创建 buffer 的 API 和 C++ 的 Cocos2D-X 里面创建 sprite 有点类似。可能就是天生为游戏而生的吧。</p><p>与 protocol buffers 相比，FlatBuffers 优点有以下这些：</p><ol><li>不需要解析/拆包就可以访问序列化数据<br>访问序列化数据甚至层级数据都不需要解析。归功于此，我们不需要花费时间去初始化解析器（意味着构建复杂的字段映射）和解析数据。</li><li>直接使用内存<br>FlatBuffers 数据使用自己的内存缓冲区，不需要分配其他更多的内存。我们不需要像 JSON 那样在解析数据的时候，为整个层级数据分配额外的内存对象。<strong>FlatBuffers 算是 zero-copy + Random-access reads 版本的 protobuf</strong>。</li></ol><p>FlatBuffers 提供的优点并不是无任何妥协。它的缺点也算是为了它的优点做的牺牲。</p><ol><li>无可读性<br>flatBuffers 和 protocol buffers 组织数据的形式都使用的二进制数据形式，这就意味着调试程序难度会增加。(一定程度上也算是优点，有一定“安全性”)</li><li>API 略繁琐<br>由于二进制协议的构造方法，数据必须以“从内到外”的方式插入。构建 FlatBuffers 对象比较麻烦。</li><li>向后兼容性<br>在处理结构化二进制数据时，我们必须考虑对该结构进行更改的可能性。从我们的 schema 中添加或删除字段必须小心。读取旧版本对象时，错误的 schema 更改可能会导致出错了但是没有提示。</li><li>牺牲了序列化的性能<br>由于 flatbuffer 为了反序列化的性能，所以牺牲了一些序列化时候的性能，序列化的数据长度最长，性能也最差。</li></ol><h2 id=七-最后>七. 最后</h2><p>最后的最后，邻近文章结束，又发现了一个性能和特点和 Flatbuffers 类似的开源库</p><p>Cap&rsquo;n Proto 是一个疯狂快速的数据交换格式并且也同样可用于 RPC 系统中。这里有一篇性能对比的文章，<a href=https://capnproto.org/news/2014-06-17-capnproto-flatbuffers-sbe.html>《Cap&rsquo;n Proto: Cap&rsquo;n Proto, FlatBuffers, and SBE》</a>，感兴趣的同学可以当额外的阅读材料看看。</p><hr><p>Reference：</p><p><a href=https://google.github.io/flatbuffers/index.html>flatbuffers 官方文档</a><br><a href=https://github.com/dvidelabs/flatcc/blob/master/doc/binary-format.md#flatbuffers-binary-format>flatcc 官方文档</a><br><a href=https://code.facebook.com/posts/872547912839369/improving-facebook-s-performance-on-android-with-flatbuffers/>Improving Facebook&rsquo;s performance on Android with FlatBuffers</a><br><a href=https://capnproto.org/news/2014-06-17-capnproto-flatbuffers-sbe.html>Cap&rsquo;n Proto: Cap&rsquo;n Proto, FlatBuffers, and SBE</a><br><a href=https://www.zhihu.com/question/28500901>使用 flatbuffer 能在真实游戏项目的数据读写过程中提速多少?</a><br><a href=https://www.race604.com/flatbuffers-intro/#fn:1>FlatBuffers 体验</a><br><a href=https://www.wolfcstech.com/2016/12/08/%E5%9C%A8Android%E4%B8%AD%E4%BD%BF%E7%94%A8FlatBuffers/>在Android中使用FlatBuffers</a></p><blockquote><p>GitHub Repo：<a href=https://github.com/halfrost/Halfrost-Field>Halfrost-Field</a></p><p>Follow: <a href=https://github.com/halfrost>halfrost · GitHub</a></p><p>Source: <a href=https://halfrost.com/flatbuffers_encode/>https://halfrost.com/flatbuffers_encode/</a></p></blockquote><img src=https://img.halfrost.com/wechat-qr-code.png></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div id=toc-footer style=display:none><nav id=TableOfContents><ul><li><a href=#一-flatbuffers-生成二进制流>一. FlatBuffers 生成二进制流</a></li><li><a href=#二-flatbuffers-读取二进制流>二. FlatBuffers 读取二进制流</a></li><li><a href=#三-可变的-flatbuffers>三. 可变的 FlatBuffers</a></li><li><a href=#四-flatbuffers-编码原理>四. FlatBuffers 编码原理</a><ul><li><a href=#1-新建-flatbufferbuilder>1. 新建 FlatBufferBuilder</a></li><li><a href=#2-序列化标量数据>2. 序列化标量数据</a></li><li><a href=#3-序列化数组>3. 序列化数组</a></li><li><a href=#4-序列化-string>4. 序列化 string</a></li><li><a href=#5-序列化-struct>5. 序列化 struct</a></li><li><a href=#6-序列化-table>6. 序列化 table</a></li><li><a href=#7-结束序列化>7. 结束序列化</a></li></ul></li><li><a href=#五-flatbuffers-解码原理>五. FlatBuffers 解码原理</a></li><li><a href=#六-flatbuffers-性能>六. FlatBuffers 性能</a></li><li><a href=#六-flatbuffers-优缺点>六. FlatBuffers 优缺点</a></li><li><a href=#七-最后>七. 最后</a></li></ul></nav></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f"><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&text=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&is_video=false&description=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f"><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-stumbleupon fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&title=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-digg fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&name=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode&description=%e4%b8%80.%20FlatBuffers%20%e7%94%9f%e6%88%90%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%b5%81%20FlatBuffers%20%e7%9a%84%e4%bd%bf%e7%94%a8%e5%92%8c%20Protocol%20buffers%20%e5%9f%ba%e6%9c%ac%e7%b1%bb%e4%bc%bc%e3%80%82%e5%8f%aa%e4%b8%8d%e8%bf%87%e5%8a%9f%e8%83%bd%e6%af%94%20Protocol%20buffers%20%e5%a4%9a%e4%ba%86%e4%b8%80%e4%b8%aa%e8%a7%a3%e6%9e%90%20JSON%20%e7%9a%84%e5%8a%9f%e8%83%bd%e3%80%82%0a%20%e7%bc%96%e5%86%99%20schema%20%e6%96%87%e4%bb%b6%ef%bc%8c%e6%8f%8f%e8%bf%b0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%92%8c%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89%e3%80%82%20%e7%94%a8%20flatc%20%e7%bc%96%e8%af%91%ef%bc%8c%e7%94%9f%e6%88%90%e7%9b%b8%e5%ba%94%e8%af%ad%e8%a8%80%e7%9a%84%e4%bb%a3%e7%a0%81%e6%96%87%e4%bb%b6%e3%80%82%20%e8%a7%a3%e6%9e%90%20JSON%20%e6%95%b0%e6%8d%ae%ef%bc%8c%e6%8a%8a%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e6%88%90%e5%af%b9%e5%ba%94%e7%9a%84%20schema%ef%bc%8c%e5%b9%b6%e5%ad%98%e5%85%a5%20FlatBuffers%20%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6%e4%b8%ad%e3%80%82%20%e4%bd%bf%e7%94%a8%20FlatBuffers%20%e6%94%af%e6%8c%81%e7%9a%84%e8%af%ad%e8%a8%80%ef%bc%88%e5%a6%82C%20%2b%2b%ef%bc%8cJava%e7%ad%89%ef%bc%89%e7%94%9f%e6%88%90%e7%9a%84%e6%96%87%e4%bb%b6%e8%bf%9b%e8%a1%8c%e5%bc%80%e5%8f%91%e3%80%82%20%20%e6%8e%a5%e4%b8%8b%e6%9d%a5%e7%ae%80%e5%8d%95%e7%9a%84%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%20schema%20%e6%96%87%e4%bb%b6%ef%bc%8c%e6%9d%a5%e7%9c%8b%e7%9c%8b%20FlatBuffers%20%e7%9a%84%e4%bd%bf%e7%94%a8%e3%80%82%0a%2f%2f%20Example%20IDL%20file%20for%20our%20monster%27s%20schema.%20namespace%20MyGame.Sample%3b%20enum%20Color%3abyte%20%7b%20Red%20%3d%200%2c%20Green%2c%20Blue%20%3d%202%20%7d%20union%20Equipment%20%7b%20Weapon%20%7d%20%2f%2f%20Optionally%20add%20more%20tables.%20struct%20Vec3%20%7b%20x%3afloat%3b%20y%3afloat%3b%20z%3afloat%3b%20%7d%20table%20Monster%20%7b%20pos%3aVec3%3b%20%2f%2f%20Struct."><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fflatbuffers_encode%2f&t=%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20FlatBuffers%20%e4%b9%8b%20Encode"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu class=icon href=# onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden=true></i>Menu</a>
<a id=toc class=icon href=# onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden=true></i>TOC</a>
<a id=share class=icon href=# onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden=true></i>share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i>Top</a></div></div></div><footer id=footer><div class=footer-left><p class=copyright style=float:left;margin-bottom:0><a href=https://github.com/halfrost/Halfrost-Field class=github-repo style=height:18px><span class=gadget-github></span>Star</a>
Copyright &copy;halfrost 2016 - 2021
<a href=http://www.miit.gov.cn/>鄂ICP备16014744号</a></p><br><p class="copyright statistics" style=margin-bottom:20px><span id=busuanzi_container_site_pv>Cumulative Page Views <span id=busuanzi_value_site_pv></span>| Unique Visitors <span id=busuanzi_value_site_uv></span></span></p></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/main.min.f870a4d110314b9e50e65f8ac982dc1c9c376c8f1a5083d39c62cfc49073f011.js></script><script async src=/prism.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>
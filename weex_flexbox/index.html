<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=theme-color content="#FFFFFF"><meta http-equiv=x-ua-compatible content="IE=edge"><title>由 FlexBox 算法强力驱动的 Weex 布局引擎 | prometheus</title><meta name=description content="Explore in every moment of the hard thinking"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="由 FlexBox 算法强力驱动的 Weex 布局引擎"><meta property="og:description" content="前言 在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局原生界面的，之后还会与现有的布局方法进行对比，看看Weex的布局性能究竟如何。
目录  1.Weex布局算法 2.Weex布局算法性能分析 3.Weex是如何布局原生界面的  一. Weex布局算法 打开Weex的源码的Layout文件夹，就会看到两个c的文件，这两个文件就是今天要谈的Weex的布局引擎。
Layout.h和Layout.c最开始是来自于React-Native里面的代码。也就是说Weex和React-Native的布局引擎都是同一套代码。
当前React-Native的代码里面已经没有这两个文件了，而是换成了Yoga。
Yoga本是Facebook在React Native里引入的一种跨平台的基于CSS的布局引擎，它实现了Flexbox规范，完全遵守W3C的规范。随着该系统不断完善，Facebook对其进行重新发布，于是就成了现在的Yoga(Yoga官网)。
那么Flexbox是什么呢？
熟悉前端的同学一定很熟悉这个概念。2009年，W3C提出了一种新的方案——Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了几乎所有浏览器的支持，目前的前端主要是使用Html / CSS / JS实现，其中CSS用于前端的布局。任何一个Html的容器可以通过css指定为Flex布局，一旦一个容器被指定为Flex布局，其子元素就可以按照FlexBox的语法进行布局。
关于FlexBox的基本定义，更加详细的文档说明，感兴趣的同学可以去阅读一下W3C的官方文档，那里会有很详细的说明。官方文档链接
Weex中的Layout文件是Yoga的前身，是Yoga正式发布之前的版本。底层代码使用C语言代码，所以性能也不是问题。接下来就仔细分析Layout文件是如何实现FlexBox的。
故以下源码分析都基于v0.10.0这个版本。
（一）FlexBox中的基本数据结构 Flexbox布局（Flexible Box)设计之初的目的是为了能更加高效的分配子视图的布局情况，包括动态的改变宽度，高度，以及排列顺序。Flexbox可以更加方便的兼容各个大小不同的屏幕，比如拉伸和压缩子视图。
在FlexBox的世界里，存在着主轴和侧轴的概念。
大多数情况，子视图都是沿着主轴（main axis），从主轴起点（main-start）到主轴终点（main-end）排列。但是这里需要注意的一点是，主轴和侧轴虽然永远是垂直的关系，但是谁是水平，谁是竖直，并没有确定，有可能会有如下的情况：
在上图这种水平是侧轴的情况下，子视图是沿着侧轴（cross axis），从侧轴起点（cross-start）到侧轴终点（cross-end）排列的。
**主轴（main axis）：**父视图的主轴，子视图主要沿着这条轴进行排列布局。
**主轴起点（main-start）和主轴终点（main-end）：**子视图在父视图里面布局的方向是从主轴起点（main-start）向主轴终点（main-start）的方向。
**主轴尺寸（main size）：**子视图在主轴方向的宽度或高度就是主轴的尺寸。子视图主要的大小属性要么是宽度，要么是高度属性，由哪一个对着主轴方向决定。
**侧轴（cross axis）：**垂直于主轴称为侧轴。它的方向主要取决于主轴方向。
**侧轴起点（cross-start）和侧轴终点（cross-end）：**子视图行的配置从容器的侧轴起点边开始，往侧轴终点边结束。
**侧轴尺寸（cross size）：**子视图的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是「width」或「height」属性，由哪一个对着侧轴方向决定。
接下来看看Layout是怎么定义FlexBox里面的元素的。
typedef enum { CSS_DIRECTION_INHERIT = 0, CSS_DIRECTION_LTR, CSS_DIRECTION_RTL } css_direction_t; 这个方向是定义的上下文的整体布局的方向，INHERIT是继承，LTR是Left To Right，从左到右布局。RTL是Right To Left，从右到左布局。下面分析如果不做特殊说明，都是LTR从左向右布局。如果是RTL就是LTR反向。
typedef enum { CSS_FLEX_DIRECTION_COLUMN = 0, CSS_FLEX_DIRECTION_COLUMN_REVERSE, CSS_FLEX_DIRECTION_ROW, CSS_FLEX_DIRECTION_ROW_REVERSE } css_flex_direction_t; 这里定义的是Flex的方向。"><meta property="og:type" content="article"><meta property="og:url" content="https://new.halfrost.com/weex_flexbox/"><meta property="article:published_time" content="2017-03-31T08:26:00+00:00"><meta property="article:modified_time" content="2017-03-31T08:26:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="由 FlexBox 算法强力驱动的 Weex 布局引擎"><meta name=twitter:description content="前言 在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局原生界面的，之后还会与现有的布局方法进行对比，看看Weex的布局性能究竟如何。
目录  1.Weex布局算法 2.Weex布局算法性能分析 3.Weex是如何布局原生界面的  一. Weex布局算法 打开Weex的源码的Layout文件夹，就会看到两个c的文件，这两个文件就是今天要谈的Weex的布局引擎。
Layout.h和Layout.c最开始是来自于React-Native里面的代码。也就是说Weex和React-Native的布局引擎都是同一套代码。
当前React-Native的代码里面已经没有这两个文件了，而是换成了Yoga。
Yoga本是Facebook在React Native里引入的一种跨平台的基于CSS的布局引擎，它实现了Flexbox规范，完全遵守W3C的规范。随着该系统不断完善，Facebook对其进行重新发布，于是就成了现在的Yoga(Yoga官网)。
那么Flexbox是什么呢？
熟悉前端的同学一定很熟悉这个概念。2009年，W3C提出了一种新的方案——Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了几乎所有浏览器的支持，目前的前端主要是使用Html / CSS / JS实现，其中CSS用于前端的布局。任何一个Html的容器可以通过css指定为Flex布局，一旦一个容器被指定为Flex布局，其子元素就可以按照FlexBox的语法进行布局。
关于FlexBox的基本定义，更加详细的文档说明，感兴趣的同学可以去阅读一下W3C的官方文档，那里会有很详细的说明。官方文档链接
Weex中的Layout文件是Yoga的前身，是Yoga正式发布之前的版本。底层代码使用C语言代码，所以性能也不是问题。接下来就仔细分析Layout文件是如何实现FlexBox的。
故以下源码分析都基于v0.10.0这个版本。
（一）FlexBox中的基本数据结构 Flexbox布局（Flexible Box)设计之初的目的是为了能更加高效的分配子视图的布局情况，包括动态的改变宽度，高度，以及排列顺序。Flexbox可以更加方便的兼容各个大小不同的屏幕，比如拉伸和压缩子视图。
在FlexBox的世界里，存在着主轴和侧轴的概念。
大多数情况，子视图都是沿着主轴（main axis），从主轴起点（main-start）到主轴终点（main-end）排列。但是这里需要注意的一点是，主轴和侧轴虽然永远是垂直的关系，但是谁是水平，谁是竖直，并没有确定，有可能会有如下的情况：
在上图这种水平是侧轴的情况下，子视图是沿着侧轴（cross axis），从侧轴起点（cross-start）到侧轴终点（cross-end）排列的。
**主轴（main axis）：**父视图的主轴，子视图主要沿着这条轴进行排列布局。
**主轴起点（main-start）和主轴终点（main-end）：**子视图在父视图里面布局的方向是从主轴起点（main-start）向主轴终点（main-start）的方向。
**主轴尺寸（main size）：**子视图在主轴方向的宽度或高度就是主轴的尺寸。子视图主要的大小属性要么是宽度，要么是高度属性，由哪一个对着主轴方向决定。
**侧轴（cross axis）：**垂直于主轴称为侧轴。它的方向主要取决于主轴方向。
**侧轴起点（cross-start）和侧轴终点（cross-end）：**子视图行的配置从容器的侧轴起点边开始，往侧轴终点边结束。
**侧轴尺寸（cross size）：**子视图的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是「width」或「height」属性，由哪一个对着侧轴方向决定。
接下来看看Layout是怎么定义FlexBox里面的元素的。
typedef enum { CSS_DIRECTION_INHERIT = 0, CSS_DIRECTION_LTR, CSS_DIRECTION_RTL } css_direction_t; 这个方向是定义的上下文的整体布局的方向，INHERIT是继承，LTR是Left To Right，从左到右布局。RTL是Right To Left，从右到左布局。下面分析如果不做特殊说明，都是LTR从左向右布局。如果是RTL就是LTR反向。
typedef enum { CSS_FLEX_DIRECTION_COLUMN = 0, CSS_FLEX_DIRECTION_COLUMN_REVERSE, CSS_FLEX_DIRECTION_ROW, CSS_FLEX_DIRECTION_ROW_REVERSE } css_flex_direction_t; 这里定义的是Flex的方向。"><link rel=stylesheet href=/css/style-white.min.css><link rel=manifest href=/manifest.json><link rel=stylesheet href=/prism.css><link href=/images/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=/images/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=/images/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=/images/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=/images/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=/images/apple-touch-icon-512x512.png rel=apple-touch-icon sizes=512x512><link href=/images/apple-touch-icon-1024x1024.png rel=apple-touch-icon sizes=1024x1024><script async>if('serviceWorker'in navigator){navigator.serviceWorker.register("\/serviceworker-v1.min.a64912b78d282eab1ad3715a0943da21616e5f326f8afea27034784ad445043b.js").then(function(){if(navigator.serviceWorker.controller){console.log('Assets cached by the controlling service worker.');}else{console.log('Please reload this page to allow the service worker to handle network operations.');}}).catch(function(error){console.log('ERROR: '+error);});}else{console.log('Service workers are not supported in the current browser.');}</script><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://new.halfrost.com/images/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-82753806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="single-max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a><a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a><a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast');" style=display:none><i class="fas fa-chevron-up fa-lg"></i></a><span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://new.halfrost.com/weex_ios/><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li><li><a class=icon href=https://new.halfrost.com/weex_event/><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li><li><a class=icon href=#><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f"><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&text=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&title=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&is_video=false&description=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f"><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&title=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&title=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&title=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-stumbleupon" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&title=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-digg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&name=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e&description=%e5%89%8d%e8%a8%80%20%e5%9c%a8%e4%b8%8a%e7%af%87%e6%96%87%e7%ab%a0%e9%87%8c%e9%9d%a2%e8%b0%88%e4%ba%86Weex%e5%9c%a8iOS%e5%ae%a2%e6%88%b7%e7%ab%af%e5%b7%a5%e4%bd%9c%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%b5%81%e7%a8%8b%e3%80%82%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e5%b0%86%e4%bc%9a%e8%af%a6%e7%bb%86%e7%9a%84%e5%88%86%e6%9e%90Weex%e6%98%af%e5%a6%82%e4%bd%95%e9%ab%98%e6%80%a7%e8%83%bd%e7%9a%84%e5%b8%83%e5%b1%80%e5%8e%9f%e7%94%9f%e7%95%8c%e9%9d%a2%e7%9a%84%ef%bc%8c%e4%b9%8b%e5%90%8e%e8%bf%98%e4%bc%9a%e4%b8%8e%e7%8e%b0%e6%9c%89%e7%9a%84%e5%b8%83%e5%b1%80%e6%96%b9%e6%b3%95%e8%bf%9b%e8%a1%8c%e5%af%b9%e6%af%94%ef%bc%8c%e7%9c%8b%e7%9c%8bWeex%e7%9a%84%e5%b8%83%e5%b1%80%e6%80%a7%e8%83%bd%e7%a9%b6%e7%ab%9f%e5%a6%82%e4%bd%95%e3%80%82%0a%e7%9b%ae%e5%bd%95%20%201.Weex%e5%b8%83%e5%b1%80%e7%ae%97%e6%b3%95%202.Weex%e5%b8%83%e5%b1%80%e7%ae%97%e6%b3%95%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%203.Weex%e6%98%af%e5%a6%82%e4%bd%95%e5%b8%83%e5%b1%80%e5%8e%9f%e7%94%9f%e7%95%8c%e9%9d%a2%e7%9a%84%20%20%e4%b8%80.%20Weex%e5%b8%83%e5%b1%80%e7%ae%97%e6%b3%95%20%e6%89%93%e5%bc%80Weex%e7%9a%84%e6%ba%90%e7%a0%81%e7%9a%84Layout%e6%96%87%e4%bb%b6%e5%a4%b9%ef%bc%8c%e5%b0%b1%e4%bc%9a%e7%9c%8b%e5%88%b0%e4%b8%a4%e4%b8%aac%e7%9a%84%e6%96%87%e4%bb%b6%ef%bc%8c%e8%bf%99%e4%b8%a4%e4%b8%aa%e6%96%87%e4%bb%b6%e5%b0%b1%e6%98%af%e4%bb%8a%e5%a4%a9%e8%a6%81%e8%b0%88%e7%9a%84Weex%e7%9a%84%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e%e3%80%82%0aLayout.h%e5%92%8cLayout.c%e6%9c%80%e5%bc%80%e5%a7%8b%e6%98%af%e6%9d%a5%e8%87%aa%e4%ba%8eReact-Native%e9%87%8c%e9%9d%a2%e7%9a%84%e4%bb%a3%e7%a0%81%e3%80%82%e4%b9%9f%e5%b0%b1%e6%98%af%e8%af%b4Weex%e5%92%8cReact-Native%e7%9a%84%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e%e9%83%bd%e6%98%af%e5%90%8c%e4%b8%80%e5%a5%97%e4%bb%a3%e7%a0%81%e3%80%82%0a%e5%bd%93%e5%89%8dReact-Native%e7%9a%84%e4%bb%a3%e7%a0%81%e9%87%8c%e9%9d%a2%e5%b7%b2%e7%bb%8f%e6%b2%a1%e6%9c%89%e8%bf%99%e4%b8%a4%e4%b8%aa%e6%96%87%e4%bb%b6%e4%ba%86%ef%bc%8c%e8%80%8c%e6%98%af%e6%8d%a2%e6%88%90%e4%ba%86Yoga%e3%80%82%0aYoga%e6%9c%ac%e6%98%afFacebook%e5%9c%a8React%20Native%e9%87%8c%e5%bc%95%e5%85%a5%e7%9a%84%e4%b8%80%e7%a7%8d%e8%b7%a8%e5%b9%b3%e5%8f%b0%e7%9a%84%e5%9f%ba%e4%ba%8eCSS%e7%9a%84%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e%ef%bc%8c%e5%ae%83%e5%ae%9e%e7%8e%b0%e4%ba%86Flexbox%e8%a7%84%e8%8c%83%ef%bc%8c%e5%ae%8c%e5%85%a8%e9%81%b5%e5%ae%88W3C%e7%9a%84%e8%a7%84%e8%8c%83%e3%80%82%e9%9a%8f%e7%9d%80%e8%af%a5%e7%b3%bb%e7%bb%9f%e4%b8%8d%e6%96%ad%e5%ae%8c%e5%96%84%ef%bc%8cFacebook%e5%af%b9%e5%85%b6%e8%bf%9b%e8%a1%8c%e9%87%8d%e6%96%b0%e5%8f%91%e5%b8%83%ef%bc%8c%e4%ba%8e%e6%98%af%e5%b0%b1%e6%88%90%e4%ba%86%e7%8e%b0%e5%9c%a8%e7%9a%84Yoga%28Yoga%e5%ae%98%e7%bd%91%29%e3%80%82%0a%e9%82%a3%e4%b9%88Flexbox%e6%98%af%e4%bb%80%e4%b9%88%e5%91%a2%ef%bc%9f%0a%e7%86%9f%e6%82%89%e5%89%8d%e7%ab%af%e7%9a%84%e5%90%8c%e5%ad%a6%e4%b8%80%e5%ae%9a%e5%be%88%e7%86%9f%e6%82%89%e8%bf%99%e4%b8%aa%e6%a6%82%e5%bf%b5%e3%80%822009%e5%b9%b4%ef%bc%8cW3C%e6%8f%90%e5%87%ba%e4%ba%86%e4%b8%80%e7%a7%8d%e6%96%b0%e7%9a%84%e6%96%b9%e6%a1%88%e2%80%94%e2%80%94Flex%e5%b8%83%e5%b1%80%ef%bc%8c%e5%8f%af%e4%bb%a5%e7%ae%80%e4%be%bf%e3%80%81%e5%ae%8c%e6%95%b4%e3%80%81%e5%93%8d%e5%ba%94%e5%bc%8f%e5%9c%b0%e5%ae%9e%e7%8e%b0%e5%90%84%e7%a7%8d%e9%a1%b5%e9%9d%a2%e5%b8%83%e5%b1%80%e3%80%82%e7%9b%ae%e5%89%8d%ef%bc%8c%e5%ae%83%e5%b7%b2%e7%bb%8f%e5%be%97%e5%88%b0%e4%ba%86%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e6%b5%8f%e8%a7%88%e5%99%a8%e7%9a%84%e6%94%af%e6%8c%81%ef%bc%8c%e7%9b%ae%e5%89%8d%e7%9a%84%e5%89%8d%e7%ab%af%e4%b8%bb%e8%a6%81%e6%98%af%e4%bd%bf%e7%94%a8Html%20%2f%20CSS%20%2f%20JS%e5%ae%9e%e7%8e%b0%ef%bc%8c%e5%85%b6%e4%b8%adCSS%e7%94%a8%e4%ba%8e%e5%89%8d%e7%ab%af%e7%9a%84%e5%b8%83%e5%b1%80%e3%80%82%e4%bb%bb%e4%bd%95%e4%b8%80%e4%b8%aaHtml%e7%9a%84%e5%ae%b9%e5%99%a8%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87css%e6%8c%87%e5%ae%9a%e4%b8%baFlex%e5%b8%83%e5%b1%80%ef%bc%8c%e4%b8%80%e6%97%a6%e4%b8%80%e4%b8%aa%e5%ae%b9%e5%99%a8%e8%a2%ab%e6%8c%87%e5%ae%9a%e4%b8%baFlex%e5%b8%83%e5%b1%80%ef%bc%8c%e5%85%b6%e5%ad%90%e5%85%83%e7%b4%a0%e5%b0%b1%e5%8f%af%e4%bb%a5%e6%8c%89%e7%85%a7FlexBox%e7%9a%84%e8%af%ad%e6%b3%95%e8%bf%9b%e8%a1%8c%e5%b8%83%e5%b1%80%e3%80%82%0a%e5%85%b3%e4%ba%8eFlexBox%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9a%e4%b9%89%ef%bc%8c%e6%9b%b4%e5%8a%a0%e8%af%a6%e7%bb%86%e7%9a%84%e6%96%87%e6%a1%a3%e8%af%b4%e6%98%8e%ef%bc%8c%e6%84%9f%e5%85%b4%e8%b6%a3%e7%9a%84%e5%90%8c%e5%ad%a6%e5%8f%af%e4%bb%a5%e5%8e%bb%e9%98%85%e8%af%bb%e4%b8%80%e4%b8%8bW3C%e7%9a%84%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%ef%bc%8c%e9%82%a3%e9%87%8c%e4%bc%9a%e6%9c%89%e5%be%88%e8%af%a6%e7%bb%86%e7%9a%84%e8%af%b4%e6%98%8e%e3%80%82%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%e9%93%be%e6%8e%a5%0aWeex%e4%b8%ad%e7%9a%84Layout%e6%96%87%e4%bb%b6%e6%98%afYoga%e7%9a%84%e5%89%8d%e8%ba%ab%ef%bc%8c%e6%98%afYoga%e6%ad%a3%e5%bc%8f%e5%8f%91%e5%b8%83%e4%b9%8b%e5%89%8d%e7%9a%84%e7%89%88%e6%9c%ac%e3%80%82%e5%ba%95%e5%b1%82%e4%bb%a3%e7%a0%81%e4%bd%bf%e7%94%a8C%e8%af%ad%e8%a8%80%e4%bb%a3%e7%a0%81%ef%bc%8c%e6%89%80%e4%bb%a5%e6%80%a7%e8%83%bd%e4%b9%9f%e4%b8%8d%e6%98%af%e9%97%ae%e9%a2%98%e3%80%82%e6%8e%a5%e4%b8%8b%e6%9d%a5%e5%b0%b1%e4%bb%94%e7%bb%86%e5%88%86%e6%9e%90Layout%e6%96%87%e4%bb%b6%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0FlexBox%e7%9a%84%e3%80%82%0a%e6%95%85%e4%bb%a5%e4%b8%8b%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e9%83%bd%e5%9f%ba%e4%ba%8ev0.10.0%e8%bf%99%e4%b8%aa%e7%89%88%e6%9c%ac%e3%80%82%0a%ef%bc%88%e4%b8%80%ef%bc%89FlexBox%e4%b8%ad%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%20Flexbox%e5%b8%83%e5%b1%80%ef%bc%88Flexible%20Box%29%e8%ae%be%e8%ae%a1%e4%b9%8b%e5%88%9d%e7%9a%84%e7%9b%ae%e7%9a%84%e6%98%af%e4%b8%ba%e4%ba%86%e8%83%bd%e6%9b%b4%e5%8a%a0%e9%ab%98%e6%95%88%e7%9a%84%e5%88%86%e9%85%8d%e5%ad%90%e8%a7%86%e5%9b%be%e7%9a%84%e5%b8%83%e5%b1%80%e6%83%85%e5%86%b5%ef%bc%8c%e5%8c%85%e6%8b%ac%e5%8a%a8%e6%80%81%e7%9a%84%e6%94%b9%e5%8f%98%e5%ae%bd%e5%ba%a6%ef%bc%8c%e9%ab%98%e5%ba%a6%ef%bc%8c%e4%bb%a5%e5%8f%8a%e6%8e%92%e5%88%97%e9%a1%ba%e5%ba%8f%e3%80%82Flexbox%e5%8f%af%e4%bb%a5%e6%9b%b4%e5%8a%a0%e6%96%b9%e4%be%bf%e7%9a%84%e5%85%bc%e5%ae%b9%e5%90%84%e4%b8%aa%e5%a4%a7%e5%b0%8f%e4%b8%8d%e5%90%8c%e7%9a%84%e5%b1%8f%e5%b9%95%ef%bc%8c%e6%af%94%e5%a6%82%e6%8b%89%e4%bc%b8%e5%92%8c%e5%8e%8b%e7%bc%a9%e5%ad%90%e8%a7%86%e5%9b%be%e3%80%82%0a%e5%9c%a8FlexBox%e7%9a%84%e4%b8%96%e7%95%8c%e9%87%8c%ef%bc%8c%e5%ad%98%e5%9c%a8%e7%9d%80%e4%b8%bb%e8%bd%b4%e5%92%8c%e4%be%a7%e8%bd%b4%e7%9a%84%e6%a6%82%e5%bf%b5%e3%80%82%0a%e5%a4%a7%e5%a4%9a%e6%95%b0%e6%83%85%e5%86%b5%ef%bc%8c%e5%ad%90%e8%a7%86%e5%9b%be%e9%83%bd%e6%98%af%e6%b2%bf%e7%9d%80%e4%b8%bb%e8%bd%b4%ef%bc%88main%20axis%ef%bc%89%ef%bc%8c%e4%bb%8e%e4%b8%bb%e8%bd%b4%e8%b5%b7%e7%82%b9%ef%bc%88main-start%ef%bc%89%e5%88%b0%e4%b8%bb%e8%bd%b4%e7%bb%88%e7%82%b9%ef%bc%88main-end%ef%bc%89%e6%8e%92%e5%88%97%e3%80%82%e4%bd%86%e6%98%af%e8%bf%99%e9%87%8c%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e4%b8%80%e7%82%b9%e6%98%af%ef%bc%8c%e4%b8%bb%e8%bd%b4%e5%92%8c%e4%be%a7%e8%bd%b4%e8%99%bd%e7%84%b6%e6%b0%b8%e8%bf%9c%e6%98%af%e5%9e%82%e7%9b%b4%e7%9a%84%e5%85%b3%e7%b3%bb%ef%bc%8c%e4%bd%86%e6%98%af%e8%b0%81%e6%98%af%e6%b0%b4%e5%b9%b3%ef%bc%8c%e8%b0%81%e6%98%af%e7%ab%96%e7%9b%b4%ef%bc%8c%e5%b9%b6%e6%b2%a1%e6%9c%89%e7%a1%ae%e5%ae%9a%ef%bc%8c%e6%9c%89%e5%8f%af%e8%83%bd%e4%bc%9a%e6%9c%89%e5%a6%82%e4%b8%8b%e7%9a%84%e6%83%85%e5%86%b5%ef%bc%9a%0a%e5%9c%a8%e4%b8%8a%e5%9b%be%e8%bf%99%e7%a7%8d%e6%b0%b4%e5%b9%b3%e6%98%af%e4%be%a7%e8%bd%b4%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%ef%bc%8c%e5%ad%90%e8%a7%86%e5%9b%be%e6%98%af%e6%b2%bf%e7%9d%80%e4%be%a7%e8%bd%b4%ef%bc%88cross%20axis%ef%bc%89%ef%bc%8c%e4%bb%8e%e4%be%a7%e8%bd%b4%e8%b5%b7%e7%82%b9%ef%bc%88cross-start%ef%bc%89%e5%88%b0%e4%be%a7%e8%bd%b4%e7%bb%88%e7%82%b9%ef%bc%88cross-end%ef%bc%89%e6%8e%92%e5%88%97%e7%9a%84%e3%80%82%0a%2a%2a%e4%b8%bb%e8%bd%b4%ef%bc%88main%20axis%ef%bc%89%ef%bc%9a%2a%2a%e7%88%b6%e8%a7%86%e5%9b%be%e7%9a%84%e4%b8%bb%e8%bd%b4%ef%bc%8c%e5%ad%90%e8%a7%86%e5%9b%be%e4%b8%bb%e8%a6%81%e6%b2%bf%e7%9d%80%e8%bf%99%e6%9d%a1%e8%bd%b4%e8%bf%9b%e8%a1%8c%e6%8e%92%e5%88%97%e5%b8%83%e5%b1%80%e3%80%82%0a%2a%2a%e4%b8%bb%e8%bd%b4%e8%b5%b7%e7%82%b9%ef%bc%88main-start%ef%bc%89%e5%92%8c%e4%b8%bb%e8%bd%b4%e7%bb%88%e7%82%b9%ef%bc%88main-end%ef%bc%89%ef%bc%9a%2a%2a%e5%ad%90%e8%a7%86%e5%9b%be%e5%9c%a8%e7%88%b6%e8%a7%86%e5%9b%be%e9%87%8c%e9%9d%a2%e5%b8%83%e5%b1%80%e7%9a%84%e6%96%b9%e5%90%91%e6%98%af%e4%bb%8e%e4%b8%bb%e8%bd%b4%e8%b5%b7%e7%82%b9%ef%bc%88main-start%ef%bc%89%e5%90%91%e4%b8%bb%e8%bd%b4%e7%bb%88%e7%82%b9%ef%bc%88main-start%ef%bc%89%e7%9a%84%e6%96%b9%e5%90%91%e3%80%82%0a%2a%2a%e4%b8%bb%e8%bd%b4%e5%b0%ba%e5%af%b8%ef%bc%88main%20size%ef%bc%89%ef%bc%9a%2a%2a%e5%ad%90%e8%a7%86%e5%9b%be%e5%9c%a8%e4%b8%bb%e8%bd%b4%e6%96%b9%e5%90%91%e7%9a%84%e5%ae%bd%e5%ba%a6%e6%88%96%e9%ab%98%e5%ba%a6%e5%b0%b1%e6%98%af%e4%b8%bb%e8%bd%b4%e7%9a%84%e5%b0%ba%e5%af%b8%e3%80%82%e5%ad%90%e8%a7%86%e5%9b%be%e4%b8%bb%e8%a6%81%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%b1%9e%e6%80%a7%e8%a6%81%e4%b9%88%e6%98%af%e5%ae%bd%e5%ba%a6%ef%bc%8c%e8%a6%81%e4%b9%88%e6%98%af%e9%ab%98%e5%ba%a6%e5%b1%9e%e6%80%a7%ef%bc%8c%e7%94%b1%e5%93%aa%e4%b8%80%e4%b8%aa%e5%af%b9%e7%9d%80%e4%b8%bb%e8%bd%b4%e6%96%b9%e5%90%91%e5%86%b3%e5%ae%9a%e3%80%82%0a%2a%2a%e4%be%a7%e8%bd%b4%ef%bc%88cross%20axis%ef%bc%89%ef%bc%9a%2a%2a%e5%9e%82%e7%9b%b4%e4%ba%8e%e4%b8%bb%e8%bd%b4%e7%a7%b0%e4%b8%ba%e4%be%a7%e8%bd%b4%e3%80%82%e5%ae%83%e7%9a%84%e6%96%b9%e5%90%91%e4%b8%bb%e8%a6%81%e5%8f%96%e5%86%b3%e4%ba%8e%e4%b8%bb%e8%bd%b4%e6%96%b9%e5%90%91%e3%80%82%0a%2a%2a%e4%be%a7%e8%bd%b4%e8%b5%b7%e7%82%b9%ef%bc%88cross-start%ef%bc%89%e5%92%8c%e4%be%a7%e8%bd%b4%e7%bb%88%e7%82%b9%ef%bc%88cross-end%ef%bc%89%ef%bc%9a%2a%2a%e5%ad%90%e8%a7%86%e5%9b%be%e8%a1%8c%e7%9a%84%e9%85%8d%e7%bd%ae%e4%bb%8e%e5%ae%b9%e5%99%a8%e7%9a%84%e4%be%a7%e8%bd%b4%e8%b5%b7%e7%82%b9%e8%be%b9%e5%bc%80%e5%a7%8b%ef%bc%8c%e5%be%80%e4%be%a7%e8%bd%b4%e7%bb%88%e7%82%b9%e8%be%b9%e7%bb%93%e6%9d%9f%e3%80%82%0a%2a%2a%e4%be%a7%e8%bd%b4%e5%b0%ba%e5%af%b8%ef%bc%88cross%20size%ef%bc%89%ef%bc%9a%2a%2a%e5%ad%90%e8%a7%86%e5%9b%be%e7%9a%84%e5%9c%a8%e4%be%a7%e8%bd%b4%e6%96%b9%e5%90%91%e7%9a%84%e5%ae%bd%e5%ba%a6%e6%88%96%e9%ab%98%e5%ba%a6%e5%b0%b1%e6%98%af%e9%a1%b9%e7%9b%ae%e7%9a%84%e4%be%a7%e8%bd%b4%e9%95%bf%e5%ba%a6%ef%bc%8c%e4%bc%b8%e7%bc%a9%e9%a1%b9%e7%9b%ae%e7%9a%84%e4%be%a7%e8%bd%b4%e9%95%bf%e5%ba%a6%e5%b1%9e%e6%80%a7%e6%98%af%e3%80%8cwidth%e3%80%8d%e6%88%96%e3%80%8cheight%e3%80%8d%e5%b1%9e%e6%80%a7%ef%bc%8c%e7%94%b1%e5%93%aa%e4%b8%80%e4%b8%aa%e5%af%b9%e7%9d%80%e4%be%a7%e8%bd%b4%e6%96%b9%e5%90%91%e5%86%b3%e5%ae%9a%e3%80%82%0a%e6%8e%a5%e4%b8%8b%e6%9d%a5%e7%9c%8b%e7%9c%8bLayout%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9a%e4%b9%89FlexBox%e9%87%8c%e9%9d%a2%e7%9a%84%e5%85%83%e7%b4%a0%e7%9a%84%e3%80%82%0atypedef%20enum%20%7b%20CSS_DIRECTION_INHERIT%20%3d%200%2c%20CSS_DIRECTION_LTR%2c%20CSS_DIRECTION_RTL%20%7d%20css_direction_t%3b%20%e8%bf%99%e4%b8%aa%e6%96%b9%e5%90%91%e6%98%af%e5%ae%9a%e4%b9%89%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e7%9a%84%e6%95%b4%e4%bd%93%e5%b8%83%e5%b1%80%e7%9a%84%e6%96%b9%e5%90%91%ef%bc%8cINHERIT%e6%98%af%e7%bb%a7%e6%89%bf%ef%bc%8cLTR%e6%98%afLeft%20To%20Right%ef%bc%8c%e4%bb%8e%e5%b7%a6%e5%88%b0%e5%8f%b3%e5%b8%83%e5%b1%80%e3%80%82RTL%e6%98%afRight%20To%20Left%ef%bc%8c%e4%bb%8e%e5%8f%b3%e5%88%b0%e5%b7%a6%e5%b8%83%e5%b1%80%e3%80%82%e4%b8%8b%e9%9d%a2%e5%88%86%e6%9e%90%e5%a6%82%e6%9e%9c%e4%b8%8d%e5%81%9a%e7%89%b9%e6%ae%8a%e8%af%b4%e6%98%8e%ef%bc%8c%e9%83%bd%e6%98%afLTR%e4%bb%8e%e5%b7%a6%e5%90%91%e5%8f%b3%e5%b8%83%e5%b1%80%e3%80%82%e5%a6%82%e6%9e%9c%e6%98%afRTL%e5%b0%b1%e6%98%afLTR%e5%8f%8d%e5%90%91%e3%80%82%0atypedef%20enum%20%7b%20CSS_FLEX_DIRECTION_COLUMN%20%3d%200%2c%20CSS_FLEX_DIRECTION_COLUMN_REVERSE%2c%20CSS_FLEX_DIRECTION_ROW%2c%20CSS_FLEX_DIRECTION_ROW_REVERSE%20%7d%20css_flex_direction_t%3b%20%e8%bf%99%e9%87%8c%e5%ae%9a%e4%b9%89%e7%9a%84%e6%98%afFlex%e7%9a%84%e6%96%b9%e5%90%91%e3%80%82"><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&t=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div><div id=toc><nav id=TableOfContents><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#目录>目录</a></li><li><a href=#一-weex布局算法>一. Weex布局算法</a><ul><li><a href=#一flexbox中的基本数据结构>（一）FlexBox中的基本数据结构</a></li><li><a href=#1align_items>1.align_items</a></li><li><a href=#2-align_content>2. align_content</a></li><li><a href=#3align_self>3.align_self</a></li><li><a href=#二flexbox中的布局算法>（二）FlexBox中的布局算法</a></li></ul></li><li><a href=#二-weex布局算法性能分析>二. Weex布局算法性能分析</a><ul><li><a href=#1算法实现分析>1.算法实现分析</a></li><li><a href=#2算法性能测试准备工作>2.算法性能测试准备工作</a></li><li><a href=#3算法性能测试结果>3.算法性能测试结果</a></li></ul></li><li><a href=#三-weex是如何布局原生界面的>三. Weex是如何布局原生界面的</a><ul><li><a href=#1创建wxcomponent>1.创建WXComponent</a></li><li><a href=#2初始化css_node_t>2.初始化css_node_t</a></li><li><a href=#3添加ui任务到uitaskqueue数组中>3.添加UI任务到uiTaskQueue数组中</a></li><li><a href=#三createfinish>（三）createFinish</a></li></ul></li><li><a href=#最后>最后</a></li></ul></li></ul></nav></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">由 FlexBox 算法强力驱动的 Weex 布局引擎</h1><div class=meta><div class=postdate><time datetime="2017-03-31 08:26:00 +0000 UTC" itemprop=datePublished>Mar 31</time></div><div class=article-category><i class="fas fa-archive"></i><a class=category-link href=/categories/ios>iOS</a>
,
<a class=category-link href=/categories/weex>Weex</a></div><div class=article-tag><i class="fas fa-tag"></i><a class=tag-link href=/tags/ios rel=tag>iOS</a>
,
<a class=tag-link href=/tags/weex rel=tag>Weex</a></div></div></header><div class=content itemprop=articleBody><h3 id=前言>前言</h3><p>在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局原生界面的，之后还会与现有的布局方法进行对比，看看Weex的布局性能究竟如何。</p><h3 id=目录>目录</h3><ul><li>1.Weex布局算法</li><li>2.Weex布局算法性能分析</li><li>3.Weex是如何布局原生界面的</li></ul><h3 id=一-weex布局算法>一. Weex布局算法</h3><p>打开Weex的源码的Layout文件夹，就会看到两个c的文件，这两个文件就是今天要谈的Weex的布局引擎。</p><p>Layout.h和Layout.c最开始是来自于React-Native里面的代码。也就是说Weex和React-Native的布局引擎都是同一套代码。</p><p>当前React-Native的代码里面已经没有这两个文件了，而是换成了Yoga。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_1.png alt></p><p>Yoga本是Facebook在React Native里引入的一种跨平台的基于CSS的布局引擎，它实现了Flexbox规范，完全遵守W3C的规范。随着该系统不断完善，Facebook对其进行重新发布，于是就成了现在的Yoga(<a href=https://facebook.github.io/yoga/>Yoga官网</a>)。</p><p>那么Flexbox是什么呢？</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_2.png alt></p><p>熟悉前端的同学一定很熟悉这个概念。2009年，W3C提出了一种新的方案——Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了几乎所有浏览器的支持，目前的前端主要是使用Html / CSS / JS实现，其中CSS用于前端的布局。任何一个Html的容器可以通过css指定为Flex布局，一旦一个容器被指定为Flex布局，其子元素就可以按照FlexBox的语法进行布局。</p><p>关于FlexBox的基本定义，更加详细的文档说明，感兴趣的同学可以去阅读一下W3C的官方文档，那里会有很详细的说明。<a href=https://www.w3.org/TR/css-flexbox-1/>官方文档链接</a></p><p>Weex中的Layout文件是Yoga的前身，是Yoga正式发布之前的版本。底层代码使用C语言代码，所以性能也不是问题。接下来就仔细分析Layout文件是如何实现FlexBox的。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_3.jpg alt></p><p>故以下源码分析都基于v0.10.0这个版本。</p><h4 id=一flexbox中的基本数据结构>（一）FlexBox中的基本数据结构</h4><p>Flexbox布局（Flexible Box)设计之初的目的是为了能更加高效的分配子视图的布局情况，包括动态的改变宽度，高度，以及排列顺序。Flexbox可以更加方便的兼容各个大小不同的屏幕，比如拉伸和压缩子视图。</p><p>在FlexBox的世界里，存在着主轴和侧轴的概念。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_4.png alt></p><p>大多数情况，子视图都是沿着主轴（main axis），从主轴起点（main-start）到主轴终点（main-end）排列。但是这里需要注意的一点是，主轴和侧轴虽然永远是垂直的关系，但是谁是水平，谁是竖直，并没有确定，有可能会有如下的情况：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_5.png alt></p><p>在上图这种水平是侧轴的情况下，子视图是沿着侧轴（cross axis），从侧轴起点（cross-start）到侧轴终点（cross-end）排列的。</p><p>**主轴（main axis）：**父视图的主轴，子视图主要沿着这条轴进行排列布局。</p><p>**主轴起点（main-start）和主轴终点（main-end）：**子视图在父视图里面布局的方向是从主轴起点（main-start）向主轴终点（main-start）的方向。</p><p>**主轴尺寸（main size）：**子视图在主轴方向的宽度或高度就是主轴的尺寸。子视图主要的大小属性要么是宽度，要么是高度属性，由哪一个对着主轴方向决定。</p><p>**侧轴（cross axis）：**垂直于主轴称为侧轴。它的方向主要取决于主轴方向。</p><p>**侧轴起点（cross-start）和侧轴终点（cross-end）：**子视图行的配置从容器的侧轴起点边开始，往侧轴终点边结束。</p><p>**侧轴尺寸（cross size）：**子视图的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是「width」或「height」属性，由哪一个对着侧轴方向决定。</p><p>接下来看看Layout是怎么定义FlexBox里面的元素的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {
  CSS_DIRECTION_INHERIT <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
  CSS_DIRECTION_LTR,
  CSS_DIRECTION_RTL
} css_direction_t;


</code></pre></div><p>这个方向是定义的上下文的整体布局的方向，INHERIT是继承，LTR是Left To Right，从左到右布局。RTL是Right To Left，从右到左布局。下面分析如果不做特殊说明，都是LTR从左向右布局。如果是RTL就是LTR反向。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {
  CSS_FLEX_DIRECTION_COLUMN <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
  CSS_FLEX_DIRECTION_COLUMN_REVERSE,
  CSS_FLEX_DIRECTION_ROW,
  CSS_FLEX_DIRECTION_ROW_REVERSE
} css_flex_direction_t;



</code></pre></div><p>这里定义的是Flex的方向。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_6.png alt></p><p>上图是COLUMN。布局的走向是从上往下。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_7.png alt></p><p>上图是COLUMN_REVERSE。布局的走向是从下往上。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_8.png alt></p><p>上图是ROW。布局的走向是从左往右。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_9.png alt></p><p>上图是ROW_REVERSE。布局的走向是从右往左。</p><p>这里可以看出来，在LTR的上下文中，ROW_REVERSE即等于RTL的上下文中的ROW。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {
  CSS_JUSTIFY_FLEX_START <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
  CSS_JUSTIFY_CENTER,
  CSS_JUSTIFY_FLEX_END,
  CSS_JUSTIFY_SPACE_BETWEEN,
  CSS_JUSTIFY_SPACE_AROUND
} css_justify_t;


</code></pre></div><p>这是定义的子视图在主轴上的排列方式。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_10.png alt></p><p>上图是JUSTIFY_FLEX_START</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_11.png alt></p><p>上图是JUSTIFY_CENTER</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_12.png alt></p><p>上图是JUSTIFY_FLEX_END</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_13.png alt></p><p>上图是JUSTIFY_SPACE_BETWEEN</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_14.png alt></p><p>上图是JUSTIFY_SPACE_AROUND。这种方式是每个视图的左右都保持着一定的宽度。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {
  CSS_ALIGN_AUTO <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
  CSS_ALIGN_FLEX_START,
  CSS_ALIGN_CENTER,
  CSS_ALIGN_FLEX_END,
  CSS_ALIGN_STRETCH
} css_align_t;

</code></pre></div><p>这是定义的子视图在侧轴上的对齐方式。</p><p>在Weex这里定义了三种属于css_align_t类型的方式，align_content，align_items，align_self。这三种类型的对齐方式略有不同。</p><p>ALIGN_AUTO只是针对align_self的一个默认值，但是对于align_content，align_items子视图的对齐方式是无效的值。</p><h4 id=1align_items>1.align_items</h4><p>align_items定义的是子视图在一行里面侧轴上排列的方式。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_15.png alt></p><p>上图是ALIGN_FLEX_START</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_16.png alt></p><p>上图是ALIGN_CENTER</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_17.png alt></p><p>上图是ALIGN_FLEX_END</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_18.png alt></p><p>上图是ALIGN_STRETCH</p><p>align_items在W3C的定义里面其实还有一个种baseline的对齐方式，这里在定义里面并没有。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_19.png alt></p><p>注意，上面这种baseline的对齐方式在Weex的定义里面并没有！</p><h4 id=2-align_content>2. align_content</h4><p>align_content定义的是子视图行与行之间在侧轴上排列的方式。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_20.png alt></p><p>上图是ALIGN_FLEX_START</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_21.png alt></p><p>上图是ALIGN_CENTER</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_22.png alt></p><p>上图是ALIGN_FLEX_END</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_23.png alt></p><p>上图是ALIGN_STRETCH</p><p>在FlexBox的W3C的定义里面其实还有两种方式在Weex没有定义。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_24.png alt></p><p>上图的这种对齐方式是对应的justify里面的JUSTIFY_SPACE_AROUND，align-content里面的space-around这种对齐方式在Weex是没有的。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_25.png alt></p><p>上图的这种对齐方式是对应的justify里面的JUSTIFY_SPACE_BETWEEN，align-content里面的space-between这种对齐方式在Weex是没有的。</p><h4 id=3align_self>3.align_self</h4><p>最后这一种对齐方式是可以在align_items的基础上再分别自定义每个子视图的对齐方式。如果是auto，是与align_items方式相同。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_26.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {
  CSS_POSITION_RELATIVE <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
  CSS_POSITION_ABSOLUTE
} css_position_type_t;


</code></pre></div><p>这个是定义坐标地址的类型，有相对坐标和绝对坐标两种。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {
  CSS_NOWRAP <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
  CSS_WRAP
} css_wrap_type_t;


</code></pre></div><p>在Weex里面wrap只有两种类型。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_27.png alt></p><p>上图是NOWRAP。所有的子视图都会排列在一行之中。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_28.png alt></p><p>上图是WRAP。所有的子视图会从左到右，从上到下排列。</p><p>在W3C的标准里面还有一种wrap_reverse的排列方式。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_29.png alt></p><p>这种排列方式，是从左到右，从下到上进行排列，目前在Weex里面没有定义。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {
  CSS_LEFT <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
  CSS_TOP,
  CSS_RIGHT,
  CSS_BOTTOM,
  CSS_START,
  CSS_END,
  CSS_POSITION_COUNT
} css_position_t;

</code></pre></div><p>这里定义的是坐标的描述。Left和Top因为会出现在position[2] 和 position[4]中，所以它们两个排列在Right和Bottom前面。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {
  CSS_MEASURE_MODE_UNDEFINED <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
  CSS_MEASURE_MODE_EXACTLY,
  CSS_MEASURE_MODE_AT_MOST
} css_measure_mode_t;

</code></pre></div><p>这里定义的是计算的方式，一种是精确计算，另外一种是估算近视值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {
  CSS_WIDTH <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
  CSS_HEIGHT
} css_dimension_t;

</code></pre></div><p>这里定义的是子视图的尺寸，宽和高。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#66d9ef>float</span> position[<span style=color:#ae81ff>4</span>];
  <span style=color:#66d9ef>float</span> dimensions[<span style=color:#ae81ff>2</span>];
  css_direction_t direction;

  <span style=color:#75715e>// 缓存一些信息防止每次Layout过程都要重复计算
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>bool</span> should_update;
  <span style=color:#66d9ef>float</span> last_requested_dimensions[<span style=color:#ae81ff>2</span>];
  <span style=color:#66d9ef>float</span> last_parent_max_width;
  <span style=color:#66d9ef>float</span> last_parent_max_height;
  <span style=color:#66d9ef>float</span> last_dimensions[<span style=color:#ae81ff>2</span>];
  <span style=color:#66d9ef>float</span> last_position[<span style=color:#ae81ff>2</span>];
  css_direction_t last_direction;
} css_layout_t;

</code></pre></div><p>这里定义了一个css_layout_t结构体。结构体里面position和dimensions数组里面分别存储的是四周的位置和宽高的尺寸。direction里面存储的就是LTR还是RTL的方向。</p><p>至于下面那些变量信息都是缓存，用来防止没有改变的Lauout还会重复计算的问题。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#66d9ef>float</span> dimensions[<span style=color:#ae81ff>2</span>];
} css_dim_t;

</code></pre></div><p>css_dim_t结构体里面装的就是子视图的尺寸信息，宽和高。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#75715e>// 整个页面CSS的方向，LTR、RTL
</span><span style=color:#75715e></span>  css_direction_t direction;
  <span style=color:#75715e>// Flex 的方向
</span><span style=color:#75715e></span>  css_flex_direction_t flex_direction;
  <span style=color:#75715e>// 子视图在主轴上的排列对齐方式
</span><span style=color:#75715e></span>  css_justify_t justify_content;
  <span style=color:#75715e>// 子视图在侧轴上行与行之间的对齐方式
</span><span style=color:#75715e></span>  css_align_t align_content;
  <span style=color:#75715e>// 子视图在侧轴上的对齐方式
</span><span style=color:#75715e></span>  css_align_t align_items;
  <span style=color:#75715e>// 子视图自己本身的对齐方式
</span><span style=color:#75715e></span>  css_align_t align_self;
  <span style=color:#75715e>// 子视图的坐标系类型(相对坐标系，绝对坐标系)
</span><span style=color:#75715e></span>  css_position_type_t position_type;
  <span style=color:#75715e>// wrap类型
</span><span style=color:#75715e></span>  css_wrap_type_t flex_wrap;
  <span style=color:#66d9ef>float</span> flex;
  <span style=color:#75715e>// 上，下，左，右，start，end
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>float</span> margin[<span style=color:#ae81ff>6</span>];
  <span style=color:#75715e>// 上，下，左，右
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>float</span> position[<span style=color:#ae81ff>4</span>];
  <span style=color:#75715e>// 上，下，左，右，start，end
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>float</span> padding[<span style=color:#ae81ff>6</span>];
  <span style=color:#75715e>// 上，下，左，右，start，end
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>float</span> border[<span style=color:#ae81ff>6</span>];
  <span style=color:#75715e>// 宽，高
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>float</span> dimensions[<span style=color:#ae81ff>2</span>];
  <span style=color:#75715e>// 最小的宽和高
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>float</span> minDimensions[<span style=color:#ae81ff>2</span>];
  <span style=color:#75715e>// 最大的宽和高
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>float</span> maxDimensions[<span style=color:#ae81ff>2</span>];
} css_style_t;


</code></pre></div><p>css_style_t记录了整个style的所有信息。每个变量的意义见上面注释。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> css_node css_node_t;
<span style=color:#66d9ef>struct</span> css_node {
  css_style_t style;
  css_layout_t layout;
  <span style=color:#66d9ef>int</span> children_count;
  <span style=color:#66d9ef>int</span> line_index;

  css_node_t <span style=color:#f92672>*</span>next_absolute_child;
  css_node_t <span style=color:#f92672>*</span>next_flex_child;

  css_dim_t (<span style=color:#f92672>*</span>measure)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context, <span style=color:#66d9ef>float</span> width, css_measure_mode_t widthMode, <span style=color:#66d9ef>float</span> height, css_measure_mode_t heightMode);
  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>print)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context);
  <span style=color:#66d9ef>struct</span> css_node<span style=color:#f92672>*</span> (<span style=color:#f92672>*</span>get_child)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context, <span style=color:#66d9ef>int</span> i);
  <span style=color:#66d9ef>bool</span> (<span style=color:#f92672>*</span>is_dirty)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context);
  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context;
};


</code></pre></div><p>css_node定义的是FlexBox的一个节点的数据结构。它包含了之前的css_style_t和css_layout_t。由于结构体里面无法定义成员函数，所以下面包含4个函数指针。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_30.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
css_node_t <span style=color:#f92672>*</span><span style=color:#a6e22e>new_css_node</span>(<span style=color:#66d9ef>void</span>);
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_css_node</span>(css_node_t <span style=color:#f92672>*</span>node);
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>free_css_node</span>(css_node_t <span style=color:#f92672>*</span>node);

</code></pre></div><p>上面3个函数是关于css_node的生命周期相关的函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#75715e>// 新建节点
</span><span style=color:#75715e></span>css_node_t <span style=color:#f92672>*</span><span style=color:#a6e22e>new_css_node</span>() {
  css_node_t <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> (css_node_t <span style=color:#f92672>*</span>)calloc(<span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>node));
  init_css_node(node);
  <span style=color:#66d9ef>return</span> node;
}

<span style=color:#75715e>// 释放节点
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>free_css_node</span>(css_node_t <span style=color:#f92672>*</span>node) {
  free(node);
}


</code></pre></div><p>新建节点的时候就是调用的init_css_node方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_css_node</span>(css_node_t <span style=color:#f92672>*</span>node) {
  node<span style=color:#f92672>-&gt;</span>style.align_items <span style=color:#f92672>=</span> CSS_ALIGN_STRETCH;
  node<span style=color:#f92672>-&gt;</span>style.align_content <span style=color:#f92672>=</span> CSS_ALIGN_FLEX_START;

  node<span style=color:#f92672>-&gt;</span>style.direction <span style=color:#f92672>=</span> CSS_DIRECTION_INHERIT;
  node<span style=color:#f92672>-&gt;</span>style.flex_direction <span style=color:#f92672>=</span> CSS_FLEX_DIRECTION_COLUMN;

  <span style=color:#75715e>// 注意下面这些数组里面的值初始化为undefined，而不是0
</span><span style=color:#75715e></span>  node<span style=color:#f92672>-&gt;</span>style.dimensions[CSS_WIDTH] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>style.dimensions[CSS_HEIGHT] <span style=color:#f92672>=</span> CSS_UNDEFINED;

  node<span style=color:#f92672>-&gt;</span>style.minDimensions[CSS_WIDTH] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>style.minDimensions[CSS_HEIGHT] <span style=color:#f92672>=</span> CSS_UNDEFINED;

  node<span style=color:#f92672>-&gt;</span>style.maxDimensions[CSS_WIDTH] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>style.maxDimensions[CSS_HEIGHT] <span style=color:#f92672>=</span> CSS_UNDEFINED;

  node<span style=color:#f92672>-&gt;</span>style.position[CSS_LEFT] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>style.position[CSS_TOP] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>style.position[CSS_RIGHT] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>style.position[CSS_BOTTOM] <span style=color:#f92672>=</span> CSS_UNDEFINED;

  node<span style=color:#f92672>-&gt;</span>style.margin[CSS_START] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>style.margin[CSS_END] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>style.padding[CSS_START] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>style.padding[CSS_END] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>style.border[CSS_START] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>style.border[CSS_END] <span style=color:#f92672>=</span> CSS_UNDEFINED;

  node<span style=color:#f92672>-&gt;</span>layout.dimensions[CSS_WIDTH] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>layout.dimensions[CSS_HEIGHT] <span style=color:#f92672>=</span> CSS_UNDEFINED;

  <span style=color:#75715e>// 以下这些用来对比是否发生变化的缓存变量，初始值都为 -1。
</span><span style=color:#75715e></span>  node<span style=color:#f92672>-&gt;</span>layout.last_requested_dimensions[CSS_WIDTH] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
  node<span style=color:#f92672>-&gt;</span>layout.last_requested_dimensions[CSS_HEIGHT] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
  node<span style=color:#f92672>-&gt;</span>layout.last_parent_max_width <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
  node<span style=color:#f92672>-&gt;</span>layout.last_parent_max_height <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
  node<span style=color:#f92672>-&gt;</span>layout.last_direction <span style=color:#f92672>=</span> (css_direction_t)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
  node<span style=color:#f92672>-&gt;</span>layout.should_update <span style=color:#f92672>=</span> true;
}


</code></pre></div><p>css_node的初始化的align_items是ALIGN_STRETCH，align_content是ALIGN_FLEX_START，direction是继承自父类，flex_direction是按照列排列的。</p><p>接着下面数组里面存的都是UNDEFINED，而不是0，因为0会和结构体里面的0冲突。</p><p>最后缓存的变量初始化都为-1。</p><p>接下来定义了4个全局的数组，这4个数组非常有用，它会决定接下来layout的方向和属性。4个数组和轴的方向是相互关联的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>static</span> css_position_t leading[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_TOP,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_BOTTOM,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_LEFT,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_RIGHT
};

</code></pre></div><p>如果主轴在COLUMN垂直方向，那么子视图的leading就是CSS_TOP，方向如果是COLUMN_REVERSE，那么子视图的leading就是CSS_BOTTOM；如果主轴在ROW水平方向，那么子视图的leading就是CSS_LEFT，方向如果是ROW_REVERSE，那么子视图的leading就是CSS_RIGHT。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>static</span> css_position_t trailing[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_BOTTOM,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_TOP,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_RIGHT,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_LEFT
};

</code></pre></div><p>如果主轴在COLUMN垂直方向，那么子视图的trailing就是CSS_BOTTOM，方向如果是COLUMN_REVERSE，那么子视图的trailing就是CSS_TOP；如果主轴在ROW水平方向，那么子视图的trailing就是CSS_RIGHT，方向如果是ROW_REVERSE，那么子视图的trailing就是CSS_LEFT。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>static</span> css_position_t pos[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_TOP,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_BOTTOM,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_LEFT,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_RIGHT
};

</code></pre></div><p>如果主轴在COLUMN垂直方向，那么子视图的position就是以CSS_TOP开始的，方向如果是COLUMN_REVERSE，那么子视图的position就是以CSS_BOTTOM开始的；如果主轴在ROW水平方向，那么子视图的position就是以CSS_LEFT开始的，方向如果是ROW_REVERSE，那么子视图的position就是以CSS_RIGHT开始的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>static</span> css_dimension_t dim[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_HEIGHT,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_HEIGHT,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_WIDTH,
  <span style=color:#75715e>/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_WIDTH
};


</code></pre></div><p>如果主轴在COLUMN垂直方向，那么子视图在这个方向上的尺寸就是CSS_HEIGHT，方向如果是COLUMN_REVERSE，那么子视图在这个方向上的尺寸也是CSS_HEIGHT；如果主轴在ROW水平方向，那么子视图在这个方向上的尺寸就是CSS_WIDTH，方向如果是ROW_REVERSE，那么子视图在这个方向上的尺寸是CSS_WIDTH。</p><h4 id=二flexbox中的布局算法>（二）FlexBox中的布局算法</h4><p>Weex 盒模型基于 <a href=https://www.w3.org/TR/css3-box/>CSS 盒模型</a>，每个 Weex 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。</p><p>盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_31.png alt></p><p>盒子模型如上，这个图是基于LTR，并且主轴在水平方向的。</p><p>所以主轴在不同方向可能就会有不同的情况。</p><blockquote><p>注意：
Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容content、内边距padding和边框的宽度border，不包含外边距的宽度margin。</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#75715e>// 判断轴是否是水平方向
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isRowDirection</span>(css_flex_direction_t flex_direction) {
  <span style=color:#66d9ef>return</span> flex_direction <span style=color:#f92672>==</span> CSS_FLEX_DIRECTION_ROW <span style=color:#f92672>||</span>
         flex_direction <span style=color:#f92672>==</span> CSS_FLEX_DIRECTION_ROW_REVERSE;
}

<span style=color:#75715e>// 判断轴是否是垂直方向
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isColumnDirection</span>(css_flex_direction_t flex_direction) {
  <span style=color:#66d9ef>return</span> flex_direction <span style=color:#f92672>==</span> CSS_FLEX_DIRECTION_COLUMN <span style=color:#f92672>||</span>
         flex_direction <span style=color:#f92672>==</span> CSS_FLEX_DIRECTION_COLUMN_REVERSE;
}

</code></pre></div><p>判断轴的方向的方向就是上面这两个。</p><p>然后接着还要计算4个方向上的padding、border、margin。这里就举一个方向的例子。</p><p>首先如何计算Margin的呢？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>getLeadingMargin</span>(css_node_t <span style=color:#f92672>*</span>node, css_flex_direction_t axis) {
  <span style=color:#66d9ef>if</span> (isRowDirection(axis) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>isUndefined(node<span style=color:#f92672>-&gt;</span>style.margin[CSS_START])) {
    <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>style.margin[CSS_START];
  }
  <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>style.margin[leading[axis]];
}


</code></pre></div><p>判断轴的方向是不是水平方向，如果是水平方向就直接取node的margin里面的CSS_START即是LeadingMargin，如果是竖直方向，就取出在竖直轴上面的leading方向的margin的值。</p><p>如果取TrailingMargin那么就取margin[CSS_END]。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>getTrailingMargin</span>(css_node_t <span style=color:#f92672>*</span>node, css_flex_direction_t axis) {
  <span style=color:#66d9ef>if</span> (isRowDirection(axis) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>isUndefined(node<span style=color:#f92672>-&gt;</span>style.margin[CSS_END])) {
    <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>style.margin[CSS_END];
  }

  <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>style.margin[trailing[axis]];
}


</code></pre></div><p>以下padding、border、margin三个值的数组存储有6个值，如果是水平方向，那么CSS_START存储的都是Leading，CSS_END存储的都是Trailing。下面没有特殊说明，都按照这个规则来。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>getLeadingPadding</span>(css_node_t <span style=color:#f92672>*</span>node, css_flex_direction_t axis) {
  <span style=color:#66d9ef>if</span> (isRowDirection(axis) <span style=color:#f92672>&amp;&amp;</span>
      <span style=color:#f92672>!</span>isUndefined(node<span style=color:#f92672>-&gt;</span>style.padding[CSS_START]) <span style=color:#f92672>&amp;&amp;</span>
      node<span style=color:#f92672>-&gt;</span>style.padding[CSS_START] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
    <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>style.padding[CSS_START];
  }

  <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>style.padding[leading[axis]] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
    <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>style.padding[leading[axis]];
  }

  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}


</code></pre></div><p>取Padding的思路也和取Margin的思路一样，水平方向就是取出数组里面的padding[CSS_START]，如果是竖直方向，就对应得取出padding[leading[axis]]的值即可。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>getLeadingBorder</span>(css_node_t <span style=color:#f92672>*</span>node, css_flex_direction_t axis) {
  <span style=color:#66d9ef>if</span> (isRowDirection(axis) <span style=color:#f92672>&amp;&amp;</span>
      <span style=color:#f92672>!</span>isUndefined(node<span style=color:#f92672>-&gt;</span>style.border[CSS_START]) <span style=color:#f92672>&amp;&amp;</span>
      node<span style=color:#f92672>-&gt;</span>style.border[CSS_START] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
    <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>style.border[CSS_START];
  }

  <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>style.border[leading[axis]] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
    <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>style.border[leading[axis]];
  }

  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}


</code></pre></div><p>最后这是Border的计算方法，和上述Padding，Margin一模一样，这里就不再赘述了。</p><p>四周边距的计算方法都实现了，接下来就是如何layout了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#75715e>// 计算布局的方法
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>layoutNode</span>(css_node_t <span style=color:#f92672>*</span>node, <span style=color:#66d9ef>float</span> maxWidth, <span style=color:#66d9ef>float</span> maxHeight, css_direction_t parentDirection);

<span style=color:#75715e>// 在调用layoutNode之前，可以重置node节点的layout
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>resetNodeLayout</span>(css_node_t <span style=color:#f92672>*</span>node);

</code></pre></div><p>重置node节点的方法就是把节点的坐标重置为0，然后把宽和高都重置为UNDEFINED。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>resetNodeLayout</span>(css_node_t <span style=color:#f92672>*</span>node) {
  node<span style=color:#f92672>-&gt;</span>layout.dimensions[CSS_WIDTH] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>layout.dimensions[CSS_HEIGHT] <span style=color:#f92672>=</span> CSS_UNDEFINED;
  node<span style=color:#f92672>-&gt;</span>layout.position[CSS_LEFT] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  node<span style=color:#f92672>-&gt;</span>layout.position[CSS_TOP] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
}


</code></pre></div><p>最后，布局方法就是如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>layoutNode</span>(css_node_t <span style=color:#f92672>*</span>node, <span style=color:#66d9ef>float</span> parentMaxWidth, <span style=color:#66d9ef>float</span> parentMaxHeight, css_direction_t parentDirection) {
  css_layout_t <span style=color:#f92672>*</span>layout <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>node<span style=color:#f92672>-&gt;</span>layout;
  css_direction_t direction <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>style.direction;
  layout<span style=color:#f92672>-&gt;</span>should_update <span style=color:#f92672>=</span> true;

  <span style=color:#75715e>// 对比当前环境是否“干净”，以及比较待布局的node节点和上次节点是否完全一致。
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>bool</span> skipLayout <span style=color:#f92672>=</span>
    <span style=color:#f92672>!</span>node<span style=color:#f92672>-&gt;</span>is_dirty(node<span style=color:#f92672>-&gt;</span>context) <span style=color:#f92672>&amp;&amp;</span>
    eq(layout<span style=color:#f92672>-&gt;</span>last_requested_dimensions[CSS_WIDTH], layout<span style=color:#f92672>-&gt;</span>dimensions[CSS_WIDTH]) <span style=color:#f92672>&amp;&amp;</span>
    eq(layout<span style=color:#f92672>-&gt;</span>last_requested_dimensions[CSS_HEIGHT], layout<span style=color:#f92672>-&gt;</span>dimensions[CSS_HEIGHT]) <span style=color:#f92672>&amp;&amp;</span>
    eq(layout<span style=color:#f92672>-&gt;</span>last_parent_max_width, parentMaxWidth) <span style=color:#f92672>&amp;&amp;</span>
    eq(layout<span style=color:#f92672>-&gt;</span>last_parent_max_height, parentMaxHeight) <span style=color:#f92672>&amp;&amp;</span>
    eq(layout<span style=color:#f92672>-&gt;</span>last_direction, direction);

  <span style=color:#66d9ef>if</span> (skipLayout) {
    <span style=color:#75715e>// 把缓存的值直接赋值给当前的layout
</span><span style=color:#75715e></span>    layout<span style=color:#f92672>-&gt;</span>dimensions[CSS_WIDTH] <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>last_dimensions[CSS_WIDTH];
    layout<span style=color:#f92672>-&gt;</span>dimensions[CSS_HEIGHT] <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>last_dimensions[CSS_HEIGHT];
    layout<span style=color:#f92672>-&gt;</span>position[CSS_TOP] <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>last_position[CSS_TOP];
    layout<span style=color:#f92672>-&gt;</span>position[CSS_LEFT] <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>last_position[CSS_LEFT];
  } <span style=color:#66d9ef>else</span> {
    <span style=color:#75715e>// 缓存node节点
</span><span style=color:#75715e></span>    layout<span style=color:#f92672>-&gt;</span>last_requested_dimensions[CSS_WIDTH] <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>dimensions[CSS_WIDTH];
    layout<span style=color:#f92672>-&gt;</span>last_requested_dimensions[CSS_HEIGHT] <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>dimensions[CSS_HEIGHT];
    layout<span style=color:#f92672>-&gt;</span>last_parent_max_width <span style=color:#f92672>=</span> parentMaxWidth;
    layout<span style=color:#f92672>-&gt;</span>last_parent_max_height <span style=color:#f92672>=</span> parentMaxHeight;
    layout<span style=color:#f92672>-&gt;</span>last_direction <span style=color:#f92672>=</span> direction;

    <span style=color:#75715e>// 初始化所有子视图node的尺寸和位置
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, childCount <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>children_count; i <span style=color:#f92672>&lt;</span> childCount; i<span style=color:#f92672>++</span>) {
      resetNodeLayout(node<span style=color:#f92672>-&gt;</span>get_child(node<span style=color:#f92672>-&gt;</span>context, i));
    }

    <span style=color:#75715e>// 布局视图的核心实现
</span><span style=color:#75715e></span>    layoutNodeImpl(node, parentMaxWidth, parentMaxHeight, parentDirection);

    <span style=color:#75715e>// 布局完成，把此次的布局缓存起来，防止下次重复的布局重复计算
</span><span style=color:#75715e></span>    layout<span style=color:#f92672>-&gt;</span>last_dimensions[CSS_WIDTH] <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>dimensions[CSS_WIDTH];
    layout<span style=color:#f92672>-&gt;</span>last_dimensions[CSS_HEIGHT] <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>dimensions[CSS_HEIGHT];
    layout<span style=color:#f92672>-&gt;</span>last_position[CSS_TOP] <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>position[CSS_TOP];
    layout<span style=color:#f92672>-&gt;</span>last_position[CSS_LEFT] <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>position[CSS_LEFT];
  }
}

</code></pre></div><p>每步都注释了，见上述代码注释，在调用布局的核心实现layoutNodeImpl之前，会循环调用resetNodeLayout，初始化所有子视图。</p><p>所有的核心实现就在layoutNodeImpl这个方法里面了。Weex里面的这个方法实现有700多行，在Yoga的实现中，布局算法有1000多行。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>layoutNodeImpl</span>(css_node_t <span style=color:#f92672>*</span>node, <span style=color:#66d9ef>float</span> parentMaxWidth, <span style=color:#66d9ef>float</span> parentMaxHeight, css_direction_t parentDirection) {

}


</code></pre></div><p>这里分析一下这个算法的主要流程。在Weex的这个实现中，有7个循环，假设依次分别标上A，B，C，D，E，F，G。</p><p>先来看循环A</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>

    <span style=color:#66d9ef>float</span> mainContentDim <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#75715e>// 存在3类子视图，支持flex的子视图，不支持flex的子视图，绝对布局的子视图，我们需要知道哪些子视图是在等待分配空间。
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> flexibleChildrenCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>float</span> totalFlexible <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>int</span> nonFlexibleChildrenCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

    <span style=color:#75715e>// 利用一层循环在主轴上简单的堆叠子视图，在循环C中，会忽略这些已经在循环A中已经排列好的子视图
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> isSimpleStackMain <span style=color:#f92672>=</span>
        (isMainDimDefined <span style=color:#f92672>&amp;&amp;</span> justifyContent <span style=color:#f92672>==</span> CSS_JUSTIFY_FLEX_START) <span style=color:#f92672>||</span>
        (<span style=color:#f92672>!</span>isMainDimDefined <span style=color:#f92672>&amp;&amp;</span> justifyContent <span style=color:#f92672>!=</span> CSS_JUSTIFY_CENTER);
    <span style=color:#66d9ef>int</span> firstComplexMain <span style=color:#f92672>=</span> (isSimpleStackMain <span style=color:#f92672>?</span> childCount : startLine);

    <span style=color:#75715e>// 利用一层循环在侧轴上简单的堆叠子视图，在循环D中，会忽略这些已经在循环A中已经排列好的子视图
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> isSimpleStackCross <span style=color:#f92672>=</span> true;
    <span style=color:#66d9ef>int</span> firstComplexCross <span style=color:#f92672>=</span> childCount;

    css_node_t<span style=color:#f92672>*</span> firstFlexChild <span style=color:#f92672>=</span> NULL;
    css_node_t<span style=color:#f92672>*</span> currentFlexChild <span style=color:#f92672>=</span> NULL;

    <span style=color:#66d9ef>float</span> mainDim <span style=color:#f92672>=</span> leadingPaddingAndBorderMain;
    <span style=color:#66d9ef>float</span> crossDim <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

    <span style=color:#66d9ef>float</span> maxWidth <span style=color:#f92672>=</span> CSS_UNDEFINED;
    <span style=color:#66d9ef>float</span> maxHeight <span style=color:#f92672>=</span> CSS_UNDEFINED;

    <span style=color:#75715e>// 循环A从这里开始
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> startLine; i <span style=color:#f92672>&lt;</span> childCount; <span style=color:#f92672>++</span>i) {
      child <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>get_child(node<span style=color:#f92672>-&gt;</span>context, i);
      child<span style=color:#f92672>-&gt;</span>line_index <span style=color:#f92672>=</span> linesCount;

      child<span style=color:#f92672>-&gt;</span>next_absolute_child <span style=color:#f92672>=</span> NULL;
      child<span style=color:#f92672>-&gt;</span>next_flex_child <span style=color:#f92672>=</span> NULL;

      css_align_t alignItem <span style=color:#f92672>=</span> getAlignItem(node, child);

      <span style=color:#75715e>// 在递归layout之前，先预填充侧轴上可以被拉伸的子视图
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (alignItem <span style=color:#f92672>==</span> CSS_ALIGN_STRETCH <span style=color:#f92672>&amp;&amp;</span>
          child<span style=color:#f92672>-&gt;</span>style.position_type <span style=color:#f92672>==</span> CSS_POSITION_RELATIVE <span style=color:#f92672>&amp;&amp;</span>
          isCrossDimDefined <span style=color:#f92672>&amp;&amp;</span>
          <span style=color:#f92672>!</span>isStyleDimDefined(child, crossAxis)) {
          
        <span style=color:#75715e>// 这里要进行一个比较，比较子视图在侧轴上的尺寸 和 侧轴上减去两边的Margin、padding、Border剩下的可拉伸的空间 进行比较，因为拉伸是不会压缩原始的大小的。
</span><span style=color:#75715e></span>        child<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[crossAxis]] <span style=color:#f92672>=</span> fmaxf(
          boundAxis(child, crossAxis, node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[crossAxis]] <span style=color:#f92672>-</span>
            paddingAndBorderAxisCross <span style=color:#f92672>-</span> getMarginAxis(child, crossAxis)),
          getPaddingAndBorderAxis(child, crossAxis)
        );
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (child<span style=color:#f92672>-&gt;</span>style.position_type <span style=color:#f92672>==</span> CSS_POSITION_ABSOLUTE) {
        <span style=color:#75715e>// 这里会储存一个绝对布局子视图的链表。这样我们在后面布局的时候可以快速的跳过它们。
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (firstAbsoluteChild <span style=color:#f92672>==</span> NULL) {
          firstAbsoluteChild <span style=color:#f92672>=</span> child;
        }
        <span style=color:#66d9ef>if</span> (currentAbsoluteChild <span style=color:#f92672>!=</span> NULL) {
          currentAbsoluteChild<span style=color:#f92672>-&gt;</span>next_absolute_child <span style=color:#f92672>=</span> child;
        }
        currentAbsoluteChild <span style=color:#f92672>=</span> child;

        <span style=color:#75715e>// 预填充子视图，这里需要用到视图在轴上面的绝对坐标，如果是水平轴，需要用到左右的偏移量，如果是竖直轴，需要用到上下的偏移量。
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (ii <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ii <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>; ii<span style=color:#f92672>++</span>) {
          axis <span style=color:#f92672>=</span> (ii <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>?</span> CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
          <span style=color:#66d9ef>if</span> (isLayoutDimDefined(node, axis) <span style=color:#f92672>&amp;&amp;</span>
              <span style=color:#f92672>!</span>isStyleDimDefined(child, axis) <span style=color:#f92672>&amp;&amp;</span>
              isPosDefined(child, leading[axis]) <span style=color:#f92672>&amp;&amp;</span>
              isPosDefined(child, trailing[axis])) {
            child<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[axis]] <span style=color:#f92672>=</span> fmaxf(
              <span style=color:#75715e>// 这里是绝对布局，还需要减去leading和trailing
</span><span style=color:#75715e></span>              boundAxis(child, axis, node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[axis]] <span style=color:#f92672>-</span>
                getPaddingAndBorderAxis(node, axis) <span style=color:#f92672>-</span>
                getMarginAxis(child, axis) <span style=color:#f92672>-</span>
                getPosition(child, leading[axis]) <span style=color:#f92672>-</span>
                getPosition(child, trailing[axis])),
              getPaddingAndBorderAxis(child, axis)
            );
          }
        }
      }



</code></pre></div><p>循环A的具体实现如上，注释见代码。
循环A主要是实现的是layout布局中不可以flex的子视图的布局，mainContentDim变量是用来记录所有的尺寸以及所有不能flex的子视图的margin的总和。它被用来设置node节点的尺寸，和计算剩余空间以便供可flex子视图进行拉伸适配。</p><p>每个node节点的next_absolute_child维护了一个链表，这里存储的依次是绝对布局视图的链表。</p><p>接着需要再统计可以被拉伸的子视图。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
      <span style=color:#66d9ef>float</span> nextContentDim <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

      <span style=color:#75715e>// 统计可以拉伸flex的子视图
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (isMainDimDefined <span style=color:#f92672>&amp;&amp;</span> isFlex(child)) {
        flexibleChildrenCount<span style=color:#f92672>++</span>;
        totalFlexible <span style=color:#f92672>+=</span> child<span style=color:#f92672>-&gt;</span>style.flex;

        <span style=color:#75715e>// 存储一个链表维护可以flex的子视图
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (firstFlexChild <span style=color:#f92672>==</span> NULL) {
          firstFlexChild <span style=color:#f92672>=</span> child;
        }
        <span style=color:#66d9ef>if</span> (currentFlexChild <span style=color:#f92672>!=</span> NULL) {
          currentFlexChild<span style=color:#f92672>-&gt;</span>next_flex_child <span style=color:#f92672>=</span> child;
        }
        currentFlexChild <span style=color:#f92672>=</span> child;

        <span style=color:#75715e>// 这时我们虽然不知道确切的尺寸信息，但是已经知道了padding , border , margin，我们可以利用这些信息来给子视图确定一个最小的size，计算剩余可用的空间。
</span><span style=color:#75715e></span>        <span style=color:#75715e>// 下一个content的距离等于当前子视图Leading和Trailing的padding , border , margin6个尺寸之和。
</span><span style=color:#75715e></span>        nextContentDim <span style=color:#f92672>=</span> getPaddingAndBorderAxis(child, mainAxis) <span style=color:#f92672>+</span>
          getMarginAxis(child, mainAxis);

      } <span style=color:#66d9ef>else</span> {
        maxWidth <span style=color:#f92672>=</span> CSS_UNDEFINED;
        maxHeight <span style=color:#f92672>=</span> CSS_UNDEFINED;

       <span style=color:#75715e>// 计算出最大宽度和最大高度
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isMainRowDirection) {
          <span style=color:#66d9ef>if</span> (isLayoutDimDefined(node, resolvedRowAxis)) {
            maxWidth <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[resolvedRowAxis]] <span style=color:#f92672>-</span>
              paddingAndBorderAxisResolvedRow;
          } <span style=color:#66d9ef>else</span> {
            maxWidth <span style=color:#f92672>=</span> parentMaxWidth <span style=color:#f92672>-</span>
              getMarginAxis(node, resolvedRowAxis) <span style=color:#f92672>-</span>
              paddingAndBorderAxisResolvedRow;
          }
        } <span style=color:#66d9ef>else</span> {
          <span style=color:#66d9ef>if</span> (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {
            maxHeight <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] <span style=color:#f92672>-</span>
                paddingAndBorderAxisColumn;
          } <span style=color:#66d9ef>else</span> {
            maxHeight <span style=color:#f92672>=</span> parentMaxHeight <span style=color:#f92672>-</span>
              getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) <span style=color:#f92672>-</span>
              paddingAndBorderAxisColumn;
          }
        }

        <span style=color:#75715e>// 递归调用layout函数，进行不能拉伸的子视图的布局。
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (alreadyComputedNextLayout <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          layoutNode(child, maxWidth, maxHeight, direction);
        }

        <span style=color:#75715e>// 由于绝对布局的子视图的位置和layout无关，所以我们不能用它们来计算mainContentDim
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (child<span style=color:#f92672>-&gt;</span>style.position_type <span style=color:#f92672>==</span> CSS_POSITION_RELATIVE) {
          nonFlexibleChildrenCount<span style=color:#f92672>++</span>;
          nextContentDim <span style=color:#f92672>=</span> getDimWithMargin(child, mainAxis);
        }
      }


</code></pre></div><p>上述代码就确定出了不可拉伸的子视图的布局。</p><p>每个node节点的next_flex_child维护了一个链表，这里存储的依次是可以flex拉伸视图的链表。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
      <span style=color:#75715e>// 将要加入的元素可能会被挤到下一行
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (isNodeFlexWrap <span style=color:#f92672>&amp;&amp;</span>
          isMainDimDefined <span style=color:#f92672>&amp;&amp;</span>
          mainContentDim <span style=color:#f92672>+</span> nextContentDim <span style=color:#f92672>&gt;</span> definedMainDim <span style=color:#f92672>&amp;&amp;</span>
          <span style=color:#75715e>// 如果这里只有一个元素，它可能就需要单独占一行
</span><span style=color:#75715e></span>          i <span style=color:#f92672>!=</span> startLine) {
        nonFlexibleChildrenCount<span style=color:#f92672>--</span>;
        alreadyComputedNextLayout <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>break</span>;
      }

      <span style=color:#75715e>// 停止在主轴上堆叠子视图，剩余的子视图都在循环C里面布局
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (isSimpleStackMain <span style=color:#f92672>&amp;&amp;</span>
          (child<span style=color:#f92672>-&gt;</span>style.position_type <span style=color:#f92672>!=</span> CSS_POSITION_RELATIVE <span style=color:#f92672>||</span> isFlex(child))) {
        isSimpleStackMain <span style=color:#f92672>=</span> false;
        firstComplexMain <span style=color:#f92672>=</span> i;
      }

      <span style=color:#75715e>// 停止在侧轴上堆叠子视图，剩余的子视图都在循环D里面布局
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (isSimpleStackCross <span style=color:#f92672>&amp;&amp;</span>
          (child<span style=color:#f92672>-&gt;</span>style.position_type <span style=color:#f92672>!=</span> CSS_POSITION_RELATIVE <span style=color:#f92672>||</span>
              (alignItem <span style=color:#f92672>!=</span> CSS_ALIGN_STRETCH <span style=color:#f92672>&amp;&amp;</span> alignItem <span style=color:#f92672>!=</span> CSS_ALIGN_FLEX_START) <span style=color:#f92672>||</span>
              (alignItem <span style=color:#f92672>==</span> CSS_ALIGN_STRETCH <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>isCrossDimDefined))) {
        isSimpleStackCross <span style=color:#f92672>=</span> false;
        firstComplexCross <span style=color:#f92672>=</span> i;
      }

      <span style=color:#66d9ef>if</span> (isSimpleStackMain) {
        child<span style=color:#f92672>-&gt;</span>layout.position[pos[mainAxis]] <span style=color:#f92672>+=</span> mainDim;
        <span style=color:#66d9ef>if</span> (isMainDimDefined) {
        <span style=color:#75715e>// 设置子视图主轴上的TrailingPosition
</span><span style=color:#75715e></span>          setTrailingPosition(node, child, mainAxis);
        }
        <span style=color:#75715e>// 可以算出了主轴上的尺寸了
</span><span style=color:#75715e></span>        mainDim <span style=color:#f92672>+=</span> getDimWithMargin(child, mainAxis);
        <span style=color:#75715e>// 可以算出侧轴上的尺寸了
</span><span style=color:#75715e></span>        crossDim <span style=color:#f92672>=</span> fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
      }

      <span style=color:#66d9ef>if</span> (isSimpleStackCross) {
        child<span style=color:#f92672>-&gt;</span>layout.position[pos[crossAxis]] <span style=color:#f92672>+=</span> linesCrossDim <span style=color:#f92672>+</span> leadingPaddingAndBorderCross;
        <span style=color:#66d9ef>if</span> (isCrossDimDefined) {
        <span style=color:#75715e>// 设置子视图侧轴上的TrailingPosition
</span><span style=color:#75715e></span>          setTrailingPosition(node, child, crossAxis);
        }
      }

      alreadyComputedNextLayout <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
      mainContentDim <span style=color:#f92672>+=</span> nextContentDim;
      endLine <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    }
<span style=color:#75715e>// 循环A 至此结束
</span><span style=color:#75715e></span>
</code></pre></div><p>循环A结束以后，会计算出endLine，计算出主轴上的尺寸，侧轴上的尺寸。不可拉伸的子视图的布局也会被确定。</p><p>接下来进入循环B的阶段。</p><p>循环B主要分为2个部分，第一个部分是用来布局可拉伸的子视图。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
    <span style=color:#75715e>// 为了在主轴上布局，需要控制两个space，一个是第一个子视图和最左边的距离，另一个是两个子视图之间的距离
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> leadingMainDim <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>float</span> betweenMainDim <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

    <span style=color:#75715e>// 记录剩余的可用空间
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> remainingMainDim <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>if</span> (isMainDimDefined) {
      remainingMainDim <span style=color:#f92672>=</span> definedMainDim <span style=color:#f92672>-</span> mainContentDim;
    } <span style=color:#66d9ef>else</span> {
      remainingMainDim <span style=color:#f92672>=</span> fmaxf(mainContentDim, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>-</span> mainContentDim;
    }

    <span style=color:#75715e>// 如果当前还有可拉伸的子视图，它们就要填充剩余的可用空间
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (flexibleChildrenCount <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
      <span style=color:#66d9ef>float</span> flexibleMainDim <span style=color:#f92672>=</span> remainingMainDim <span style=color:#f92672>/</span> totalFlexible;
      <span style=color:#66d9ef>float</span> baseMainDim;
      <span style=color:#66d9ef>float</span> boundMainDim;

      <span style=color:#75715e>// 如果剩余的空间不能提供给可拉伸的子视图，不能满足它们的最大或者最小的bounds，那么这些子视图也要排除到计算拉伸的过程之外
</span><span style=color:#75715e></span>      currentFlexChild <span style=color:#f92672>=</span> firstFlexChild;
      <span style=color:#66d9ef>while</span> (currentFlexChild <span style=color:#f92672>!=</span> NULL) {
        baseMainDim <span style=color:#f92672>=</span> flexibleMainDim <span style=color:#f92672>*</span> currentFlexChild<span style=color:#f92672>-&gt;</span>style.flex <span style=color:#f92672>+</span>
            getPaddingAndBorderAxis(currentFlexChild, mainAxis);
        boundMainDim <span style=color:#f92672>=</span> boundAxis(currentFlexChild, mainAxis, baseMainDim);

        <span style=color:#66d9ef>if</span> (baseMainDim <span style=color:#f92672>!=</span> boundMainDim) {
          remainingMainDim <span style=color:#f92672>-=</span> boundMainDim;
          totalFlexible <span style=color:#f92672>-=</span> currentFlexChild<span style=color:#f92672>-&gt;</span>style.flex;
        }

        currentFlexChild <span style=color:#f92672>=</span> currentFlexChild<span style=color:#f92672>-&gt;</span>next_flex_child;
      }
      flexibleMainDim <span style=color:#f92672>=</span> remainingMainDim <span style=color:#f92672>/</span> totalFlexible;

      <span style=color:#75715e>// 不可以拉伸的子视图可以在父视图内部overflow，在这种情况下，假设没有可用的拉伸space
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (flexibleMainDim <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
        flexibleMainDim <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
      }

      currentFlexChild <span style=color:#f92672>=</span> firstFlexChild;
      <span style=color:#66d9ef>while</span> (currentFlexChild <span style=color:#f92672>!=</span> NULL) {
        <span style=color:#75715e>// 在这层循环里面我们已经可以确认子视图的最终大小了
</span><span style=color:#75715e></span>        currentFlexChild<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[mainAxis]] <span style=color:#f92672>=</span> boundAxis(currentFlexChild, mainAxis,
          flexibleMainDim <span style=color:#f92672>*</span> currentFlexChild<span style=color:#f92672>-&gt;</span>style.flex <span style=color:#f92672>+</span>
              getPaddingAndBorderAxis(currentFlexChild, mainAxis)
        );

        <span style=color:#75715e>// 计算水平方向轴上子视图的最大宽度
</span><span style=color:#75715e></span>        maxWidth <span style=color:#f92672>=</span> CSS_UNDEFINED;
        <span style=color:#66d9ef>if</span> (isLayoutDimDefined(node, resolvedRowAxis)) {
          maxWidth <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[resolvedRowAxis]] <span style=color:#f92672>-</span>
            paddingAndBorderAxisResolvedRow;
        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isMainRowDirection) {
          maxWidth <span style=color:#f92672>=</span> parentMaxWidth <span style=color:#f92672>-</span>
            getMarginAxis(node, resolvedRowAxis) <span style=color:#f92672>-</span>
            paddingAndBorderAxisResolvedRow;
        }
        
        <span style=color:#75715e>// 计算垂直方向轴上子视图的最大高度
</span><span style=color:#75715e></span>        maxHeight <span style=color:#f92672>=</span> CSS_UNDEFINED;
        <span style=color:#66d9ef>if</span> (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {
          maxHeight <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] <span style=color:#f92672>-</span>
            paddingAndBorderAxisColumn;
        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (isMainRowDirection) {
          maxHeight <span style=color:#f92672>=</span> parentMaxHeight <span style=color:#f92672>-</span>
            getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) <span style=color:#f92672>-</span>
            paddingAndBorderAxisColumn;
        }

        <span style=color:#75715e>// 再次递归完成可拉伸的子视图的布局
</span><span style=color:#75715e></span>        layoutNode(currentFlexChild, maxWidth, maxHeight, direction);

        child <span style=color:#f92672>=</span> currentFlexChild;
        currentFlexChild <span style=color:#f92672>=</span> currentFlexChild<span style=color:#f92672>-&gt;</span>next_flex_child;
        child<span style=color:#f92672>-&gt;</span>next_flex_child <span style=color:#f92672>=</span> NULL;
      }
    }


</code></pre></div><p>在上述2个while结束以后，所有可以被拉伸的子视图就都布局完成了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>

 <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (justifyContent <span style=color:#f92672>!=</span> CSS_JUSTIFY_FLEX_START) {
      <span style=color:#66d9ef>if</span> (justifyContent <span style=color:#f92672>==</span> CSS_JUSTIFY_CENTER) {
        leadingMainDim <span style=color:#f92672>=</span> remainingMainDim <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (justifyContent <span style=color:#f92672>==</span> CSS_JUSTIFY_FLEX_END) {
        leadingMainDim <span style=color:#f92672>=</span> remainingMainDim;
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (justifyContent <span style=color:#f92672>==</span> CSS_JUSTIFY_SPACE_BETWEEN) {
        remainingMainDim <span style=color:#f92672>=</span> fmaxf(remainingMainDim, <span style=color:#ae81ff>0</span>);
        <span style=color:#66d9ef>if</span> (flexibleChildrenCount <span style=color:#f92672>+</span> nonFlexibleChildrenCount <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
          betweenMainDim <span style=color:#f92672>=</span> remainingMainDim <span style=color:#f92672>/</span>
            (flexibleChildrenCount <span style=color:#f92672>+</span> nonFlexibleChildrenCount <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
        } <span style=color:#66d9ef>else</span> {
          betweenMainDim <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        }
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (justifyContent <span style=color:#f92672>==</span> CSS_JUSTIFY_SPACE_AROUND) {
        <span style=color:#75715e>// 这里是实现SPACE_AROUND的代码
</span><span style=color:#75715e></span>        betweenMainDim <span style=color:#f92672>=</span> remainingMainDim <span style=color:#f92672>/</span>
          (flexibleChildrenCount <span style=color:#f92672>+</span> nonFlexibleChildrenCount);
        leadingMainDim <span style=color:#f92672>=</span> betweenMainDim <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
      }
    }


</code></pre></div><p>可flex拉伸的视图布局完成以后，这里是收尾工作，根据justifyContent，更改betweenMainDim和leadingMainDim的大小。</p><p>接着再是循环C。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
    <span style=color:#75715e>// 在这个循环中，所有子视图的宽和高都将被确定下来。在确定各个子视图的坐标的时候，同时也将确定父视图的宽和高。
</span><span style=color:#75715e></span>    mainDim <span style=color:#f92672>+=</span> leadingMainDim;

    <span style=color:#75715e>// 按照Line，一层层的循环
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> firstComplexMain; i <span style=color:#f92672>&lt;</span> endLine; <span style=color:#f92672>++</span>i) {
      child <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>get_child(node<span style=color:#f92672>-&gt;</span>context, i);

      <span style=color:#66d9ef>if</span> (child<span style=color:#f92672>-&gt;</span>style.position_type <span style=color:#f92672>==</span> CSS_POSITION_ABSOLUTE <span style=color:#f92672>&amp;&amp;</span>
          isPosDefined(child, leading[mainAxis])) {
        <span style=color:#75715e>// 到这里，绝对坐标的子视图的坐标已经确定下来了，左边距和上边距已经被定下来了。这时子视图的绝对坐标可以确定了。
</span><span style=color:#75715e></span>        child<span style=color:#f92672>-&gt;</span>layout.position[pos[mainAxis]] <span style=color:#f92672>=</span> getPosition(child, leading[mainAxis]) <span style=color:#f92672>+</span>
          getLeadingBorder(node, mainAxis) <span style=color:#f92672>+</span>
          getLeadingMargin(child, mainAxis);
      } <span style=color:#66d9ef>else</span> {
        <span style=color:#75715e>// 如果子视图不是绝对坐标，坐标是相对的，或者还没有确定下来左边距和上边距，那么就根据当前位置确定坐标
</span><span style=color:#75715e></span>        child<span style=color:#f92672>-&gt;</span>layout.position[pos[mainAxis]] <span style=color:#f92672>+=</span> mainDim;

        <span style=color:#75715e>// 确定trailing的坐标位置
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (isMainDimDefined) {
          setTrailingPosition(node, child, mainAxis);
        }

        <span style=color:#75715e>// 接下来开始处理相对坐标的子视图，具有绝对坐标的子视图不会参与下述的布局计算中
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (child<span style=color:#f92672>-&gt;</span>style.position_type <span style=color:#f92672>==</span> CSS_POSITION_RELATIVE) {
          <span style=color:#75715e>// 主轴上的宽度是由所有的子视图的宽度累加而成
</span><span style=color:#75715e></span>          mainDim <span style=color:#f92672>+=</span> betweenMainDim <span style=color:#f92672>+</span> getDimWithMargin(child, mainAxis);
          <span style=color:#75715e>// 侧轴的高度是由最高的子视图决定的
</span><span style=color:#75715e></span>          crossDim <span style=color:#f92672>=</span> fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
        }
      }
    }

    <span style=color:#66d9ef>float</span> containerCrossAxis <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[crossAxis]];
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isCrossDimDefined) {
      containerCrossAxis <span style=color:#f92672>=</span> fmaxf(
        <span style=color:#75715e>// 计算父视图的时候需要加上，上下的padding和Border。
</span><span style=color:#75715e></span>        boundAxis(node, crossAxis, crossDim <span style=color:#f92672>+</span> paddingAndBorderAxisCross),
        paddingAndBorderAxisCross
      );
    }



</code></pre></div><p>在循环C中，会在主轴上计算出所有子视图的坐标，包括各个子视图的宽和高。</p><p>接下来就到循环D的流程了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>

     <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> firstComplexCross; i <span style=color:#f92672>&lt;</span> endLine; <span style=color:#f92672>++</span>i) {
      child <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>get_child(node<span style=color:#f92672>-&gt;</span>context, i);

      <span style=color:#66d9ef>if</span> (child<span style=color:#f92672>-&gt;</span>style.position_type <span style=color:#f92672>==</span> CSS_POSITION_ABSOLUTE <span style=color:#f92672>&amp;&amp;</span>
          isPosDefined(child, leading[crossAxis])) {
        <span style=color:#75715e>// 到这里，绝对坐标的子视图的坐标已经确定下来了，上下左右至少有一边的坐标已经被定下来了。这时子视图的绝对坐标可以确定了。
</span><span style=color:#75715e></span>        child<span style=color:#f92672>-&gt;</span>layout.position[pos[crossAxis]] <span style=color:#f92672>=</span> getPosition(child, leading[crossAxis]) <span style=color:#f92672>+</span>
          getLeadingBorder(node, crossAxis) <span style=color:#f92672>+</span>
          getLeadingMargin(child, crossAxis);

      } <span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>float</span> leadingCrossDim <span style=color:#f92672>=</span> leadingPaddingAndBorderCross;

        <span style=color:#75715e>// 在侧轴上，针对相对坐标的子视图，我们利用父视图的alignItems或者子视图的alignSelf来确定具体的坐标位置
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (child<span style=color:#f92672>-&gt;</span>style.position_type <span style=color:#f92672>==</span> CSS_POSITION_RELATIVE) {
          <span style=color:#75715e>// 获取子视图的AlignItem属性值
</span><span style=color:#75715e></span>          css_align_t alignItem <span style=color:#f92672>=</span> getAlignItem(node, child);
          <span style=color:#66d9ef>if</span> (alignItem <span style=color:#f92672>==</span> CSS_ALIGN_STRETCH) {
            <span style=color:#75715e>// 如果在侧轴上子视图还没有确定尺寸，那么才会相应STRETCH拉伸。
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isStyleDimDefined(child, crossAxis)) {
              <span style=color:#66d9ef>float</span> dimCrossAxis <span style=color:#f92672>=</span> child<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[crossAxis]];
              child<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[crossAxis]] <span style=color:#f92672>=</span> fmaxf(
                boundAxis(child, crossAxis, containerCrossAxis <span style=color:#f92672>-</span>
                  paddingAndBorderAxisCross <span style=color:#f92672>-</span> getMarginAxis(child, crossAxis)),
                getPaddingAndBorderAxis(child, crossAxis)
              );

              <span style=color:#75715e>// 如果视图的大小变化了，连带该视图的子视图还需要再次layout
</span><span style=color:#75715e></span>              <span style=color:#66d9ef>if</span> (dimCrossAxis <span style=color:#f92672>!=</span> child<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[crossAxis]] <span style=color:#f92672>&amp;&amp;</span> child<span style=color:#f92672>-&gt;</span>children_count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
                <span style=color:#75715e>// Reset child margins before re-layout as they are added back in layoutNode and would be doubled
</span><span style=color:#75715e></span>                child<span style=color:#f92672>-&gt;</span>layout.position[leading[mainAxis]] <span style=color:#f92672>-=</span> getLeadingMargin(child, mainAxis) <span style=color:#f92672>+</span>
                  getRelativePosition(child, mainAxis);
                child<span style=color:#f92672>-&gt;</span>layout.position[trailing[mainAxis]] <span style=color:#f92672>-=</span> getTrailingMargin(child, mainAxis) <span style=color:#f92672>+</span>
                  getRelativePosition(child, mainAxis);
                child<span style=color:#f92672>-&gt;</span>layout.position[leading[crossAxis]] <span style=color:#f92672>-=</span> getLeadingMargin(child, crossAxis) <span style=color:#f92672>+</span>
                  getRelativePosition(child, crossAxis);
                child<span style=color:#f92672>-&gt;</span>layout.position[trailing[crossAxis]] <span style=color:#f92672>-=</span> getTrailingMargin(child, crossAxis) <span style=color:#f92672>+</span>
                  getRelativePosition(child, crossAxis);

                <span style=color:#75715e>// 递归子视图的布局
</span><span style=color:#75715e></span>                layoutNode(child, maxWidth, maxHeight, direction);
              }
            }
          } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (alignItem <span style=color:#f92672>!=</span> CSS_ALIGN_FLEX_START) {
            <span style=color:#75715e>// 在侧轴上剩余的空间等于父视图在侧轴上的高度减去子视图的在侧轴上padding、Border、Margin以及高度
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>float</span> remainingCrossDim <span style=color:#f92672>=</span> containerCrossAxis <span style=color:#f92672>-</span>
              paddingAndBorderAxisCross <span style=color:#f92672>-</span> getDimWithMargin(child, crossAxis);

            <span style=color:#66d9ef>if</span> (alignItem <span style=color:#f92672>==</span> CSS_ALIGN_CENTER) {
              leadingCrossDim <span style=color:#f92672>+=</span> remainingCrossDim <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
            } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// CSS_ALIGN_FLEX_END
</span><span style=color:#75715e></span>              leadingCrossDim <span style=color:#f92672>+=</span> remainingCrossDim;
            }
          }
        }

        <span style=color:#75715e>// 确定子视图在侧轴上的坐标位置
</span><span style=color:#75715e></span>        child<span style=color:#f92672>-&gt;</span>layout.position[pos[crossAxis]] <span style=color:#f92672>+=</span> linesCrossDim <span style=color:#f92672>+</span> leadingCrossDim;

        <span style=color:#75715e>// 确定trailing的坐标
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (isCrossDimDefined) {
          setTrailingPosition(node, child, crossAxis);
        }
      }
    }

    linesCrossDim <span style=color:#f92672>+=</span> crossDim;
    linesMainDim <span style=color:#f92672>=</span> fmaxf(linesMainDim, mainDim);
    linesCount <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
    startLine <span style=color:#f92672>=</span> endLine;
  }


</code></pre></div><p>上述的循环D中主要是在侧轴上计算子视图的坐标。如果视图发生了大小变化，还需要递归子视图，重新布局一次。</p><p>再接着是循环E</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>

  <span style=color:#66d9ef>if</span> (linesCount <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> isCrossDimDefined) {
    <span style=color:#66d9ef>float</span> nodeCrossAxisInnerSize <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[crossAxis]] <span style=color:#f92672>-</span>
        paddingAndBorderAxisCross;
    <span style=color:#66d9ef>float</span> remainingAlignContentDim <span style=color:#f92672>=</span> nodeCrossAxisInnerSize <span style=color:#f92672>-</span> linesCrossDim;

    <span style=color:#66d9ef>float</span> crossDimLead <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>float</span> currentLead <span style=color:#f92672>=</span> leadingPaddingAndBorderCross;

    <span style=color:#75715e>// 布局alignContent
</span><span style=color:#75715e></span>    css_align_t alignContent <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>style.align_content;
    <span style=color:#66d9ef>if</span> (alignContent <span style=color:#f92672>==</span> CSS_ALIGN_FLEX_END) {
      currentLead <span style=color:#f92672>+=</span> remainingAlignContentDim;
    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (alignContent <span style=color:#f92672>==</span> CSS_ALIGN_CENTER) {
      currentLead <span style=color:#f92672>+=</span> remainingAlignContentDim <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (alignContent <span style=color:#f92672>==</span> CSS_ALIGN_STRETCH) {
      <span style=color:#66d9ef>if</span> (nodeCrossAxisInnerSize <span style=color:#f92672>&gt;</span> linesCrossDim) {
        crossDimLead <span style=color:#f92672>=</span> (remainingAlignContentDim <span style=color:#f92672>/</span> linesCount);
      }
    }

    <span style=color:#66d9ef>int</span> endIndex <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> linesCount; <span style=color:#f92672>++</span>i) {
      <span style=color:#66d9ef>int</span> startIndex <span style=color:#f92672>=</span> endIndex;

      <span style=color:#75715e>// 计算每一行的行高，行高根据lineHeight和子视图在侧轴上的高度加上下的Margin之和比较，取最大值
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>float</span> lineHeight <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
      <span style=color:#66d9ef>for</span> (ii <span style=color:#f92672>=</span> startIndex; ii <span style=color:#f92672>&lt;</span> childCount; <span style=color:#f92672>++</span>ii) {
        child <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>get_child(node<span style=color:#f92672>-&gt;</span>context, ii);
        <span style=color:#66d9ef>if</span> (child<span style=color:#f92672>-&gt;</span>style.position_type <span style=color:#f92672>!=</span> CSS_POSITION_RELATIVE) {
          <span style=color:#66d9ef>continue</span>;
        }
        <span style=color:#66d9ef>if</span> (child<span style=color:#f92672>-&gt;</span>line_index <span style=color:#f92672>!=</span> i) {
          <span style=color:#66d9ef>break</span>;
        }
        <span style=color:#66d9ef>if</span> (isLayoutDimDefined(child, crossAxis)) {
          lineHeight <span style=color:#f92672>=</span> fmaxf(
            lineHeight,
            child<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[crossAxis]] <span style=color:#f92672>+</span> getMarginAxis(child, crossAxis)
          );
        }
      }
      endIndex <span style=color:#f92672>=</span> ii;
      lineHeight <span style=color:#f92672>+=</span> crossDimLead;

      <span style=color:#66d9ef>for</span> (ii <span style=color:#f92672>=</span> startIndex; ii <span style=color:#f92672>&lt;</span> endIndex; <span style=color:#f92672>++</span>ii) {
        child <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>get_child(node<span style=color:#f92672>-&gt;</span>context, ii);
        <span style=color:#66d9ef>if</span> (child<span style=color:#f92672>-&gt;</span>style.position_type <span style=color:#f92672>!=</span> CSS_POSITION_RELATIVE) {
          <span style=color:#66d9ef>continue</span>;
        }

        <span style=color:#75715e>// 布局AlignItem
</span><span style=color:#75715e></span>        css_align_t alignContentAlignItem <span style=color:#f92672>=</span> getAlignItem(node, child);
        <span style=color:#66d9ef>if</span> (alignContentAlignItem <span style=color:#f92672>==</span> CSS_ALIGN_FLEX_START) {
          child<span style=color:#f92672>-&gt;</span>layout.position[pos[crossAxis]] <span style=color:#f92672>=</span> currentLead <span style=color:#f92672>+</span> getLeadingMargin(child, crossAxis);
        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (alignContentAlignItem <span style=color:#f92672>==</span> CSS_ALIGN_FLEX_END) {
          child<span style=color:#f92672>-&gt;</span>layout.position[pos[crossAxis]] <span style=color:#f92672>=</span> currentLead <span style=color:#f92672>+</span> lineHeight <span style=color:#f92672>-</span> getTrailingMargin(child, crossAxis) <span style=color:#f92672>-</span> child<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[crossAxis]];
        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (alignContentAlignItem <span style=color:#f92672>==</span> CSS_ALIGN_CENTER) {
          <span style=color:#66d9ef>float</span> childHeight <span style=color:#f92672>=</span> child<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[crossAxis]];
          child<span style=color:#f92672>-&gt;</span>layout.position[pos[crossAxis]] <span style=color:#f92672>=</span> currentLead <span style=color:#f92672>+</span> (lineHeight <span style=color:#f92672>-</span> childHeight) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (alignContentAlignItem <span style=color:#f92672>==</span> CSS_ALIGN_STRETCH) {
          child<span style=color:#f92672>-&gt;</span>layout.position[pos[crossAxis]] <span style=color:#f92672>=</span> currentLead <span style=color:#f92672>+</span> getLeadingMargin(child, crossAxis);
          <span style=color:#75715e>// TODO(prenaux): Correctly set the height of items with undefined
</span><span style=color:#75715e></span>          <span style=color:#75715e>//                (auto) crossAxis dimension.
</span><span style=color:#75715e></span>        }
      }

      currentLead <span style=color:#f92672>+=</span> lineHeight;
    }
  }



</code></pre></div><p>执行循环E有一个前提，就是，行数至少要超过一行，并且侧轴上有高度定义。满足了这个前提条件以后才会开始下面的align规则。</p><p>在循环E中会处理侧轴上的align拉伸规则。这里会布局alignContent和AlignItem。</p><p>这块代码实现的算法原理请参见<a href=http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm>http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm</a> section 9.4部分。</p><p>至此可能还存在一些没有指定宽和高的视图，接下来将会做最后一次的处理。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>

  <span style=color:#75715e>// 如果某个视图没有被指定宽或者高，并且也没有被父视图设置宽和高，那么在这里通过子视图来设置宽和高
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isMainDimDefined) {
    <span style=color:#75715e>// 视图的宽度等于内部子视图的宽度加上Trailing的Padding、Border的宽度和主轴上Leading的Padding、Border+ Trailing的Padding、Border，两者取最大值。
</span><span style=color:#75715e></span>    node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[mainAxis]] <span style=color:#f92672>=</span> fmaxf(
      boundAxis(node, mainAxis, linesMainDim <span style=color:#f92672>+</span> getTrailingPaddingAndBorder(node, mainAxis)),
      paddingAndBorderAxisMain
    );

    <span style=color:#66d9ef>if</span> (mainAxis <span style=color:#f92672>==</span> CSS_FLEX_DIRECTION_ROW_REVERSE <span style=color:#f92672>||</span>
        mainAxis <span style=color:#f92672>==</span> CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
      needsMainTrailingPos <span style=color:#f92672>=</span> true;
    }
  }

  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isCrossDimDefined) {
    node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[crossAxis]] <span style=color:#f92672>=</span> fmaxf(
      <span style=color:#75715e>// 视图的高度等于内部子视图的高度加上上下的Padding、Border的宽度和侧轴上Padding、Border，两者取最大值。
</span><span style=color:#75715e></span>      boundAxis(node, crossAxis, linesCrossDim <span style=color:#f92672>+</span> paddingAndBorderAxisCross),
      paddingAndBorderAxisCross
    );

    <span style=color:#66d9ef>if</span> (crossAxis <span style=color:#f92672>==</span> CSS_FLEX_DIRECTION_ROW_REVERSE <span style=color:#f92672>||</span>
        crossAxis <span style=color:#f92672>==</span> CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
      needsCrossTrailingPos <span style=color:#f92672>=</span> true;
    }
  }



</code></pre></div><p>这些没有确定宽和高的子视图的宽和高会根据父视图来决定。方法见上述代码。</p><p>再就是循环F了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>

  <span style=color:#66d9ef>if</span> (needsMainTrailingPos <span style=color:#f92672>||</span> needsCrossTrailingPos) {
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> childCount; <span style=color:#f92672>++</span>i) {
      child <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>get_child(node<span style=color:#f92672>-&gt;</span>context, i);

      <span style=color:#66d9ef>if</span> (needsMainTrailingPos) {
        setTrailingPosition(node, child, mainAxis);
      }

      <span style=color:#66d9ef>if</span> (needsCrossTrailingPos) {
        setTrailingPosition(node, child, crossAxis);
      }
    }
  }


</code></pre></div><p>这一步是设置当前node节点的Trailing坐标，如果有必要的话。如果不需要，这一步会直接跳过。</p><p>最后一步就是循环G了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
  currentAbsoluteChild <span style=color:#f92672>=</span> firstAbsoluteChild;
  <span style=color:#66d9ef>while</span> (currentAbsoluteChild <span style=color:#f92672>!=</span> NULL) {
    <span style=color:#66d9ef>for</span> (ii <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ii <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>; ii<span style=color:#f92672>++</span>) {
      axis <span style=color:#f92672>=</span> (ii <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>?</span> CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;

      <span style=color:#66d9ef>if</span> (isLayoutDimDefined(node, axis) <span style=color:#f92672>&amp;&amp;</span>
          <span style=color:#f92672>!</span>isStyleDimDefined(currentAbsoluteChild, axis) <span style=color:#f92672>&amp;&amp;</span>
          isPosDefined(currentAbsoluteChild, leading[axis]) <span style=color:#f92672>&amp;&amp;</span>
          isPosDefined(currentAbsoluteChild, trailing[axis])) {
        <span style=color:#75715e>// 绝对坐标的子视图在主轴上的宽度，在侧轴上的高度都不能比Padding、Border的总和小。
</span><span style=color:#75715e></span>        currentAbsoluteChild<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[axis]] <span style=color:#f92672>=</span> fmaxf(
          boundAxis(currentAbsoluteChild, axis, node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[axis]] <span style=color:#f92672>-</span>
            getBorderAxis(node, axis) <span style=color:#f92672>-</span>
            getMarginAxis(currentAbsoluteChild, axis) <span style=color:#f92672>-</span>
            getPosition(currentAbsoluteChild, leading[axis]) <span style=color:#f92672>-</span>
            getPosition(currentAbsoluteChild, trailing[axis])
          ),
          getPaddingAndBorderAxis(currentAbsoluteChild, axis)
        );
      }

      <span style=color:#66d9ef>if</span> (isPosDefined(currentAbsoluteChild, trailing[axis]) <span style=color:#f92672>&amp;&amp;</span>
          <span style=color:#f92672>!</span>isPosDefined(currentAbsoluteChild, leading[axis])) {
        <span style=color:#75715e>// 当前子视图的坐标等于当前视图的宽度减去子视图的宽度再减去trailing
</span><span style=color:#75715e></span>        currentAbsoluteChild<span style=color:#f92672>-&gt;</span>layout.position[leading[axis]] <span style=color:#f92672>=</span>
          node<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[axis]] <span style=color:#f92672>-</span>
          currentAbsoluteChild<span style=color:#f92672>-&gt;</span>layout.dimensions[dim[axis]] <span style=color:#f92672>-</span>
          getPosition(currentAbsoluteChild, trailing[axis]);
      }
    }

    child <span style=color:#f92672>=</span> currentAbsoluteChild;
    currentAbsoluteChild <span style=color:#f92672>=</span> currentAbsoluteChild<span style=color:#f92672>-&gt;</span>next_absolute_child;
    child<span style=color:#f92672>-&gt;</span>next_absolute_child <span style=color:#f92672>=</span> NULL;
  }



</code></pre></div><p>最后这一步循环G是用来给绝对坐标的子视图计算宽度和高度。</p><p>执行完上述7个循环以后，所有的子视图就都layout完成了。</p><p>总结一下上述的流程，如下图：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_32.png alt></p><h3 id=二-weex布局算法性能分析>二. Weex布局算法性能分析</h3><h4 id=1算法实现分析>1.算法实现分析</h4><p>上一章节看了Weex的layout算法实现。这里就分析一下在这个实现下，布局能力究竟有多强。</p><p>Weex的实现是FaceBook的开源库Yoga的前身，所以这里可以把两个看成是一种实现。</p><p>Weex的这种FlexBox的实现其实只是W3C标准的一个实现的子集，因为FlexBox的官方标准里面还有一些并没有实现出来。W3C上定义的FlexBox的标准，文档在<a href=https://www.w3.org/TR/css-flexbox-1/>这里</a>。</p><p>FlexBox标准定义：</p><p>针对父视图 (flex container):</p><ol><li>display</li><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ol><p>针对子视图 (flex items):</p><ol><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ol><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_33.png alt></p><p>相比官方的定义，上述的实现有一些限制：</p><ol><li>所有显示属性的node节点都默认假定是Flex的视图，当然这里要除去文本节点，因为它会被假定为inline-flex。</li><li>不支持zIndex的属性，包括任何z上的排序。所有的node节点都是按照代码书写的先后顺序进行排列的。Weex 目前也不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面。</li><li>FlexBox里面定义的order属性，也不支持。flex item默认按照代码书写顺序。</li><li>visibility属性默认都是可见的，暂时不支持边缘塌陷合并(collapse)和隐藏(hidden)属性。</li><li>不支持forced breaks。</li><li>不支持垂直方向的inline(比如从上到下的text，或者从下到上的text)</li></ol><p>关于Flexbox 在iOS这边的具体实现上一章节已经分析过了。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_34.png alt></p><p>接下来仔细分析一下Autolayout的具体实现</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_35.png alt></p><p>原来我们用Frame进行布局的时候，需要知道一个点（origin或者center）和宽高就可以确定一个View。</p><p>现在换成了Autolayout，每个View需要知道4个尺寸。left，top，width，height。</p><p>但是一个View的约束是相对于另一个View的，比如说相对于父视图，或者是相对于两两View之间的。</p><p>那么两两个View之间的约束就会变成一个八元一次的方程组。</p><p>解这个方程组可能有以下3种情况：</p><ol><li>当方程组的解的个数有无穷多个，最终会得到欠约束的有歧义的布局。</li><li>当方程无解时，则表示约束有冲突。</li><li>只有当方程组有唯一解的时候，才能得到一个稳定的布局。</li></ol><p><strong>Autolayout 本质是一个线性方程解析器，该解析器试图找到一种可满足其规则的几何表达式。</strong></p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_36.png alt></p><p>Autolayout的底层数学模型是线性算术约束问题。</p><p>关于这个问题，早在1940年，由Dantzig提出了一个the simplex algorithm算法，但是由于这个算法实在很难用在UI应用上面，所以没有得到很广泛的应用，直到1997年，澳大利亚的莫纳什大学（Monash University）的两名学生，Alan Borning 和 Kim Marriott实现了Cassowary线性约束算法，才得以在UI应用上被大量的应用起来。</p><p>Cassowary线性约束算法是基于双simplex算法的，在增加约束或者一个对象被移除的时候，通过局部误差增益 和 加权求和比较 ，能够完美的增量处理不同层次的约束。Cassowary线性约束算法适合GUI布局系统，被用来计算view之间的位置的。开发者可以指定不同View之间的位置关系和约束关系，Cassowary线性约束算法会去求处符合条件的最优值。</p><p>下面是两位学生写的相关的论文，有兴趣的可以读一下，了解一下算法的具体实现：</p><ol><li>Alan Borning, Kim Marriott, Peter Stuckey, and Yi Xiao, <a href=https://constraints.cs.washington.edu/solvers/uist97.pdf>Solving Linear Arithmetic Constraints for User Interface Applications</a>, Proceedings of the 1997 ACM Symposium on User Interface Software and Technology, October 1997, pages 87-96.</li><li>Greg J. Badros and Alan Borning, &ldquo;The Cassowary Linear Arithmetic Constraint Solving Algorithm: Interface and Implementation&rdquo;, Technical Report UW-CSE-98-06-04, June 1998 (<a href=https://constraints.cs.washington.edu/cassowary/cassowary-tr.pdf>pdf</a>)</li><li>Greg J. Badros, Alan Borning, and Peter J. Stuckey, &ldquo;The Cassowary Linear Arithmetic Constraint Solving Algorithm,&rdquo; <em>ACM Transactions on Computer Human Interaction</em>, Vol. 8 No. 4, December 2001, pages 267-306. (<a href=https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf>pdf</a>)</li></ol><p>Cassowary线性约束算法的伪代码如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_37.png alt></p><p>关于这个算法已经被人们实现成了各个版本。1年以后，又出了一个新的QOCA算法。以下这段话摘抄自1997年ACM权威论文上的一篇文章：</p><blockquote><p>Both of our algorithms have been implemented, Cassowary
in Smalltalk and QOCA in C++. They perform surprisingly well. The QOCA implementation is considerably more sophisticated and has much better performance than the current version of Cassowary. However, QOCA is inherently a more complex algorithm, and re-implementing it with a comparable level of performance would be a daunting task. In contrast, Cassowary is straightforward, and a reimplementation based on this paper is more reasonable, given a knowledge of the simplex algorithm.</p></blockquote><p>Cassowary（<a href=https://constraints.cs.washington.edu/cassowary/>项目主页</a>）也是优先被Smalltalk实现了，也是用在Autolayout技术上。另外还有更加复杂的QOCA算法，这里就不再细谈了，有兴趣的同学可以看看上面三篇论文，里面有详细的描述。</p><h4 id=2算法性能测试准备工作>2.算法性能测试准备工作</h4><p>开始笔者是打算连带Weex的布局性能一起测试的，但是由于Weex的布局都在子线程，刷新渲染回到主线程，需要测试都在主线程的情况需要改动一些代码，而且Weex原生的布局是从JS调用方法，如果用这种方法又会多损耗一些性能，对测试结果有影响。于是换成Weex相同布局方式的Yoga算法进行测试。由于Facebook对它进行了很好的封装，使用起来也很方便。虽然Layout算法和Weex有些差异，但是不影响定性的比较。</p><p>确定下来测试对象：Frame，FlexBox(Yoga实现)，Autolayout。</p><p>测试前，还需要准备测试模型，这里选出了3种测试模型。</p><p>第一种测试模型是随机生成完全不相关联的View。如下图：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_38.png alt></p><p>第二种测试模型是生成相互嵌套的View。嵌套规则设置一个简单的：子视图依次比父视图高度少一个像素。类似下图，这是500个View相互嵌套的结果：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_39.png alt></p><p>第三种测试模型是针对Autolayout专门加的。由于Autolayout约束的特殊性，这里针对链式约束额外增加的测试模型。规则是前后两个相连的View之间依次加上约束。类似下图，这是500个View链式的约束结果：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_40.png alt></p><p>根据测试模型，我们可以得到如下的7组需要测试的测试用例：</p><p>1.Frame
2.嵌套的Frame
3.Yoga
4.嵌套的Yoga
5.Autolayout
6.嵌套的Autolayout
7.链式的Autolayout</p><p>测试样本：由于需要考虑到测试的通用性，测试样本要尽量随机。于是针对随机生成的坐标全部都随机生成，View的颜色也全部都随机生成，这样保证了通用公正公平性质。</p><p>测试次数：为了保证测试数据能尽量真实，笔者在这里花了大量的时间。每组测试用例都针对从100，200，300，400，500，600，700，800，900，1000个视图进行测试，为了保证测试的普遍性，这里每次测试都测试10000次，然后对10000次的结果进行加和平均。加和平均取小数点后5位。（10000次的统计是用计算机来算的，但是真的非常非常非常的耗时，有兴趣的可以自己用电脑试试）</p><p>最后展示一下测试机器的配置和系统版本：</p><p>（由于iPhone真机对每个App的内存有限制，产生1000个嵌套的视图，并且进行10000次试验，iPhone真机完全受不了这种计算量，App直接闪退，所以用真机测试到一半，改用模拟器测试，借助Mac的性能，咬着牙从零开始，重新统计了所有测试用例的数据）</p><p>如果有性能更强的Mac电脑（垃圾桶），测试全过程花的时间可能会更少。</p><p>笔者用的电脑的配置如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_41.png alt></p><p>测试用的模拟器是iPad Pro（12.9 inch）iOS 10.3（14E269）</p><p>我所用的测试代码也公布出来，有兴趣的可以自己测试测试。<a href=https://github.com/halfrost/Halfrost-Field/tree/master/contents/iOS/AutoLayoutProfiling-master>测试代码在这里</a></p><h4 id=3算法性能测试结果>3.算法性能测试结果</h4><p>公布测试结果：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_42.png alt></p><p>上图数据是10，20，30，40，50，60，70，80，90，100个View分别用7组用例测试出来的结果。将上面的结果统计成折线图，如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_43.png alt></p><p>结果依旧是Autolayout的3种方式都高于其他4种布局方式。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_44.png alt></p><p>上图是3个布局算法在普通场景下的性能比较图，可以看到，FlexBox的性能接近于原生的Frame。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_45.png alt></p><p>上图是3个布局算法在嵌套情况下的性能比较图，可以看到，FlexBox的性能也依旧接近于原生的Frame。而嵌套情况下的Autolayout的性能急剧下降。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_46.png alt></p><p>最后这张图也是专门针对Autolayout额外加的一组测试。目的是为了比较3种场景下不同的Autolayout的性能，可以看到，嵌套的Autolayout的性能依旧是最差的！</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_47.png alt></p><p>上图数据是100，200，300，400，500，600，700，800，900，1000个View分别用7组用例测试出来的结果。将上面的结果统计成折线图，如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_48.png alt></p><p>当视图多到900，1000的时候，嵌套的Autolayout直接就导致模拟器崩溃了。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_49.png alt></p><p>上图是3个布局算法在普通场景下的性能比较图，可以看到，FlexBox的性能接近于原生的Frame。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_50.png alt></p><p>上图是3个布局算法在嵌套情况下的性能比较图，可以看到，FlexBox的性能也依旧接近于原生的Frame。而嵌套情况下的Autolayout的性能急剧下降。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_51.png alt></p><p>最后这张图是专门针对Autolayout额外加的一组测试。目的是为了比较3种场景下不同的Autolayout的性能，可以看到，平时我们使用嵌套的Autolayout的性能是最差的！</p><h3 id=三-weex是如何布局原生界面的>三. Weex是如何布局原生界面的</h3><p>上一章节看了FlexBox算法的强大布局能力，这一章节就来看看Weex究竟是如何利用这个能力的对原生View进行Layout。</p><p>在解答上面这个问题之前，先让我们回顾一下上篇文章<a href=http://www.jianshu.com/p/41cde2c62b81>《Weex 是如何在 iOS 客户端上跑起来的》</a>里面提到的，在JSFramework转换从网络上下载下来的JS文件之前，本地先注册了4个重要的回调函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>NSInteger</span>(<span style=color:#f92672>^</span>WXJSCallNative)(NSString <span style=color:#f92672>*</span>instance, NSArray <span style=color:#f92672>*</span>tasks, NSString <span style=color:#f92672>*</span>callback);
<span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>NSInteger</span>(<span style=color:#f92672>^</span>WXJSCallAddElement)(NSString <span style=color:#f92672>*</span>instanceId,  NSString <span style=color:#f92672>*</span>parentRef, NSDictionary <span style=color:#f92672>*</span>elementData, NSInteger index);
<span style=color:#66d9ef>typedef</span> NSInvocation <span style=color:#f92672>*</span>(<span style=color:#f92672>^</span>WXJSCallNativeModule)(NSString <span style=color:#f92672>*</span>instanceId, NSString <span style=color:#f92672>*</span>moduleName, NSString <span style=color:#f92672>*</span>methodName, NSArray <span style=color:#f92672>*</span>args, NSDictionary <span style=color:#f92672>*</span>options);
<span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>void</span> (<span style=color:#f92672>^</span>WXJSCallNativeComponent)(NSString <span style=color:#f92672>*</span>instanceId, NSString <span style=color:#f92672>*</span>componentRef, NSString <span style=color:#f92672>*</span>methodName, NSArray <span style=color:#f92672>*</span>args, NSDictionary <span style=color:#f92672>*</span>options);


</code></pre></div><p>这4个block非常重要，是JS和OC进行相互调用的四大函数。</p><p>先来回顾一下这四大函数注册的时候分别封装了哪些闭包。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>WXBridgeContext</span> ()
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>) <span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>WXBridgeProtocol<span style=color:#f92672>&gt;</span>  jsBridge;

</code></pre></div><p>在WXBridgeContext类里面有一个jsBridge。jsBridge初始化的时候会注册这4个全局函数。</p><p>第一个闭包函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    [_jsBridge registerCallNative:<span style=color:#f92672>^</span>NSInteger(NSString <span style=color:#f92672>*</span>instance, NSArray <span style=color:#f92672>*</span>tasks, NSString <span style=color:#f92672>*</span>callback) {
        <span style=color:#66d9ef>return</span> [weakSelf invokeNative:instance tasks:tasks callback:callback];
    }];



</code></pre></div><p>这里的闭包函数会被传入到下面这个函数中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>registerCallNative:</span>(WXJSCallNative)callNative
{
    JSValue<span style=color:#f92672>*</span> (<span style=color:#f92672>^</span>callNativeBlock)(JSValue <span style=color:#f92672>*</span>, JSValue <span style=color:#f92672>*</span>, JSValue <span style=color:#f92672>*</span>) <span style=color:#f92672>=</span> <span style=color:#f92672>^</span>JSValue<span style=color:#f92672>*</span>(JSValue <span style=color:#f92672>*</span>instance, JSValue <span style=color:#f92672>*</span>tasks, JSValue <span style=color:#f92672>*</span>callback){
        NSString <span style=color:#f92672>*</span>instanceId <span style=color:#f92672>=</span> [instance toString];
        NSArray <span style=color:#f92672>*</span>tasksArray <span style=color:#f92672>=</span> [tasks toArray];
        NSString <span style=color:#f92672>*</span>callbackId <span style=color:#f92672>=</span> [callback toString];
        
        WXLogDebug(<span style=color:#e6db74>@&#34;Calling native... instance:%@, tasks:%@, callback:%@&#34;</span>, instanceId, tasksArray, callbackId);
        <span style=color:#66d9ef>return</span> [JSValue valueWithInt32:(int32_t)callNative(instanceId, tasksArray, callbackId) inContext:[JSContext currentContext]];
    };
    
    _jsContext[<span style=color:#e6db74>@&#34;callNative&#34;</span>] <span style=color:#f92672>=</span> callNativeBlock;
}


</code></pre></div><p>这里就封装了一个函数，暴露给JS用。方法名叫callNative，函数参数为3个，分别是instanceId，tasksArray任务数组，callbackId回调ID。</p><p>所有的OC的闭包都需要封装一层，因为暴露给JS的方法不能有冒号，所有的参数都是直接跟在小括号的参数列表里面的，因为JS的函数是这样定义的。</p><p>当JS调用callNative方法之后，就会最终执行WXBridgeContext类里面的[weakSelf invokeNative:instance tasks:tasks callback:callback]方法。</p><p>第二个闭包函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    [_jsBridge registerCallAddElement:<span style=color:#f92672>^</span>NSInteger(NSString <span style=color:#f92672>*</span>instanceId, NSString <span style=color:#f92672>*</span>parentRef, NSDictionary <span style=color:#f92672>*</span>elementData, NSInteger index) {
        <span style=color:#75715e>// Temporary here , in order to improve performance, will be refactored next version.
</span><span style=color:#75715e></span>        WXSDKInstance <span style=color:#f92672>*</span>instance <span style=color:#f92672>=</span> [WXSDKManager instanceForID:instanceId];
        
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>instance) {
            WXLogInfo(<span style=color:#e6db74>@&#34;instance not found, maybe already destroyed&#34;</span>);
            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
        }
        WXPerformBlockOnComponentThread(<span style=color:#f92672>^</span>{
            WXComponentManager <span style=color:#f92672>*</span>manager <span style=color:#f92672>=</span> instance.componentManager;
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>manager.isValid) {
                <span style=color:#66d9ef>return</span>;
            }
            [manager startComponentTasks];
            [manager addComponent:elementData toSupercomponent:parentRef atIndex:index appendingInTree:NO];
        });
        
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    }];

</code></pre></div><p>这个闭包会被传到下面的函数中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>registerCallAddElement:</span>(WXJSCallAddElement)callAddElement
{
    <span style=color:#66d9ef>id</span> callAddElementBlock <span style=color:#f92672>=</span> <span style=color:#f92672>^</span>(JSValue <span style=color:#f92672>*</span>instanceId, JSValue <span style=color:#f92672>*</span>ref, JSValue <span style=color:#f92672>*</span>element, JSValue <span style=color:#f92672>*</span>index, JSValue <span style=color:#f92672>*</span>ifCallback) {
        
        NSString <span style=color:#f92672>*</span>instanceIdString <span style=color:#f92672>=</span> [instanceId toString];
        NSDictionary <span style=color:#f92672>*</span>componentData <span style=color:#f92672>=</span> [element toDictionary];
        NSString <span style=color:#f92672>*</span>parentRef <span style=color:#f92672>=</span> [ref toString];
        NSInteger insertIndex <span style=color:#f92672>=</span> [[index toNumber] integerValue];
        
         WXLogDebug(<span style=color:#e6db74>@&#34;callAddElement...%@, %@, %@, %ld&#34;</span>, instanceIdString, parentRef, componentData, (<span style=color:#66d9ef>long</span>)insertIndex);
        
        <span style=color:#66d9ef>return</span> [JSValue valueWithInt32:(int32_t)callAddElement(instanceIdString, parentRef, componentData, insertIndex) inContext:[JSContext currentContext]];
    };

    _jsContext[<span style=color:#e6db74>@&#34;callAddElement&#34;</span>] <span style=color:#f92672>=</span> callAddElementBlock;
}

</code></pre></div><p>这里的包装方法和第一个方法是相同的。这里暴露给JS的方法名叫callAddElement，函数参数为4个，分别是instanceIdString，componentData组件的数据，parentRef引用编号，insertIndex插入视图的index。</p><p>当JS调用callAddElement方法，就会最终执行WXBridgeContext类里面的WXPerformBlockOnComponentThread闭包。</p><p>第三个闭包函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

    [_jsBridge registerCallNativeModule:<span style=color:#f92672>^</span>NSInvocation<span style=color:#f92672>*</span>(NSString <span style=color:#f92672>*</span>instanceId, NSString <span style=color:#f92672>*</span>moduleName, NSString <span style=color:#f92672>*</span>methodName, NSArray <span style=color:#f92672>*</span>arguments, NSDictionary <span style=color:#f92672>*</span>options) {
        WXSDKInstance <span style=color:#f92672>*</span>instance <span style=color:#f92672>=</span> [WXSDKManager instanceForID:instanceId];
        
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>instance) {
            WXLogInfo(<span style=color:#e6db74>@&#34;instance not found for callNativeModule:%@.%@, maybe already destroyed&#34;</span>, moduleName, methodName);
            <span style=color:#66d9ef>return</span> nil;
        }
        
        WXModuleMethod <span style=color:#f92672>*</span>method <span style=color:#f92672>=</span> [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];
        <span style=color:#66d9ef>return</span> [method invoke];
    }];


</code></pre></div><p>这个闭包会被传到下面的函数中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>registerCallNativeModule:</span>(WXJSCallNativeModule)callNativeModuleBlock
{
    _jsContext[<span style=color:#e6db74>@&#34;callNativeModule&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>^</span>JSValue <span style=color:#f92672>*</span>(JSValue <span style=color:#f92672>*</span>instanceId, JSValue <span style=color:#f92672>*</span>moduleName, JSValue <span style=color:#f92672>*</span>methodName, JSValue <span style=color:#f92672>*</span>args, JSValue <span style=color:#f92672>*</span>options) {
        NSString <span style=color:#f92672>*</span>instanceIdString <span style=color:#f92672>=</span> [instanceId toString];
        NSString <span style=color:#f92672>*</span>moduleNameString <span style=color:#f92672>=</span> [moduleName toString];
        NSString <span style=color:#f92672>*</span>methodNameString <span style=color:#f92672>=</span> [methodName toString];
        NSArray <span style=color:#f92672>*</span>argsArray <span style=color:#f92672>=</span> [args toArray];
        NSDictionary <span style=color:#f92672>*</span>optionsDic <span style=color:#f92672>=</span> [options toDictionary];
        
        WXLogDebug(<span style=color:#e6db74>@&#34;callNativeModule...%@,%@,%@,%@&#34;</span>, instanceIdString, moduleNameString, methodNameString, argsArray);
        
        NSInvocation <span style=color:#f92672>*</span>invocation <span style=color:#f92672>=</span> callNativeModuleBlock(instanceIdString, moduleNameString, methodNameString, argsArray, optionsDic);
        JSValue <span style=color:#f92672>*</span>returnValue <span style=color:#f92672>=</span> [JSValue wx_valueWithReturnValueFromInvocation:invocation inContext:[JSContext currentContext]];
        <span style=color:#66d9ef>return</span> returnValue;
    };
}


</code></pre></div><p>这里暴露给JS的方法名叫callNativeModule，函数参数为5个，分别是instanceIdString，moduleNameString模块名，methodNameString方法名，argsArray参数数组，optionsDic字典。</p><p>当JS调用callNativeModule方法，就会最终执行WXBridgeContext类里面的WXModuleMethod方法。</p><p>第四个闭包函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

    [_jsBridge registerCallNativeComponent:<span style=color:#f92672>^</span><span style=color:#66d9ef>void</span>(NSString <span style=color:#f92672>*</span>instanceId, NSString <span style=color:#f92672>*</span>componentRef, NSString <span style=color:#f92672>*</span>methodName, NSArray <span style=color:#f92672>*</span>args, NSDictionary <span style=color:#f92672>*</span>options) {
        WXSDKInstance <span style=color:#f92672>*</span>instance <span style=color:#f92672>=</span> [WXSDKManager instanceForID:instanceId];
        WXComponentMethod <span style=color:#f92672>*</span>method <span style=color:#f92672>=</span> [[WXComponentMethod alloc] initWithComponentRef:componentRef methodName:methodName arguments:args instance:instance];
        [method invoke];
    }];

</code></pre></div><p>这个闭包会被传到下面的函数中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>registerCallNativeComponent:</span>(WXJSCallNativeComponent)callNativeComponentBlock
{
    _jsContext[<span style=color:#e6db74>@&#34;callNativeComponent&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>^</span><span style=color:#66d9ef>void</span>(JSValue <span style=color:#f92672>*</span>instanceId, JSValue <span style=color:#f92672>*</span>componentName, JSValue <span style=color:#f92672>*</span>methodName, JSValue <span style=color:#f92672>*</span>args, JSValue <span style=color:#f92672>*</span>options) {
        NSString <span style=color:#f92672>*</span>instanceIdString <span style=color:#f92672>=</span> [instanceId toString];
        NSString <span style=color:#f92672>*</span>componentNameString <span style=color:#f92672>=</span> [componentName toString];
        NSString <span style=color:#f92672>*</span>methodNameString <span style=color:#f92672>=</span> [methodName toString];
        NSArray <span style=color:#f92672>*</span>argsArray <span style=color:#f92672>=</span> [args toArray];
        NSDictionary <span style=color:#f92672>*</span>optionsDic <span style=color:#f92672>=</span> [options toDictionary];
        
        WXLogDebug(<span style=color:#e6db74>@&#34;callNativeComponent...%@,%@,%@,%@&#34;</span>, instanceIdString, componentNameString, methodNameString, argsArray);
        
        callNativeComponentBlock(instanceIdString, componentNameString, methodNameString, argsArray, optionsDic);
    };
}


</code></pre></div><p>这里暴露给JS的方法名叫callNativeComponent，函数参数为5个，分别是instanceIdString，componentNameString组件名，methodNameString方法名，argsArray参数数组，optionsDic字典。</p><p>当JS调用callNativeComponent方法，就会最终执行WXBridgeContext类里面的WXComponentMethod方法。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_52.png alt></p><p>总结一下上述暴露给JS的4个方法：</p><ol><li><p>callNative
这个方法是JS用来调用任意一个Native方法的。</p></li><li><p>callAddElement
这个方法是JS用来给当前页面添加视图元素的。</p></li><li><p>callNativeModule
这个方法是JS用来调用模块里面暴露出来的方法。</p></li><li><p>callNativeComponent
这个方法是JS用来调用组件里面暴露出来的方法。</p></li></ol><p>Weex在布局的时候就只会用到前2个方法。</p><p>####（一）createRoot:</p><p>当JSFramework把JS文件转换类似JSON的文件之后，就开始调用Native的callNative方法。</p><p>callNative方法会最终执行WXBridgeContext类里面的[weakSelf invokeNative:instance tasks:tasks callback:callback]方法。</p><p>当前操作处于子线程“com.taobao.weex.bridge”中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (NSInteger)<span style=color:#a6e22e>invokeNative:</span>(NSString <span style=color:#f92672>*</span>)instanceId <span style=color:#a6e22e>tasks:</span>(NSArray <span style=color:#f92672>*</span>)tasks <span style=color:#a6e22e>callback:</span>(NSString __unused<span style=color:#f92672>*</span>)callback
{
    WXAssertBridgeThread();
    
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>instanceId <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>tasks) {
        WX_MONITOR_FAIL(WXMTNativeRender, WX_ERR_JSFUNC_PARAM, <span style=color:#e6db74>@&#34;JS call Native params error!&#34;</span>);
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    }

    WXSDKInstance <span style=color:#f92672>*</span>instance <span style=color:#f92672>=</span> [WXSDKManager instanceForID:instanceId];
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>instance) {
        WXLogInfo(<span style=color:#e6db74>@&#34;instance already destroyed, task ignored&#34;</span>);
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    }
    

    <span style=color:#75715e>// 根据JS发送过来的方法，进行转换成Native方法调用
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (NSDictionary <span style=color:#f92672>*</span>task <span style=color:#66d9ef>in</span> tasks) {
        NSString <span style=color:#f92672>*</span>methodName <span style=color:#f92672>=</span> task[<span style=color:#e6db74>@&#34;method&#34;</span>];
        NSArray <span style=color:#f92672>*</span>arguments <span style=color:#f92672>=</span> task[<span style=color:#e6db74>@&#34;args&#34;</span>];
        <span style=color:#66d9ef>if</span> (task[<span style=color:#e6db74>@&#34;component&#34;</span>]) {
            NSString <span style=color:#f92672>*</span>ref <span style=color:#f92672>=</span> task[<span style=color:#e6db74>@&#34;ref&#34;</span>];
            WXComponentMethod <span style=color:#f92672>*</span>method <span style=color:#f92672>=</span> [[WXComponentMethod alloc] initWithComponentRef:ref methodName:methodName arguments:arguments instance:instance];
            [method invoke];
        } <span style=color:#66d9ef>else</span> {
            NSString <span style=color:#f92672>*</span>moduleName <span style=color:#f92672>=</span> task[<span style=color:#e6db74>@&#34;module&#34;</span>];
            WXModuleMethod <span style=color:#f92672>*</span>method <span style=color:#f92672>=</span> [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];
            [method invoke];
        }
    }
    
    <span style=color:#75715e>// 如果有回调，回调给JS
</span><span style=color:#75715e></span>    [self performSelector:<span style=color:#66d9ef>@selector</span>(_sendQueueLoop) withObject:nil];
    
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
}


</code></pre></div><p>这里会把JS从发送过来的callNative方法转换成Native的组件component的方法调用或者模块module的方法调用。</p><p>举个例子：</p><p>JS从callNative方法传过来3个参数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
instance:<span style=color:#ae81ff>0</span>,

tasks:(
        {
        args <span style=color:#f92672>=</span>         (
                        {
                attr <span style=color:#f92672>=</span>                 {
                };
                ref <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;_root&#34;</span>;
                style <span style=color:#f92672>=</span>                 {
                    alignItems <span style=color:#f92672>=</span> center;
                };
                type <span style=color:#f92672>=</span> div;
            }
        );
        method <span style=color:#f92672>=</span> createBody;
        module <span style=color:#f92672>=</span> dom;
    }
), 

callback:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>

</code></pre></div><p>tasks数组里面会解析出各个方法和调用者。</p><p>这个例子里面就会解析出Dom模块的createBody方法。</p><p>接着就会调用Dom模块的createBody方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

    <span style=color:#66d9ef>if</span> (isSync) {
        [invocation invoke];
        <span style=color:#66d9ef>return</span> invocation;
    } <span style=color:#66d9ef>else</span> {
        [self _dispatchInvocation:invocation moduleInstance:moduleInstance];
        <span style=color:#66d9ef>return</span> nil;
    }

</code></pre></div><p>调用方法之前，有一个线程切换的步骤。如果是同步方法，那么就直接调用，如果是异步方法，那么嗨需要进行线程转换。</p><p>Dom模块的createBody方法是异步的方法，于是就需要调用_dispatchInvocation: moduleInstance:方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>


- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>_dispatchInvocation:</span>(NSInvocation <span style=color:#f92672>*</span>)invocation <span style=color:#a6e22e>moduleInstance:</span>(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>WXModuleProtocol<span style=color:#f92672>&gt;</span>)moduleInstance
{
    <span style=color:#75715e>// dispatch to user specified queue or thread, default is main thread
</span><span style=color:#75715e></span>    dispatch_block_t dispatchBlock <span style=color:#f92672>=</span> <span style=color:#f92672>^</span> (){
        [invocation invoke];
    };
    
    NSThread <span style=color:#f92672>*</span>targetThread <span style=color:#f92672>=</span> nil;
    dispatch_queue_t targetQueue <span style=color:#f92672>=</span> nil;

    <span style=color:#66d9ef>if</span>([moduleInstance respondsToSelector:<span style=color:#66d9ef>@selector</span>(targetExecuteQueue)]){
        <span style=color:#75715e>// 判断当前是否有Queue，如果没有，就返回main_queue，如果有，就切换到targetQueue
</span><span style=color:#75715e></span>        targetQueue <span style=color:#f92672>=</span> [moduleInstance targetExecuteQueue] <span style=color:#f92672>?:</span> dispatch_get_main_queue();
    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>([moduleInstance respondsToSelector:<span style=color:#66d9ef>@selector</span>(targetExecuteThread)]){
        <span style=color:#75715e>// 判断当前是否有Thread，如果没有，就返回主线程，如果有，就切换到targetThread
</span><span style=color:#75715e></span>        targetThread <span style=color:#f92672>=</span> [moduleInstance targetExecuteThread] <span style=color:#f92672>?:</span> [NSThread mainThread];
    } <span style=color:#66d9ef>else</span> {
        targetThread <span style=color:#f92672>=</span> [NSThread mainThread];
    }

    WXAssert(targetQueue <span style=color:#f92672>||</span> targetThread, <span style=color:#e6db74>@&#34;No queue or thread found for module:%@&#34;</span>, moduleInstance);
    
    <span style=color:#66d9ef>if</span> (targetQueue) {
        dispatch_async(targetQueue, dispatchBlock);
    } <span style=color:#66d9ef>else</span> {
        WXPerformBlockOnThread(<span style=color:#f92672>^</span>{
            dispatchBlock();
        }, targetThread);
    }
}


</code></pre></div><p>在整个Weex模块中，目前只有2个模块是有targetQueue的，一个是WXClipboardModule，另一个是WXStorageModule。所以这里没有targetQueue，就只能切换到对应的targetThread上。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>WXPerformBlockOnThread</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span> _Nonnull block)(), NSThread <span style=color:#f92672>*</span><span style=color:#66d9ef>thread</span>)
{
    [WXUtility performBlock:block onThread:<span style=color:#66d9ef>thread</span>];
}

+ (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>performBlock:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)())block <span style=color:#a6e22e>onThread:</span>(NSThread <span style=color:#f92672>*</span>)thread
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#66d9ef>thread</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>block) <span style=color:#66d9ef>return</span>;
    
    <span style=color:#75715e>// 如果当前线程不是目标线程上，就要切换线程
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ([NSThread currentThread] <span style=color:#f92672>==</span> <span style=color:#66d9ef>thread</span>) {
        block();
    } <span style=color:#66d9ef>else</span> {
        [self performSelector:<span style=color:#66d9ef>@selector</span>(_performBlock:)
                     onThread:<span style=color:#66d9ef>thread</span>
                   withObject:[block <span style=color:#66d9ef>copy</span>]
                waitUntilDone:NO];
    }
}

</code></pre></div><p>这里就是切换线程的操作，如果当前线程不是目标线程，就要切换线程。在目标线程上调用_performBlock:方法，入参还是最初传进来的block闭包。</p><p>切换前线程处于子线程“com.taobao.weex.bridge”中。</p><p>在WXDomModule中调用targetExecuteThread方法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (NSThread <span style=color:#f92672>*</span>)<span style=color:#a6e22e>targetExecuteThread</span>
{
    <span style=color:#66d9ef>return</span> [WXComponentManager componentThread];
}


</code></pre></div><p>切换线程之后，当前线程变成了“com.taobao.weex.component”。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>createBody:</span>(NSDictionary <span style=color:#f92672>*</span>)body
{
    [self performBlockOnComponentManager:<span style=color:#f92672>^</span>(WXComponentManager <span style=color:#f92672>*</span>manager) {
        [manager createRoot:body];
    }];
}


- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>performBlockOnComponentManager:</span>(<span style=color:#66d9ef>void</span>(<span style=color:#f92672>^</span>)(WXComponentManager <span style=color:#f92672>*</span>))block
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>block) {
        <span style=color:#66d9ef>return</span>;
    }
    <span style=color:#66d9ef>__weak</span> <span style=color:#66d9ef>typeof</span>(self) weakSelf <span style=color:#f92672>=</span> self;
    
    WXPerformBlockOnComponentThread(<span style=color:#f92672>^</span>{
        WXComponentManager <span style=color:#f92672>*</span>manager <span style=color:#f92672>=</span> weakSelf.weexInstance.componentManager;
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>manager.isValid) {
            <span style=color:#66d9ef>return</span>;
        }

        <span style=color:#75715e>// 开启组件任务
</span><span style=color:#75715e></span>        [manager startComponentTasks];
        block(manager);
    });
}



</code></pre></div><p>当调用了Dom模块的createBody方法以后，会先调用WXComponentManager的startComponentTasks方法，再调用createRoot:方法。</p><p>这里会初始化一个WXComponentManager。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (WXComponentManager <span style=color:#f92672>*</span>)<span style=color:#a6e22e>componentManager</span>
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>_componentManager) {
        _componentManager <span style=color:#f92672>=</span> [[WXComponentManager alloc] initWithWeexInstance:self];
    }
    
    <span style=color:#66d9ef>return</span> _componentManager;
}


- (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>initWithWeexInstance:</span>(<span style=color:#66d9ef>id</span>)weexInstance
{
    <span style=color:#66d9ef>if</span> (self <span style=color:#f92672>=</span> [self init]) {
        _weexInstance <span style=color:#f92672>=</span> weexInstance;
        
        _indexDict <span style=color:#f92672>=</span> [NSMapTable strongToWeakObjectsMapTable];
        _fixedComponents <span style=color:#f92672>=</span> [NSMutableArray wx_mutableArrayUsingWeakReferences];
        _uiTaskQueue <span style=color:#f92672>=</span> [NSMutableArray array];
        _isValid <span style=color:#f92672>=</span> YES;
        [self _startDisplayLink];
    }
    
    <span style=color:#66d9ef>return</span> self;
}


</code></pre></div><p>WXComponentManager的初始化重点是会开启DisplayLink，它会开启一个runloop。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>_startDisplayLink</span>
{
    WXAssertComponentThread();
    
    <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>_displayLink){
        _displayLink <span style=color:#f92672>=</span> [CADisplayLink displayLinkWithTarget:self selector:<span style=color:#66d9ef>@selector</span>(_handleDisplayLink)];
        [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
    }
}

</code></pre></div><p>displayLink一旦开启，被加入到当前runloop之中，每次runloop循环一次都会执行刷新布局的方法_handleDisplayLink。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>startComponentTasks</span>
{
    [self _awakeDisplayLink];
}

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>_awakeDisplayLink</span>
{
    WXAssertComponentThread();
    <span style=color:#66d9ef>if</span>(_displayLink <span style=color:#f92672>&amp;&amp;</span> _displayLink.paused) {
        _displayLink.paused <span style=color:#f92672>=</span> NO;
    }
}

</code></pre></div><p>WXComponentManager的startComponentTasks方法仅仅是更改了CADisplayLink的paused的状态。CADisplayLink就是用来刷新layout的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>WXComponentManager</span>
{
    <span style=color:#75715e>// 对WXSDKInstance的弱引用
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>__weak</span> WXSDKInstance <span style=color:#f92672>*</span>_weexInstance;
    <span style=color:#75715e>// 当前WXComponentManager是否可用
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>BOOL</span> _isValid;
    
    <span style=color:#75715e>// 是否停止刷新布局
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>BOOL</span> _stopRunning;
    NSUInteger _noTaskTickCount;
    
    <span style=color:#75715e>// access only on component thread
</span><span style=color:#75715e></span>    NSMapTable<span style=color:#f92672>&lt;</span>NSString <span style=color:#f92672>*</span>, WXComponent <span style=color:#f92672>*&gt;</span> <span style=color:#f92672>*</span>_indexDict;
    NSMutableArray<span style=color:#f92672>&lt;</span>dispatch_block_t<span style=color:#f92672>&gt;</span> <span style=color:#f92672>*</span>_uiTaskQueue;
    
    WXComponent <span style=color:#f92672>*</span>_rootComponent;
    NSMutableArray <span style=color:#f92672>*</span>_fixedComponents;
    
    css_node_t <span style=color:#f92672>*</span>_rootCSSNode;
    CADisplayLink <span style=color:#f92672>*</span>_displayLink;
}

</code></pre></div><p>以上就是WXComponentManager的所有属性，可以看出WXComponentManager就是用来处理UI任务的。</p><p>再来看看createRoot:方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>createRoot:</span>(NSDictionary <span style=color:#f92672>*</span>)data
{
    WXAssertComponentThread();
    WXAssertParam(data);
    
    <span style=color:#75715e>// 1.创建WXComponent，作为rootComponent
</span><span style=color:#75715e></span>    _rootComponent <span style=color:#f92672>=</span> [self _buildComponentForData:data];

    <span style=color:#75715e>// 2.初始化css_node_t，作为rootCSSNode
</span><span style=color:#75715e></span>    [self _initRootCSSNode];
    
    <span style=color:#66d9ef>__weak</span> <span style=color:#66d9ef>typeof</span>(self) weakSelf <span style=color:#f92672>=</span> self;
    <span style=color:#75715e>// 3.添加UI任务到uiTaskQueue数组中
</span><span style=color:#75715e></span>    [self _addUITask:<span style=color:#f92672>^</span>{
        <span style=color:#66d9ef>__strong</span> <span style=color:#66d9ef>typeof</span>(self) strongSelf <span style=color:#f92672>=</span> weakSelf;
        strongSelf.weexInstance.rootView.wx_component <span style=color:#f92672>=</span> strongSelf<span style=color:#f92672>-&gt;</span>_rootComponent;
        [strongSelf.weexInstance.rootView addSubview:strongSelf<span style=color:#f92672>-&gt;</span>_rootComponent.view];
    }];
}

</code></pre></div><p>这里干了3件事情:</p><h4 id=1创建wxcomponent>1.创建WXComponent</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (WXComponent <span style=color:#f92672>*</span>)<span style=color:#a6e22e>_buildComponentForData:</span>(NSDictionary <span style=color:#f92672>*</span>)data
{
    NSString <span style=color:#f92672>*</span>ref <span style=color:#f92672>=</span> data[<span style=color:#e6db74>@&#34;ref&#34;</span>];
    NSString <span style=color:#f92672>*</span>type <span style=color:#f92672>=</span> data[<span style=color:#e6db74>@&#34;type&#34;</span>];
    NSDictionary <span style=color:#f92672>*</span>styles <span style=color:#f92672>=</span> data[<span style=color:#e6db74>@&#34;style&#34;</span>];
    NSDictionary <span style=color:#f92672>*</span>attributes <span style=color:#f92672>=</span> data[<span style=color:#e6db74>@&#34;attr&#34;</span>];
    NSArray <span style=color:#f92672>*</span>events <span style=color:#f92672>=</span> data[<span style=color:#e6db74>@&#34;event&#34;</span>];
        
    <span style=color:#66d9ef>Class</span> clazz <span style=color:#f92672>=</span> [WXComponentFactory classWithComponentName:type];
    WXComponent <span style=color:#f92672>*</span>component <span style=color:#f92672>=</span> [[clazz alloc] initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:self.weexInstance];
    WXAssert(component, <span style=color:#e6db74>@&#34;Component build failed for data:%@&#34;</span>, data);
    
    [_indexDict setObject:component forKey:component.ref];
    
    <span style=color:#66d9ef>return</span> component;
}

</code></pre></div><p>这里的入参data是之前的tasks数组。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>initWithRef:</span>(NSString <span style=color:#f92672>*</span>)ref
                       <span style=color:#a6e22e>type:</span>(NSString <span style=color:#f92672>*</span>)type
                     <span style=color:#a6e22e>styles:</span>(NSDictionary <span style=color:#f92672>*</span>)styles
                 <span style=color:#a6e22e>attributes:</span>(NSDictionary <span style=color:#f92672>*</span>)attributes
                     <span style=color:#a6e22e>events:</span>(NSArray <span style=color:#f92672>*</span>)events
               <span style=color:#a6e22e>weexInstance:</span>(WXSDKInstance <span style=color:#f92672>*</span>)weexInstance
{
    <span style=color:#66d9ef>if</span> (self <span style=color:#f92672>=</span> [super init]) {
        pthread_mutexattr_init(<span style=color:#f92672>&amp;</span>_propertMutexAttr);
        pthread_mutexattr_settype(<span style=color:#f92672>&amp;</span>_propertMutexAttr, PTHREAD_MUTEX_RECURSIVE);
        pthread_mutex_init(<span style=color:#f92672>&amp;</span>_propertyMutex, <span style=color:#f92672>&amp;</span>_propertMutexAttr);
        
        _ref <span style=color:#f92672>=</span> ref;
        _type <span style=color:#f92672>=</span> type;
        _weexInstance <span style=color:#f92672>=</span> weexInstance;
        _styles <span style=color:#f92672>=</span> [self parseStyles:styles];
        _attributes <span style=color:#f92672>=</span> attributes <span style=color:#f92672>?</span> [NSMutableDictionary dictionaryWithDictionary:attributes] <span style=color:#f92672>:</span> [NSMutableDictionary dictionary];
        _events <span style=color:#f92672>=</span> events <span style=color:#f92672>?</span> [NSMutableArray arrayWithArray:events] <span style=color:#f92672>:</span> [NSMutableArray array];
        _subcomponents <span style=color:#f92672>=</span> [NSMutableArray array];
        
        _absolutePosition <span style=color:#f92672>=</span> CGPointMake(NAN, NAN);
        
        _isNeedJoinLayoutSystem <span style=color:#f92672>=</span> YES;
        _isLayoutDirty <span style=color:#f92672>=</span> YES;
        _isViewFrameSyncWithCalculated <span style=color:#f92672>=</span> YES;
        
        _async <span style=color:#f92672>=</span> NO;
        
        <span style=color:#75715e>//TODO set indicator style 
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> ([type isEqualToString:<span style=color:#e6db74>@&#34;indicator&#34;</span>]) {
            _styles[<span style=color:#e6db74>@&#34;position&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;absolute&#34;</span>;
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>_styles[<span style=color:#e6db74>@&#34;left&#34;</span>] <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>_styles[<span style=color:#e6db74>@&#34;right&#34;</span>]) {
                _styles[<span style=color:#e6db74>@&#34;left&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>@0.0f</span>;
            }
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>_styles[<span style=color:#e6db74>@&#34;top&#34;</span>] <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>_styles[<span style=color:#e6db74>@&#34;bottom&#34;</span>]) {
                _styles[<span style=color:#e6db74>@&#34;top&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>@0.0f</span>;
            }
        }
        
        <span style=color:#75715e>// 设置NavBar的Style
</span><span style=color:#75715e></span>        [self _setupNavBarWithStyles:_styles attributes:_attributes];
        <span style=color:#75715e>// 根据style初始化cssNode数据结构
</span><span style=color:#75715e></span>        [self _initCSSNodeWithStyles:_styles];
        <span style=color:#75715e>// 根据style初始化View的各个属性
</span><span style=color:#75715e></span>        [self _initViewPropertyWithStyles:_styles];
        <span style=color:#75715e>// 处理Border的圆角，边线宽度，背景颜色等属性
</span><span style=color:#75715e></span>        [self _handleBorders:styles isUpdating:NO];
    }
    
    <span style=color:#66d9ef>return</span> self;
}


</code></pre></div><p>上述函数就是初始化WXComponent的布局的各个属性。这里会用到FlexBox里面的一些计算属性的方法就在_initCSSNodeWithStyles:方法里面。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>_initCSSNodeWithStyles:</span>(NSDictionary <span style=color:#f92672>*</span>)styles
{
    _cssNode <span style=color:#f92672>=</span> new_css_node();
    
    _cssNode<span style=color:#f92672>-&gt;</span>print <span style=color:#f92672>=</span> cssNodePrint;
    _cssNode<span style=color:#f92672>-&gt;</span>get_child <span style=color:#f92672>=</span> cssNodeGetChild;
    _cssNode<span style=color:#f92672>-&gt;</span>is_dirty <span style=color:#f92672>=</span> cssNodeIsDirty;
    <span style=color:#66d9ef>if</span> ([self measureBlock]) {
        _cssNode<span style=color:#f92672>-&gt;</span>measure <span style=color:#f92672>=</span> cssNodeMeasure;
    }
    _cssNode<span style=color:#f92672>-&gt;</span>context <span style=color:#f92672>=</span> (<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)self;
    
    <span style=color:#75715e>// 重新计算_cssNode需要布局的子视图个数
</span><span style=color:#75715e></span>    [self _recomputeCSSNodeChildren];
    <span style=color:#75715e>// 将style各个属性都填充到cssNode数据结构中
</span><span style=color:#75715e></span>    [self _fillCSSNode:styles];
    
    <span style=color:#75715e>// To be in conformity with Android/Web, hopefully remove this in the future.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ([self.ref isEqualToString:WX_SDK_ROOT_REF]) {
        <span style=color:#66d9ef>if</span> (isUndefined(_cssNode<span style=color:#f92672>-&gt;</span>style.dimensions[CSS_HEIGHT]) <span style=color:#f92672>&amp;&amp;</span> self.weexInstance.frame.size.height) {
            _cssNode<span style=color:#f92672>-&gt;</span>style.dimensions[CSS_HEIGHT] <span style=color:#f92672>=</span> self.weexInstance.frame.size.height;
        }
        
        <span style=color:#66d9ef>if</span> (isUndefined(_cssNode<span style=color:#f92672>-&gt;</span>style.dimensions[CSS_WIDTH]) <span style=color:#f92672>&amp;&amp;</span> self.weexInstance.frame.size.width) {
            _cssNode<span style=color:#f92672>-&gt;</span>style.dimensions[CSS_WIDTH] <span style=color:#f92672>=</span> self.weexInstance.frame.size.width;
        }
    }
}

</code></pre></div><p>在_fillCSSNode:方法里面会对FlexBox算法里面定义的各个属性值就行赋值。</p><h4 id=2初始化css_node_t>2.初始化css_node_t</h4><p>在这里，准备开始Layout之前，我们需要先初始化rootCSSNode</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>_initRootCSSNode</span>
{
    _rootCSSNode <span style=color:#f92672>=</span> new_css_node();
    
    <span style=color:#75715e>// 根据页面weexInstance设置rootCSSNode的坐标和宽高尺寸
</span><span style=color:#75715e></span>    [self _applyRootFrame:self.weexInstance.frame toRootCSSNode:_rootCSSNode];
    
    _rootCSSNode<span style=color:#f92672>-&gt;</span>style.flex_wrap <span style=color:#f92672>=</span> CSS_NOWRAP;
    _rootCSSNode<span style=color:#f92672>-&gt;</span>is_dirty <span style=color:#f92672>=</span> rootNodeIsDirty;
    _rootCSSNode<span style=color:#f92672>-&gt;</span>get_child <span style=color:#f92672>=</span> rootNodeGetChild;
    _rootCSSNode<span style=color:#f92672>-&gt;</span>context <span style=color:#f92672>=</span> (<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)(self);
    _rootCSSNode<span style=color:#f92672>-&gt;</span>children_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
}

</code></pre></div><p>在上述方法中，会初始化rootCSSNode的坐标和宽高尺寸。</p><h4 id=3添加ui任务到uitaskqueue数组中>3.添加UI任务到uiTaskQueue数组中</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    [self _addUITask:<span style=color:#f92672>^</span>{
        <span style=color:#66d9ef>__strong</span> <span style=color:#66d9ef>typeof</span>(self) strongSelf <span style=color:#f92672>=</span> weakSelf;
        strongSelf.weexInstance.rootView.wx_component <span style=color:#f92672>=</span> strongSelf<span style=color:#f92672>-&gt;</span>_rootComponent;
        [strongSelf.weexInstance.rootView addSubview:strongSelf<span style=color:#f92672>-&gt;</span>_rootComponent.view];
    }];


</code></pre></div><p>WXComponentManager会把当前的组件以及它对应的View添加到页面Instance的rootView上面的这个任务，添加到uiTaskQueue数组中。</p><p>_rootComponent.view会创建组件对应的WXView，这个是继承自UIView的。所以Weex通过JS代码创建出来的控件都是原生的，都是WXView类型的，实质就是UIView。创建UIView这一步又是回到主线程中执行的。</p><p>最后显示到页面上的工作，是由displayLink的刷新方法在主线程刷新UI显示的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>_handleDisplayLink</span>
{ 
    [self _layoutAndSyncUI];
}

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>_layoutAndSyncUI</span>
{
    <span style=color:#75715e>// Flexbox布局
</span><span style=color:#75715e></span>    [self _layout];
    <span style=color:#66d9ef>if</span>(_uiTaskQueue.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>){
        <span style=color:#75715e>// 同步执行UI任务
</span><span style=color:#75715e></span>        [self _syncUITasks];
        _noTaskTickCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#75715e>// 如果当前一秒内没有任务，那么智能的挂起displaylink，以节约CPU时间
</span><span style=color:#75715e></span>        _noTaskTickCount <span style=color:#f92672>++</span>;
        <span style=color:#66d9ef>if</span> (_noTaskTickCount <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>60</span>) {
            [self _suspendDisplayLink];
        }
    }
}

</code></pre></div><p>_layoutAndSyncUI是布局和刷新UI的核心流程。每次刷新一次，都会先调用Flexbox算法的Layout进行布局，这个布局是在子线程“com.taobao.weex.component”执行的。接着再去查看当前是否有UI任务需要执行，如果有，就切换到主线程进行UI刷新操作。</p><p>这里还会有一个智能的挂起操作。就是判断一秒内如果都没有任务，那么就挂起displaylink，以节约CPU时间。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>_layout</span>
{
    <span style=color:#66d9ef>BOOL</span> needsLayout <span style=color:#f92672>=</span> NO;
    NSEnumerator <span style=color:#f92672>*</span>enumerator <span style=color:#f92672>=</span> [_indexDict objectEnumerator];
    WXComponent <span style=color:#f92672>*</span>component;
    <span style=color:#75715e>// 判断当前是否需要布局，即是判断当前组件的_isLayoutDirty这个BOLL属性值
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> ((component <span style=color:#f92672>=</span> [enumerator nextObject])) {
        <span style=color:#66d9ef>if</span> ([component needsLayout]) {
            needsLayout <span style=color:#f92672>=</span> YES;
            <span style=color:#66d9ef>break</span>;
        }
    }

    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>needsLayout) {
        <span style=color:#66d9ef>return</span>;
    }
    
    <span style=color:#75715e>// Flexbox的算法核心函数
</span><span style=color:#75715e></span>    layoutNode(_rootCSSNode, _rootCSSNode<span style=color:#f92672>-&gt;</span>style.dimensions[CSS_WIDTH], _rootCSSNode<span style=color:#f92672>-&gt;</span>style.dimensions[CSS_HEIGHT], CSS_DIRECTION_INHERIT);
 
    NSMutableSet<span style=color:#f92672>&lt;</span>WXComponent <span style=color:#f92672>*&gt;</span> <span style=color:#f92672>*</span>dirtyComponents <span style=color:#f92672>=</span> [NSMutableSet set];
    [_rootComponent _calculateFrameWithSuperAbsolutePosition:CGPointZero gatherDirtyComponents:dirtyComponents];
    <span style=color:#75715e>// 计算当前weexInstance的rootView.frame，并且重置rootCSSNode的Layout
</span><span style=color:#75715e></span>    [self _calculateRootFrame];
  
    <span style=color:#75715e>// 在每个需要布局的组件之间
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (WXComponent <span style=color:#f92672>*</span>dirtyComponent <span style=color:#66d9ef>in</span> dirtyComponents) {
        [self _addUITask:<span style=color:#f92672>^</span>{
            [dirtyComponent _layoutDidFinish];
        }];
    }
}

</code></pre></div><p>_indexDict里面维护了一张整个页面的布局结构的Map，举个例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

NSMapTable {
[<span style=color:#ae81ff>7</span>] _root <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>&lt;</span>div ref<span style=color:#f92672>=</span>_root<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span>WXView: <span style=color:#ae81ff>0x7fc59a416140</span>; frame <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>; <span style=color:#ae81ff>331.333</span> <span style=color:#ae81ff>331.333</span>); layer <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>WXLayer: <span style=color:#ae81ff>0x608000223180</span><span style=color:#f92672>&gt;&gt;</span>
[<span style=color:#ae81ff>12</span>] <span style=color:#ae81ff>5</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>&lt;</span>image ref<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span>WXImageView: <span style=color:#ae81ff>0x7fc59a724430</span>; baseClass <span style=color:#f92672>=</span> UIImageView; frame <span style=color:#f92672>=</span> (<span style=color:#ae81ff>110.333</span> <span style=color:#ae81ff>192.333</span>; <span style=color:#ae81ff>110.333</span> <span style=color:#ae81ff>110.333</span>); clipsToBounds <span style=color:#f92672>=</span> YES; layer <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>WXLayer: <span style=color:#ae81ff>0x60000002f780</span><span style=color:#f92672>&gt;&gt;</span>
[<span style=color:#ae81ff>13</span>] <span style=color:#ae81ff>3</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>&lt;</span>image ref<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span>WXImageView: <span style=color:#ae81ff>0x7fc59a617a00</span>; baseClass <span style=color:#f92672>=</span> UIImageView; frame <span style=color:#f92672>=</span> (<span style=color:#ae81ff>110.333</span> <span style=color:#ae81ff>55.3333</span>; <span style=color:#ae81ff>110.333</span> <span style=color:#ae81ff>110.333</span>); clipsToBounds <span style=color:#f92672>=</span> YES; opaque <span style=color:#f92672>=</span> NO; gestureRecognizers <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>NSArray: <span style=color:#ae81ff>0x60000024b760</span><span style=color:#f92672>&gt;</span>; layer <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>WXLayer: <span style=color:#ae81ff>0x60000003e8c0</span><span style=color:#f92672>&gt;&gt;</span>
[<span style=color:#ae81ff>15</span>] <span style=color:#ae81ff>4</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>&lt;</span>text ref<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span>WXText: <span style=color:#ae81ff>0x7fc59a509840</span>; text: hello Weex; frame:<span style=color:#ae81ff>0.000000</span>,<span style=color:#ae81ff>441.666667</span>,<span style=color:#ae81ff>331.333333</span>,<span style=color:#ae81ff>26.666667</span> frame <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>441.667</span>; <span style=color:#ae81ff>331.333</span> <span style=color:#ae81ff>26.6667</span>); opaque <span style=color:#f92672>=</span> NO; layer <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>WXLayer: <span style=color:#ae81ff>0x608000223480</span><span style=color:#f92672>&gt;&gt;</span>
}



</code></pre></div><p>所有的组件都是由ref引用值作为Key存储的，只要知道这个页面上全局唯一的ref，就可以拿到这个ref对应的组件。</p><p>_layout会先判断当前是否有需要布局的组件，如果有，就从rootCSSNode开始进行Flexbox算法的Layout。执行完成以后还需要调整一次rootView的frame，最后添加一个UI任务到taskQueue中，这个任务标记的是组件布局完成。</p><p>注意上述所有布局操作都是在子线程“com.taobao.weex.component”中执行的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>_syncUITasks</span>
{
    <span style=color:#75715e>// 用blocks接收原来uiTaskQueue里面的所有任务
</span><span style=color:#75715e></span>    NSArray<span style=color:#f92672>&lt;</span>dispatch_block_t<span style=color:#f92672>&gt;</span> <span style=color:#f92672>*</span>blocks <span style=color:#f92672>=</span> _uiTaskQueue;
    <span style=color:#75715e>// 清空uiTaskQueue
</span><span style=color:#75715e></span>    _uiTaskQueue <span style=color:#f92672>=</span> [NSMutableArray array];
    <span style=color:#75715e>// 在主线程中依次执行uiTaskQueue里面的所有闭包
</span><span style=color:#75715e></span>    dispatch_async(dispatch_get_main_queue(), <span style=color:#f92672>^</span>{
        <span style=color:#66d9ef>for</span>(dispatch_block_t block <span style=color:#66d9ef>in</span> blocks) {
            block();
        }
    });
}


</code></pre></div><p>布局完成以后就调用同步的UI刷新方法。注意这里要对UI进行操作，一定要切换回主线程。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_53_.png alt></p><p>####（二）callAddElement</p><p>在子线程“com.taobao.weex.bridge”中，会一直相应来自JSFramework调用Native的方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    [_jsBridge registerCallAddElement:<span style=color:#f92672>^</span>NSInteger(NSString <span style=color:#f92672>*</span>instanceId, NSString <span style=color:#f92672>*</span>parentRef, NSDictionary <span style=color:#f92672>*</span>elementData, NSInteger index) {
        <span style=color:#75715e>// Temporary here , in order to improve performance, will be refactored next version.
</span><span style=color:#75715e></span>        WXSDKInstance <span style=color:#f92672>*</span>instance <span style=color:#f92672>=</span> [WXSDKManager instanceForID:instanceId];
        
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>instance) {
            WXLogInfo(<span style=color:#e6db74>@&#34;instance not found, maybe already destroyed&#34;</span>);
            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
        }
        
        WXPerformBlockOnComponentThread(<span style=color:#f92672>^</span>{
            WXComponentManager <span style=color:#f92672>*</span>manager <span style=color:#f92672>=</span> instance.componentManager;
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>manager.isValid) {
                <span style=color:#66d9ef>return</span>;
            }
            [manager startComponentTasks];
            [manager addComponent:elementData toSupercomponent:parentRef atIndex:index appendingInTree:NO];
        });
        
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    }];


</code></pre></div><p>当JSFramework调用callAddElement方法，就会执行上述代码的闭包函数。这里会接收来自JS的4个入参。</p><p>举个例子，JSFramework可能会通过callAddElement方法传过来这样4个参数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#ae81ff>0</span>,
_root, 
{
    attr <span style=color:#f92672>=</span>     {
        value <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello World&#34;</span>;
    };
    ref <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
    style <span style=color:#f92672>=</span>     {
        color <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;#000000&#34;</span>;
        fontSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>40</span>;
    };
    type <span style=color:#f92672>=</span> text;
}, 
<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>


</code></pre></div><p>这里的insertIndex为0，parentRef是_root，componentData是当前要创建的组件的信息，instanceIdString是-1。</p><p>之后WXComponentManager就会调用startComponentTasks开始displaylink继续准备刷新布局，最后调用addComponent: toSupercomponent: atIndex: appendingInTree:方法添加新的组件。</p><p>注意，WXComponentManager的这两步操作，又要切换线程，切换到“com.taobao.weex.component”子线程中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>addComponent:</span>(NSDictionary <span style=color:#f92672>*</span>)componentData <span style=color:#a6e22e>toSupercomponent:</span>(NSString <span style=color:#f92672>*</span>)superRef <span style=color:#a6e22e>atIndex:</span>(NSInteger)index <span style=color:#a6e22e>appendingInTree:</span>(<span style=color:#66d9ef>BOOL</span>)appendingInTree
{
    WXComponent <span style=color:#f92672>*</span>supercomponent <span style=color:#f92672>=</span> [_indexDict objectForKey:superRef];
    WXAssertComponentExist(supercomponent);
    
    [self _recursivelyAddComponent:componentData toSupercomponent:supercomponent atIndex:index appendingInTree:appendingInTree];
}

</code></pre></div><p>WXComponentManager会在“com.taobao.weex.component”子线程中递归的添加子组件。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>_recursivelyAddComponent:</span>(NSDictionary <span style=color:#f92672>*</span>)componentData <span style=color:#a6e22e>toSupercomponent:</span>(WXComponent <span style=color:#f92672>*</span>)supercomponent <span style=color:#a6e22e>atIndex:</span>(NSInteger)index <span style=color:#a6e22e>appendingInTree:</span>(<span style=color:#66d9ef>BOOL</span>)appendingInTree
{

   <span style=color:#75715e>// 根据componentData构建组件
</span><span style=color:#75715e></span>    WXComponent <span style=color:#f92672>*</span>component <span style=color:#f92672>=</span> [self _buildComponentForData:componentData];
    
    index <span style=color:#f92672>=</span> (index <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>?</span> supercomponent<span style=color:#f92672>-&gt;</span>_subcomponents.count : index);
    
    [supercomponent _insertSubcomponent:component atIndex:index];
    <span style=color:#75715e>// 用_lazyCreateView标识懒加载
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(supercomponent <span style=color:#f92672>&amp;&amp;</span> component <span style=color:#f92672>&amp;&amp;</span> supercomponent<span style=color:#f92672>-&gt;</span>_lazyCreateView) {
        component<span style=color:#f92672>-&gt;</span>_lazyCreateView <span style=color:#f92672>=</span> YES;
    }
    
    <span style=color:#75715e>// 插入一个UI任务
</span><span style=color:#75715e></span>    [self _addUITask:<span style=color:#f92672>^</span>{
        [supercomponent insertSubview:component atIndex:index];
    }];

    NSArray <span style=color:#f92672>*</span>subcomponentsData <span style=color:#f92672>=</span> [componentData valueForKey:<span style=color:#e6db74>@&#34;children&#34;</span>];
    
    <span style=color:#66d9ef>BOOL</span> appendTree <span style=color:#f92672>=</span> <span style=color:#f92672>!</span>appendingInTree <span style=color:#f92672>&amp;&amp;</span> [component.attributes[<span style=color:#e6db74>@&#34;append&#34;</span>] isEqualToString:<span style=color:#e6db74>@&#34;tree&#34;</span>];
    <span style=color:#75715e>// 再次递归的规则：如果父视图是一个树状结构，子视图即使也是一个树状结构，也不能再次Layout
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(NSDictionary <span style=color:#f92672>*</span>subcomponentData <span style=color:#66d9ef>in</span> subcomponentsData){
        [self _recursivelyAddComponent:subcomponentData toSupercomponent:component atIndex:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> appendingInTree:appendTree <span style=color:#f92672>||</span> appendingInTree];
    }
    <span style=color:#66d9ef>if</span> (appendTree) {
        <span style=color:#75715e>// 如果当前组件是树状结构，强制刷新layout，以防在syncQueue中堆积太多的同步任务。
</span><span style=color:#75715e></span>        [self _layoutAndSyncUI];
    }
}


</code></pre></div><p>在递归的添加子组件的时候，如果是树状结构，还需要再次强制进行一次layout，同步一次UI。这里调用[self _layoutAndSyncUI]方法和createRoot:时候实现是完全一样的，下面就不再赘述了。</p><p>这里会循环添加多个子视图，相应的也会调用多次Layout方法。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_54_.png alt></p><h4 id=三createfinish>（三）createFinish</h4><p>当所有的视图都添加完成以后，JSFramework就是再次调用callNative方法。</p><p>还是会传过来3个参数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

instance:<span style=color:#ae81ff>0</span>, 
tasks:(
        {
        args <span style=color:#f92672>=</span>         (
        );
        method <span style=color:#f92672>=</span> createFinish;
        module <span style=color:#f92672>=</span> dom;
    }
), 
callback:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>

</code></pre></div><p>callNative通过这个参数会调用到WXDomModule的createFinish方法。这里的具体实现见第一步的callNative，这里不再赘述。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>createFinish</span>
{
    [self performBlockOnComponentManager:<span style=color:#f92672>^</span>(WXComponentManager <span style=color:#f92672>*</span>manager) {
        [manager createFinish];
    }];
}


</code></pre></div><p>这里最终也是会调用到WXComponentManager的createFinish。当然这里是会进行线程切换，切换到WXComponentManager的线程“com.taobao.weex.component”子线程上。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>createFinish</span>
{
    WXAssertComponentThread();
    
    WXSDKInstance <span style=color:#f92672>*</span>instance  <span style=color:#f92672>=</span> self.weexInstance;
    [self _addUITask:<span style=color:#f92672>^</span>{        
        UIView <span style=color:#f92672>*</span>rootView <span style=color:#f92672>=</span> instance.rootView;
        
        WX_MONITOR_INSTANCE_PERF_END(WXPTFirstScreenRender, instance);
        WX_MONITOR_INSTANCE_PERF_END(WXPTAllRender, instance);
        WX_MONITOR_SUCCESS(WXMTJSBridge);
        WX_MONITOR_SUCCESS(WXMTNativeRender);
        
        <span style=color:#66d9ef>if</span>(instance.renderFinish){
            instance.renderFinish(rootView);
        }
    }];
}


</code></pre></div><p>WXComponentManager的createFinish方法最后就是添加一个UI任务，回调到主线程的renderFinish方法里面。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_55_.png alt></p><p>至此，Weex的布局流程就完成了。</p><h3 id=最后>最后</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/43_56.png alt></p><p>虽然Autolayout是苹果原生就支持的自动布局方案，但是在稍微复杂的界面就会出现性能问题。大半年前，Draveness的这篇<a href=http://draveness.me/layout-performance/>《从 Auto Layout 的布局算法谈性能》</a>文章里面也稍微“批判”了Autolayout的性能问题，但是文章里面最后提到的是用ASDK的方法来解决问题。本篇文章则献上另外一种可用的布局方法——FlexBox，并且带上了经过大量测试的测试数据，向大左的这篇经典文章致敬！</p><p>如今，iOS平台上几大可用的布局方法有：Frame原生布局，Autolayout原生自动布局，FlexBox的Yoga实现，ASDK。</p><p>当然，基于这4种基本方案以外，还有一些组合方法，比如Weex的这种，用JS的CSS解析成类似JSON的DOM，再调用Native的FlexBox算法进行布局。前段时间还有来自美团的<a href=http://tech.meituan.com/the_future_of_layout.html>《布局编码的未来》</a>里面提到的毕加索（picasso）布局方法。原理也是会用到JSCore，将JS写的JSON或者自定义的DSL，经过本地的picassoEngine布局引擎转换成Native布局，最终利用锚点的概念做到高效的布局。</p><p>最后，推荐2个iOS平台上比较优秀的利用了FlexBox的原理的开源库：</p><p>来自Facebook的**<a href=https://github.com/facebook/yoga>yoga</a>**<br>来自饿了么的**<a href=https://github.com/LPD-iOS/FlexBoxLayout>FlexBoxLayout</a>**</p><img src=https://img.halfrost.com/wechat-qr-code.png></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div id=toc-footer style=display:none><nav id=TableOfContents><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#目录>目录</a></li><li><a href=#一-weex布局算法>一. Weex布局算法</a><ul><li><a href=#一flexbox中的基本数据结构>（一）FlexBox中的基本数据结构</a></li><li><a href=#1align_items>1.align_items</a></li><li><a href=#2-align_content>2. align_content</a></li><li><a href=#3align_self>3.align_self</a></li><li><a href=#二flexbox中的布局算法>（二）FlexBox中的布局算法</a></li></ul></li><li><a href=#二-weex布局算法性能分析>二. Weex布局算法性能分析</a><ul><li><a href=#1算法实现分析>1.算法实现分析</a></li><li><a href=#2算法性能测试准备工作>2.算法性能测试准备工作</a></li><li><a href=#3算法性能测试结果>3.算法性能测试结果</a></li></ul></li><li><a href=#三-weex是如何布局原生界面的>三. Weex是如何布局原生界面的</a><ul><li><a href=#1创建wxcomponent>1.创建WXComponent</a></li><li><a href=#2初始化css_node_t>2.初始化css_node_t</a></li><li><a href=#3添加ui任务到uitaskqueue数组中>3.添加UI任务到uiTaskQueue数组中</a></li><li><a href=#三createfinish>（三）createFinish</a></li></ul></li><li><a href=#最后>最后</a></li></ul></li></ul></nav></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f"><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&text=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&title=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&is_video=false&description=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f"><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&title=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&title=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&title=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-stumbleupon fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&title=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-digg fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&name=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e&description=%e5%89%8d%e8%a8%80%20%e5%9c%a8%e4%b8%8a%e7%af%87%e6%96%87%e7%ab%a0%e9%87%8c%e9%9d%a2%e8%b0%88%e4%ba%86Weex%e5%9c%a8iOS%e5%ae%a2%e6%88%b7%e7%ab%af%e5%b7%a5%e4%bd%9c%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%b5%81%e7%a8%8b%e3%80%82%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e5%b0%86%e4%bc%9a%e8%af%a6%e7%bb%86%e7%9a%84%e5%88%86%e6%9e%90Weex%e6%98%af%e5%a6%82%e4%bd%95%e9%ab%98%e6%80%a7%e8%83%bd%e7%9a%84%e5%b8%83%e5%b1%80%e5%8e%9f%e7%94%9f%e7%95%8c%e9%9d%a2%e7%9a%84%ef%bc%8c%e4%b9%8b%e5%90%8e%e8%bf%98%e4%bc%9a%e4%b8%8e%e7%8e%b0%e6%9c%89%e7%9a%84%e5%b8%83%e5%b1%80%e6%96%b9%e6%b3%95%e8%bf%9b%e8%a1%8c%e5%af%b9%e6%af%94%ef%bc%8c%e7%9c%8b%e7%9c%8bWeex%e7%9a%84%e5%b8%83%e5%b1%80%e6%80%a7%e8%83%bd%e7%a9%b6%e7%ab%9f%e5%a6%82%e4%bd%95%e3%80%82%0a%e7%9b%ae%e5%bd%95%20%201.Weex%e5%b8%83%e5%b1%80%e7%ae%97%e6%b3%95%202.Weex%e5%b8%83%e5%b1%80%e7%ae%97%e6%b3%95%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%203.Weex%e6%98%af%e5%a6%82%e4%bd%95%e5%b8%83%e5%b1%80%e5%8e%9f%e7%94%9f%e7%95%8c%e9%9d%a2%e7%9a%84%20%20%e4%b8%80.%20Weex%e5%b8%83%e5%b1%80%e7%ae%97%e6%b3%95%20%e6%89%93%e5%bc%80Weex%e7%9a%84%e6%ba%90%e7%a0%81%e7%9a%84Layout%e6%96%87%e4%bb%b6%e5%a4%b9%ef%bc%8c%e5%b0%b1%e4%bc%9a%e7%9c%8b%e5%88%b0%e4%b8%a4%e4%b8%aac%e7%9a%84%e6%96%87%e4%bb%b6%ef%bc%8c%e8%bf%99%e4%b8%a4%e4%b8%aa%e6%96%87%e4%bb%b6%e5%b0%b1%e6%98%af%e4%bb%8a%e5%a4%a9%e8%a6%81%e8%b0%88%e7%9a%84Weex%e7%9a%84%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e%e3%80%82%0aLayout.h%e5%92%8cLayout.c%e6%9c%80%e5%bc%80%e5%a7%8b%e6%98%af%e6%9d%a5%e8%87%aa%e4%ba%8eReact-Native%e9%87%8c%e9%9d%a2%e7%9a%84%e4%bb%a3%e7%a0%81%e3%80%82%e4%b9%9f%e5%b0%b1%e6%98%af%e8%af%b4Weex%e5%92%8cReact-Native%e7%9a%84%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e%e9%83%bd%e6%98%af%e5%90%8c%e4%b8%80%e5%a5%97%e4%bb%a3%e7%a0%81%e3%80%82%0a%e5%bd%93%e5%89%8dReact-Native%e7%9a%84%e4%bb%a3%e7%a0%81%e9%87%8c%e9%9d%a2%e5%b7%b2%e7%bb%8f%e6%b2%a1%e6%9c%89%e8%bf%99%e4%b8%a4%e4%b8%aa%e6%96%87%e4%bb%b6%e4%ba%86%ef%bc%8c%e8%80%8c%e6%98%af%e6%8d%a2%e6%88%90%e4%ba%86Yoga%e3%80%82%0aYoga%e6%9c%ac%e6%98%afFacebook%e5%9c%a8React%20Native%e9%87%8c%e5%bc%95%e5%85%a5%e7%9a%84%e4%b8%80%e7%a7%8d%e8%b7%a8%e5%b9%b3%e5%8f%b0%e7%9a%84%e5%9f%ba%e4%ba%8eCSS%e7%9a%84%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e%ef%bc%8c%e5%ae%83%e5%ae%9e%e7%8e%b0%e4%ba%86Flexbox%e8%a7%84%e8%8c%83%ef%bc%8c%e5%ae%8c%e5%85%a8%e9%81%b5%e5%ae%88W3C%e7%9a%84%e8%a7%84%e8%8c%83%e3%80%82%e9%9a%8f%e7%9d%80%e8%af%a5%e7%b3%bb%e7%bb%9f%e4%b8%8d%e6%96%ad%e5%ae%8c%e5%96%84%ef%bc%8cFacebook%e5%af%b9%e5%85%b6%e8%bf%9b%e8%a1%8c%e9%87%8d%e6%96%b0%e5%8f%91%e5%b8%83%ef%bc%8c%e4%ba%8e%e6%98%af%e5%b0%b1%e6%88%90%e4%ba%86%e7%8e%b0%e5%9c%a8%e7%9a%84Yoga%28Yoga%e5%ae%98%e7%bd%91%29%e3%80%82%0a%e9%82%a3%e4%b9%88Flexbox%e6%98%af%e4%bb%80%e4%b9%88%e5%91%a2%ef%bc%9f%0a%e7%86%9f%e6%82%89%e5%89%8d%e7%ab%af%e7%9a%84%e5%90%8c%e5%ad%a6%e4%b8%80%e5%ae%9a%e5%be%88%e7%86%9f%e6%82%89%e8%bf%99%e4%b8%aa%e6%a6%82%e5%bf%b5%e3%80%822009%e5%b9%b4%ef%bc%8cW3C%e6%8f%90%e5%87%ba%e4%ba%86%e4%b8%80%e7%a7%8d%e6%96%b0%e7%9a%84%e6%96%b9%e6%a1%88%e2%80%94%e2%80%94Flex%e5%b8%83%e5%b1%80%ef%bc%8c%e5%8f%af%e4%bb%a5%e7%ae%80%e4%be%bf%e3%80%81%e5%ae%8c%e6%95%b4%e3%80%81%e5%93%8d%e5%ba%94%e5%bc%8f%e5%9c%b0%e5%ae%9e%e7%8e%b0%e5%90%84%e7%a7%8d%e9%a1%b5%e9%9d%a2%e5%b8%83%e5%b1%80%e3%80%82%e7%9b%ae%e5%89%8d%ef%bc%8c%e5%ae%83%e5%b7%b2%e7%bb%8f%e5%be%97%e5%88%b0%e4%ba%86%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e6%b5%8f%e8%a7%88%e5%99%a8%e7%9a%84%e6%94%af%e6%8c%81%ef%bc%8c%e7%9b%ae%e5%89%8d%e7%9a%84%e5%89%8d%e7%ab%af%e4%b8%bb%e8%a6%81%e6%98%af%e4%bd%bf%e7%94%a8Html%20%2f%20CSS%20%2f%20JS%e5%ae%9e%e7%8e%b0%ef%bc%8c%e5%85%b6%e4%b8%adCSS%e7%94%a8%e4%ba%8e%e5%89%8d%e7%ab%af%e7%9a%84%e5%b8%83%e5%b1%80%e3%80%82%e4%bb%bb%e4%bd%95%e4%b8%80%e4%b8%aaHtml%e7%9a%84%e5%ae%b9%e5%99%a8%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87css%e6%8c%87%e5%ae%9a%e4%b8%baFlex%e5%b8%83%e5%b1%80%ef%bc%8c%e4%b8%80%e6%97%a6%e4%b8%80%e4%b8%aa%e5%ae%b9%e5%99%a8%e8%a2%ab%e6%8c%87%e5%ae%9a%e4%b8%baFlex%e5%b8%83%e5%b1%80%ef%bc%8c%e5%85%b6%e5%ad%90%e5%85%83%e7%b4%a0%e5%b0%b1%e5%8f%af%e4%bb%a5%e6%8c%89%e7%85%a7FlexBox%e7%9a%84%e8%af%ad%e6%b3%95%e8%bf%9b%e8%a1%8c%e5%b8%83%e5%b1%80%e3%80%82%0a%e5%85%b3%e4%ba%8eFlexBox%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9a%e4%b9%89%ef%bc%8c%e6%9b%b4%e5%8a%a0%e8%af%a6%e7%bb%86%e7%9a%84%e6%96%87%e6%a1%a3%e8%af%b4%e6%98%8e%ef%bc%8c%e6%84%9f%e5%85%b4%e8%b6%a3%e7%9a%84%e5%90%8c%e5%ad%a6%e5%8f%af%e4%bb%a5%e5%8e%bb%e9%98%85%e8%af%bb%e4%b8%80%e4%b8%8bW3C%e7%9a%84%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%ef%bc%8c%e9%82%a3%e9%87%8c%e4%bc%9a%e6%9c%89%e5%be%88%e8%af%a6%e7%bb%86%e7%9a%84%e8%af%b4%e6%98%8e%e3%80%82%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%e9%93%be%e6%8e%a5%0aWeex%e4%b8%ad%e7%9a%84Layout%e6%96%87%e4%bb%b6%e6%98%afYoga%e7%9a%84%e5%89%8d%e8%ba%ab%ef%bc%8c%e6%98%afYoga%e6%ad%a3%e5%bc%8f%e5%8f%91%e5%b8%83%e4%b9%8b%e5%89%8d%e7%9a%84%e7%89%88%e6%9c%ac%e3%80%82%e5%ba%95%e5%b1%82%e4%bb%a3%e7%a0%81%e4%bd%bf%e7%94%a8C%e8%af%ad%e8%a8%80%e4%bb%a3%e7%a0%81%ef%bc%8c%e6%89%80%e4%bb%a5%e6%80%a7%e8%83%bd%e4%b9%9f%e4%b8%8d%e6%98%af%e9%97%ae%e9%a2%98%e3%80%82%e6%8e%a5%e4%b8%8b%e6%9d%a5%e5%b0%b1%e4%bb%94%e7%bb%86%e5%88%86%e6%9e%90Layout%e6%96%87%e4%bb%b6%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0FlexBox%e7%9a%84%e3%80%82%0a%e6%95%85%e4%bb%a5%e4%b8%8b%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e9%83%bd%e5%9f%ba%e4%ba%8ev0.10.0%e8%bf%99%e4%b8%aa%e7%89%88%e6%9c%ac%e3%80%82%0a%ef%bc%88%e4%b8%80%ef%bc%89FlexBox%e4%b8%ad%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%20Flexbox%e5%b8%83%e5%b1%80%ef%bc%88Flexible%20Box%29%e8%ae%be%e8%ae%a1%e4%b9%8b%e5%88%9d%e7%9a%84%e7%9b%ae%e7%9a%84%e6%98%af%e4%b8%ba%e4%ba%86%e8%83%bd%e6%9b%b4%e5%8a%a0%e9%ab%98%e6%95%88%e7%9a%84%e5%88%86%e9%85%8d%e5%ad%90%e8%a7%86%e5%9b%be%e7%9a%84%e5%b8%83%e5%b1%80%e6%83%85%e5%86%b5%ef%bc%8c%e5%8c%85%e6%8b%ac%e5%8a%a8%e6%80%81%e7%9a%84%e6%94%b9%e5%8f%98%e5%ae%bd%e5%ba%a6%ef%bc%8c%e9%ab%98%e5%ba%a6%ef%bc%8c%e4%bb%a5%e5%8f%8a%e6%8e%92%e5%88%97%e9%a1%ba%e5%ba%8f%e3%80%82Flexbox%e5%8f%af%e4%bb%a5%e6%9b%b4%e5%8a%a0%e6%96%b9%e4%be%bf%e7%9a%84%e5%85%bc%e5%ae%b9%e5%90%84%e4%b8%aa%e5%a4%a7%e5%b0%8f%e4%b8%8d%e5%90%8c%e7%9a%84%e5%b1%8f%e5%b9%95%ef%bc%8c%e6%af%94%e5%a6%82%e6%8b%89%e4%bc%b8%e5%92%8c%e5%8e%8b%e7%bc%a9%e5%ad%90%e8%a7%86%e5%9b%be%e3%80%82%0a%e5%9c%a8FlexBox%e7%9a%84%e4%b8%96%e7%95%8c%e9%87%8c%ef%bc%8c%e5%ad%98%e5%9c%a8%e7%9d%80%e4%b8%bb%e8%bd%b4%e5%92%8c%e4%be%a7%e8%bd%b4%e7%9a%84%e6%a6%82%e5%bf%b5%e3%80%82%0a%e5%a4%a7%e5%a4%9a%e6%95%b0%e6%83%85%e5%86%b5%ef%bc%8c%e5%ad%90%e8%a7%86%e5%9b%be%e9%83%bd%e6%98%af%e6%b2%bf%e7%9d%80%e4%b8%bb%e8%bd%b4%ef%bc%88main%20axis%ef%bc%89%ef%bc%8c%e4%bb%8e%e4%b8%bb%e8%bd%b4%e8%b5%b7%e7%82%b9%ef%bc%88main-start%ef%bc%89%e5%88%b0%e4%b8%bb%e8%bd%b4%e7%bb%88%e7%82%b9%ef%bc%88main-end%ef%bc%89%e6%8e%92%e5%88%97%e3%80%82%e4%bd%86%e6%98%af%e8%bf%99%e9%87%8c%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e4%b8%80%e7%82%b9%e6%98%af%ef%bc%8c%e4%b8%bb%e8%bd%b4%e5%92%8c%e4%be%a7%e8%bd%b4%e8%99%bd%e7%84%b6%e6%b0%b8%e8%bf%9c%e6%98%af%e5%9e%82%e7%9b%b4%e7%9a%84%e5%85%b3%e7%b3%bb%ef%bc%8c%e4%bd%86%e6%98%af%e8%b0%81%e6%98%af%e6%b0%b4%e5%b9%b3%ef%bc%8c%e8%b0%81%e6%98%af%e7%ab%96%e7%9b%b4%ef%bc%8c%e5%b9%b6%e6%b2%a1%e6%9c%89%e7%a1%ae%e5%ae%9a%ef%bc%8c%e6%9c%89%e5%8f%af%e8%83%bd%e4%bc%9a%e6%9c%89%e5%a6%82%e4%b8%8b%e7%9a%84%e6%83%85%e5%86%b5%ef%bc%9a%0a%e5%9c%a8%e4%b8%8a%e5%9b%be%e8%bf%99%e7%a7%8d%e6%b0%b4%e5%b9%b3%e6%98%af%e4%be%a7%e8%bd%b4%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%ef%bc%8c%e5%ad%90%e8%a7%86%e5%9b%be%e6%98%af%e6%b2%bf%e7%9d%80%e4%be%a7%e8%bd%b4%ef%bc%88cross%20axis%ef%bc%89%ef%bc%8c%e4%bb%8e%e4%be%a7%e8%bd%b4%e8%b5%b7%e7%82%b9%ef%bc%88cross-start%ef%bc%89%e5%88%b0%e4%be%a7%e8%bd%b4%e7%bb%88%e7%82%b9%ef%bc%88cross-end%ef%bc%89%e6%8e%92%e5%88%97%e7%9a%84%e3%80%82%0a%2a%2a%e4%b8%bb%e8%bd%b4%ef%bc%88main%20axis%ef%bc%89%ef%bc%9a%2a%2a%e7%88%b6%e8%a7%86%e5%9b%be%e7%9a%84%e4%b8%bb%e8%bd%b4%ef%bc%8c%e5%ad%90%e8%a7%86%e5%9b%be%e4%b8%bb%e8%a6%81%e6%b2%bf%e7%9d%80%e8%bf%99%e6%9d%a1%e8%bd%b4%e8%bf%9b%e8%a1%8c%e6%8e%92%e5%88%97%e5%b8%83%e5%b1%80%e3%80%82%0a%2a%2a%e4%b8%bb%e8%bd%b4%e8%b5%b7%e7%82%b9%ef%bc%88main-start%ef%bc%89%e5%92%8c%e4%b8%bb%e8%bd%b4%e7%bb%88%e7%82%b9%ef%bc%88main-end%ef%bc%89%ef%bc%9a%2a%2a%e5%ad%90%e8%a7%86%e5%9b%be%e5%9c%a8%e7%88%b6%e8%a7%86%e5%9b%be%e9%87%8c%e9%9d%a2%e5%b8%83%e5%b1%80%e7%9a%84%e6%96%b9%e5%90%91%e6%98%af%e4%bb%8e%e4%b8%bb%e8%bd%b4%e8%b5%b7%e7%82%b9%ef%bc%88main-start%ef%bc%89%e5%90%91%e4%b8%bb%e8%bd%b4%e7%bb%88%e7%82%b9%ef%bc%88main-start%ef%bc%89%e7%9a%84%e6%96%b9%e5%90%91%e3%80%82%0a%2a%2a%e4%b8%bb%e8%bd%b4%e5%b0%ba%e5%af%b8%ef%bc%88main%20size%ef%bc%89%ef%bc%9a%2a%2a%e5%ad%90%e8%a7%86%e5%9b%be%e5%9c%a8%e4%b8%bb%e8%bd%b4%e6%96%b9%e5%90%91%e7%9a%84%e5%ae%bd%e5%ba%a6%e6%88%96%e9%ab%98%e5%ba%a6%e5%b0%b1%e6%98%af%e4%b8%bb%e8%bd%b4%e7%9a%84%e5%b0%ba%e5%af%b8%e3%80%82%e5%ad%90%e8%a7%86%e5%9b%be%e4%b8%bb%e8%a6%81%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%b1%9e%e6%80%a7%e8%a6%81%e4%b9%88%e6%98%af%e5%ae%bd%e5%ba%a6%ef%bc%8c%e8%a6%81%e4%b9%88%e6%98%af%e9%ab%98%e5%ba%a6%e5%b1%9e%e6%80%a7%ef%bc%8c%e7%94%b1%e5%93%aa%e4%b8%80%e4%b8%aa%e5%af%b9%e7%9d%80%e4%b8%bb%e8%bd%b4%e6%96%b9%e5%90%91%e5%86%b3%e5%ae%9a%e3%80%82%0a%2a%2a%e4%be%a7%e8%bd%b4%ef%bc%88cross%20axis%ef%bc%89%ef%bc%9a%2a%2a%e5%9e%82%e7%9b%b4%e4%ba%8e%e4%b8%bb%e8%bd%b4%e7%a7%b0%e4%b8%ba%e4%be%a7%e8%bd%b4%e3%80%82%e5%ae%83%e7%9a%84%e6%96%b9%e5%90%91%e4%b8%bb%e8%a6%81%e5%8f%96%e5%86%b3%e4%ba%8e%e4%b8%bb%e8%bd%b4%e6%96%b9%e5%90%91%e3%80%82%0a%2a%2a%e4%be%a7%e8%bd%b4%e8%b5%b7%e7%82%b9%ef%bc%88cross-start%ef%bc%89%e5%92%8c%e4%be%a7%e8%bd%b4%e7%bb%88%e7%82%b9%ef%bc%88cross-end%ef%bc%89%ef%bc%9a%2a%2a%e5%ad%90%e8%a7%86%e5%9b%be%e8%a1%8c%e7%9a%84%e9%85%8d%e7%bd%ae%e4%bb%8e%e5%ae%b9%e5%99%a8%e7%9a%84%e4%be%a7%e8%bd%b4%e8%b5%b7%e7%82%b9%e8%be%b9%e5%bc%80%e5%a7%8b%ef%bc%8c%e5%be%80%e4%be%a7%e8%bd%b4%e7%bb%88%e7%82%b9%e8%be%b9%e7%bb%93%e6%9d%9f%e3%80%82%0a%2a%2a%e4%be%a7%e8%bd%b4%e5%b0%ba%e5%af%b8%ef%bc%88cross%20size%ef%bc%89%ef%bc%9a%2a%2a%e5%ad%90%e8%a7%86%e5%9b%be%e7%9a%84%e5%9c%a8%e4%be%a7%e8%bd%b4%e6%96%b9%e5%90%91%e7%9a%84%e5%ae%bd%e5%ba%a6%e6%88%96%e9%ab%98%e5%ba%a6%e5%b0%b1%e6%98%af%e9%a1%b9%e7%9b%ae%e7%9a%84%e4%be%a7%e8%bd%b4%e9%95%bf%e5%ba%a6%ef%bc%8c%e4%bc%b8%e7%bc%a9%e9%a1%b9%e7%9b%ae%e7%9a%84%e4%be%a7%e8%bd%b4%e9%95%bf%e5%ba%a6%e5%b1%9e%e6%80%a7%e6%98%af%e3%80%8cwidth%e3%80%8d%e6%88%96%e3%80%8cheight%e3%80%8d%e5%b1%9e%e6%80%a7%ef%bc%8c%e7%94%b1%e5%93%aa%e4%b8%80%e4%b8%aa%e5%af%b9%e7%9d%80%e4%be%a7%e8%bd%b4%e6%96%b9%e5%90%91%e5%86%b3%e5%ae%9a%e3%80%82%0a%e6%8e%a5%e4%b8%8b%e6%9d%a5%e7%9c%8b%e7%9c%8bLayout%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9a%e4%b9%89FlexBox%e9%87%8c%e9%9d%a2%e7%9a%84%e5%85%83%e7%b4%a0%e7%9a%84%e3%80%82%0atypedef%20enum%20%7b%20CSS_DIRECTION_INHERIT%20%3d%200%2c%20CSS_DIRECTION_LTR%2c%20CSS_DIRECTION_RTL%20%7d%20css_direction_t%3b%20%e8%bf%99%e4%b8%aa%e6%96%b9%e5%90%91%e6%98%af%e5%ae%9a%e4%b9%89%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e7%9a%84%e6%95%b4%e4%bd%93%e5%b8%83%e5%b1%80%e7%9a%84%e6%96%b9%e5%90%91%ef%bc%8cINHERIT%e6%98%af%e7%bb%a7%e6%89%bf%ef%bc%8cLTR%e6%98%afLeft%20To%20Right%ef%bc%8c%e4%bb%8e%e5%b7%a6%e5%88%b0%e5%8f%b3%e5%b8%83%e5%b1%80%e3%80%82RTL%e6%98%afRight%20To%20Left%ef%bc%8c%e4%bb%8e%e5%8f%b3%e5%88%b0%e5%b7%a6%e5%b8%83%e5%b1%80%e3%80%82%e4%b8%8b%e9%9d%a2%e5%88%86%e6%9e%90%e5%a6%82%e6%9e%9c%e4%b8%8d%e5%81%9a%e7%89%b9%e6%ae%8a%e8%af%b4%e6%98%8e%ef%bc%8c%e9%83%bd%e6%98%afLTR%e4%bb%8e%e5%b7%a6%e5%90%91%e5%8f%b3%e5%b8%83%e5%b1%80%e3%80%82%e5%a6%82%e6%9e%9c%e6%98%afRTL%e5%b0%b1%e6%98%afLTR%e5%8f%8d%e5%90%91%e3%80%82%0atypedef%20enum%20%7b%20CSS_FLEX_DIRECTION_COLUMN%20%3d%200%2c%20CSS_FLEX_DIRECTION_COLUMN_REVERSE%2c%20CSS_FLEX_DIRECTION_ROW%2c%20CSS_FLEX_DIRECTION_ROW_REVERSE%20%7d%20css_flex_direction_t%3b%20%e8%bf%99%e9%87%8c%e5%ae%9a%e4%b9%89%e7%9a%84%e6%98%afFlex%e7%9a%84%e6%96%b9%e5%90%91%e3%80%82"><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fweex_flexbox%2f&t=%e7%94%b1%20FlexBox%20%e7%ae%97%e6%b3%95%e5%bc%ba%e5%8a%9b%e9%a9%b1%e5%8a%a8%e7%9a%84%20Weex%20%e5%b8%83%e5%b1%80%e5%bc%95%e6%93%8e"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu class=icon href=# onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden=true></i>Menu</a>
<a id=toc class=icon href=# onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden=true></i>TOC</a>
<a id=share class=icon href=# onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden=true></i>share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i>Top</a></div></div></div><footer id=footer><div class=footer-left><p class=copyright style=float:left;margin-bottom:0><a href=https://github.com/halfrost/Halfrost-Field class=github-repo style=height:18px><span class=gadget-github></span>Star</a>
Copyright &copy;halfrost 2016 - 2021
<a href=http://www.miit.gov.cn/>鄂ICP备16014744号</a></p><br><p class="copyright statistics" style=margin-bottom:20px><span id=busuanzi_container_site_pv>Cumulative Page Views <span id=busuanzi_value_site_pv></span>| Unique Visitors <span id=busuanzi_value_site_uv></span></span></p></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/main.min.f870a4d110314b9e50e65f8ac982dc1c9c376c8f1a5083d39c62cfc49073f011.js></script><script async src=/prism.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>
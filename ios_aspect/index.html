<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=theme-color content="#FFFFFF"><meta http-equiv=x-ua-compatible content="IE=edge"><title>iOS 如何实现 Aspect Oriented Programming | prometheus</title><meta name=description content="Explore in every moment of the hard thinking"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="iOS 如何实现 Aspect Oriented Programming"><meta property="og:description" content="前言 在“Runtime病院”住院的后两天，分析了一下AOP的实现原理。“出院”后，发现Aspect库还没有详细分析，于是就有了这篇文章，今天就来说说iOS 是如何实现Aspect Oriented Programming。
目录  1.Aspect Oriented Programming简介 2.什么是Aspects 3.Aspects 中4个基本类 解析 4.Aspects hook前的准备工作 5.Aspects hook过程详解 6.关于Aspects的一些 “坑”  一.Aspect Oriented Programming简介 面向切面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点（crosscutting concern）。
侧面的概念源于对面向对象的程序设计的改进，但并不只限于此，它还可以用来改进传统的函数。与侧面相关的编程概念还包括元对象协议、主题（subject）、混入（mixin）和委托。
AOP通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。
OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。
AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。
OOP和AOP属于两个不同的“思考方式”。OOP专注于对象的属性和行为的封装，AOP专注于处理某个步骤和阶段的，从中进行切面的提取。
举个例子，如果有一个判断权限的需求，OOP的做法肯定是在每个操作前都加入权限判断。那日志记录怎么办？在每个方法的开始结束的地方都加上日志记录。AOP就是把这些重复的逻辑和操作，提取出来，运用动态代理，实现这些模块的解耦。OOP和AOP不是互斥，而是相互配合。
在iOS里面使用AOP进行编程，可以实现非侵入。不需要更改之前的代码逻辑，就能加入新的功能。主要用来处理一些具有横切性质的系统性服务，如日志记录、权限管理、缓存、对象池管理等。
二. 什么是Aspects Aspects是一个轻量级的面向切面编程的库。它能允许你在每一个类和每一个实例中存在的方法里面加入任何代码。可以在以下切入点插入代码：before(在原始的方法前执行) / instead(替换原始的方法执行) / after(在原始的方法后执行,默认)。通过Runtime消息转发实现Hook。Aspects会自动的调用super方法，使用method swizzling起来会更加方便。
这个库很稳定，目前用在数百款app上了。它也是PSPDFKit的一部分，PSPDFKit是一个iOS 看PDF的framework库。作者最终决定把它开源出来。
三.Aspects 中4个基本类 解析 我们从头文件开始看起。
1.Aspects.h typedef NS_OPTIONS(NSUInteger, AspectOptions) { AspectPositionAfter = 0, /// Called after the original implementation (default)  AspectPositionInstead = 1, /// Will replace the original implementation."><meta property="og:type" content="article"><meta property="og:url" content="https://new.halfrost.com/ios_aspect/"><meta property="article:published_time" content="2016-10-15T09:54:00+00:00"><meta property="article:modified_time" content="2016-10-15T09:54:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="iOS 如何实现 Aspect Oriented Programming"><meta name=twitter:description content="前言 在“Runtime病院”住院的后两天，分析了一下AOP的实现原理。“出院”后，发现Aspect库还没有详细分析，于是就有了这篇文章，今天就来说说iOS 是如何实现Aspect Oriented Programming。
目录  1.Aspect Oriented Programming简介 2.什么是Aspects 3.Aspects 中4个基本类 解析 4.Aspects hook前的准备工作 5.Aspects hook过程详解 6.关于Aspects的一些 “坑”  一.Aspect Oriented Programming简介 面向切面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点（crosscutting concern）。
侧面的概念源于对面向对象的程序设计的改进，但并不只限于此，它还可以用来改进传统的函数。与侧面相关的编程概念还包括元对象协议、主题（subject）、混入（mixin）和委托。
AOP通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。
OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。
AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。
OOP和AOP属于两个不同的“思考方式”。OOP专注于对象的属性和行为的封装，AOP专注于处理某个步骤和阶段的，从中进行切面的提取。
举个例子，如果有一个判断权限的需求，OOP的做法肯定是在每个操作前都加入权限判断。那日志记录怎么办？在每个方法的开始结束的地方都加上日志记录。AOP就是把这些重复的逻辑和操作，提取出来，运用动态代理，实现这些模块的解耦。OOP和AOP不是互斥，而是相互配合。
在iOS里面使用AOP进行编程，可以实现非侵入。不需要更改之前的代码逻辑，就能加入新的功能。主要用来处理一些具有横切性质的系统性服务，如日志记录、权限管理、缓存、对象池管理等。
二. 什么是Aspects Aspects是一个轻量级的面向切面编程的库。它能允许你在每一个类和每一个实例中存在的方法里面加入任何代码。可以在以下切入点插入代码：before(在原始的方法前执行) / instead(替换原始的方法执行) / after(在原始的方法后执行,默认)。通过Runtime消息转发实现Hook。Aspects会自动的调用super方法，使用method swizzling起来会更加方便。
这个库很稳定，目前用在数百款app上了。它也是PSPDFKit的一部分，PSPDFKit是一个iOS 看PDF的framework库。作者最终决定把它开源出来。
三.Aspects 中4个基本类 解析 我们从头文件开始看起。
1.Aspects.h typedef NS_OPTIONS(NSUInteger, AspectOptions) { AspectPositionAfter = 0, /// Called after the original implementation (default)  AspectPositionInstead = 1, /// Will replace the original implementation."><link rel=stylesheet href=/css/style-white.min.css><link rel=manifest href=/manifest.json><link rel=stylesheet href=/prism.css><link href=/images/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=/images/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=/images/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=/images/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=/images/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=/images/apple-touch-icon-512x512.png rel=apple-touch-icon sizes=512x512><link href=/images/apple-touch-icon-1024x1024.png rel=apple-touch-icon sizes=1024x1024><script async>if('serviceWorker'in navigator){navigator.serviceWorker.register("\/serviceworker-v1.min.a64912b78d282eab1ad3715a0943da21616e5f326f8afea27034784ad445043b.js").then(function(){if(navigator.serviceWorker.controller){console.log('Assets cached by the controlling service worker.');}else{console.log('Please reload this page to allow the service worker to handle network operations.');}}).catch(function(error){console.log('ERROR: '+error);});}else{console.log('Service workers are not supported in the current browser.');}</script><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://new.halfrost.com/images/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-82753806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="single-max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a><a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a><a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast');" style=display:none><i class="fas fa-chevron-up fa-lg"></i></a><span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://new.halfrost.com/ghost_build/><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li><li><a class=icon href=https://new.halfrost.com/realm_ios/><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li><li><a class=icon href=#><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f"><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&text=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&title=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&is_video=false&description=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f"><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&title=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&title=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&title=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-stumbleupon" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&title=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-digg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&name=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming&description=%e5%89%8d%e8%a8%80%20%e5%9c%a8%e2%80%9cRuntime%e7%97%85%e9%99%a2%e2%80%9d%e4%bd%8f%e9%99%a2%e7%9a%84%e5%90%8e%e4%b8%a4%e5%a4%a9%ef%bc%8c%e5%88%86%e6%9e%90%e4%ba%86%e4%b8%80%e4%b8%8bAOP%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e3%80%82%e2%80%9c%e5%87%ba%e9%99%a2%e2%80%9d%e5%90%8e%ef%bc%8c%e5%8f%91%e7%8e%b0Aspect%e5%ba%93%e8%bf%98%e6%b2%a1%e6%9c%89%e8%af%a6%e7%bb%86%e5%88%86%e6%9e%90%ef%bc%8c%e4%ba%8e%e6%98%af%e5%b0%b1%e6%9c%89%e4%ba%86%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%ef%bc%8c%e4%bb%8a%e5%a4%a9%e5%b0%b1%e6%9d%a5%e8%af%b4%e8%af%b4iOS%20%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0Aspect%20Oriented%20Programming%e3%80%82%0a%e7%9b%ae%e5%bd%95%20%201.Aspect%20Oriented%20Programming%e7%ae%80%e4%bb%8b%202.%e4%bb%80%e4%b9%88%e6%98%afAspects%203.Aspects%20%e4%b8%ad4%e4%b8%aa%e5%9f%ba%e6%9c%ac%e7%b1%bb%20%e8%a7%a3%e6%9e%90%204.Aspects%20hook%e5%89%8d%e7%9a%84%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c%205.Aspects%20hook%e8%bf%87%e7%a8%8b%e8%af%a6%e8%a7%a3%206.%e5%85%b3%e4%ba%8eAspects%e7%9a%84%e4%b8%80%e4%ba%9b%20%e2%80%9c%e5%9d%91%e2%80%9d%20%20%e4%b8%80.Aspect%20Oriented%20Programming%e7%ae%80%e4%bb%8b%20%e9%9d%a2%e5%90%91%e5%88%87%e9%9d%a2%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%ef%bc%88aspect-oriented%20programming%ef%bc%8cAOP%ef%bc%8c%e5%8f%88%e8%af%91%e4%bd%9c%e9%9d%a2%e5%90%91%e6%96%b9%e9%9d%a2%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e3%80%81%e8%a7%82%e7%82%b9%e5%af%bc%e5%90%91%e7%bc%96%e7%a8%8b%e3%80%81%e5%89%96%e9%9d%a2%e5%af%bc%e5%90%91%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%ef%bc%89%e6%98%af%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6%e4%b8%ad%e7%9a%84%e4%b8%80%e4%b8%aa%e6%9c%af%e8%af%ad%ef%bc%8c%e6%8c%87%e4%b8%80%e7%a7%8d%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e8%8c%83%e5%9e%8b%e3%80%82%e8%af%a5%e8%8c%83%e5%9e%8b%e4%bb%a5%e4%b8%80%e7%a7%8d%e7%a7%b0%e4%b8%ba%e4%be%a7%e9%9d%a2%ef%bc%88aspect%ef%bc%8c%e5%8f%88%e8%af%91%e4%bd%9c%e6%96%b9%e9%9d%a2%ef%bc%89%e7%9a%84%e8%af%ad%e8%a8%80%e6%9e%84%e9%80%a0%e4%b8%ba%e5%9f%ba%e7%a1%80%ef%bc%8c%e4%be%a7%e9%9d%a2%e6%98%af%e4%b8%80%e7%a7%8d%e6%96%b0%e7%9a%84%e6%a8%a1%e5%9d%97%e5%8c%96%e6%9c%ba%e5%88%b6%ef%bc%8c%e7%94%a8%e6%9d%a5%e6%8f%8f%e8%bf%b0%e5%88%86%e6%95%a3%e5%9c%a8%e5%af%b9%e8%b1%a1%e3%80%81%e7%b1%bb%e6%88%96%e5%87%bd%e6%95%b0%e4%b8%ad%e7%9a%84%e6%a8%aa%e5%88%87%e5%85%b3%e6%b3%a8%e7%82%b9%ef%bc%88crosscutting%20concern%ef%bc%89%e3%80%82%0a%e4%be%a7%e9%9d%a2%e7%9a%84%e6%a6%82%e5%bf%b5%e6%ba%90%e4%ba%8e%e5%af%b9%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e7%9a%84%e6%94%b9%e8%bf%9b%ef%bc%8c%e4%bd%86%e5%b9%b6%e4%b8%8d%e5%8f%aa%e9%99%90%e4%ba%8e%e6%ad%a4%ef%bc%8c%e5%ae%83%e8%bf%98%e5%8f%af%e4%bb%a5%e7%94%a8%e6%9d%a5%e6%94%b9%e8%bf%9b%e4%bc%a0%e7%bb%9f%e7%9a%84%e5%87%bd%e6%95%b0%e3%80%82%e4%b8%8e%e4%be%a7%e9%9d%a2%e7%9b%b8%e5%85%b3%e7%9a%84%e7%bc%96%e7%a8%8b%e6%a6%82%e5%bf%b5%e8%bf%98%e5%8c%85%e6%8b%ac%e5%85%83%e5%af%b9%e8%b1%a1%e5%8d%8f%e8%ae%ae%e3%80%81%e4%b8%bb%e9%a2%98%ef%bc%88subject%ef%bc%89%e3%80%81%e6%b7%b7%e5%85%a5%ef%bc%88mixin%ef%bc%89%e5%92%8c%e5%a7%94%e6%89%98%e3%80%82%0aAOP%e9%80%9a%e8%bf%87%e9%a2%84%e7%bc%96%e8%af%91%e6%96%b9%e5%bc%8f%e5%92%8c%e8%bf%90%e8%a1%8c%e6%9c%9f%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e5%ae%9e%e7%8e%b0%e7%a8%8b%e5%ba%8f%e5%8a%9f%e8%83%bd%e7%9a%84%e7%bb%9f%e4%b8%80%e7%bb%b4%e6%8a%a4%e7%9a%84%e4%b8%80%e7%a7%8d%e6%8a%80%e6%9c%af%e3%80%82%0aOOP%ef%bc%88%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b%ef%bc%89%e9%92%88%e5%af%b9%e4%b8%9a%e5%8a%a1%e5%a4%84%e7%90%86%e8%bf%87%e7%a8%8b%e7%9a%84%e5%ae%9e%e4%bd%93%e5%8f%8a%e5%85%b6%e5%b1%9e%e6%80%a7%e5%92%8c%e8%a1%8c%e4%b8%ba%e8%bf%9b%e8%a1%8c%e6%8a%bd%e8%b1%a1%e5%b0%81%e8%a3%85%ef%bc%8c%e4%bb%a5%e8%8e%b7%e5%be%97%e6%9b%b4%e5%8a%a0%e6%b8%85%e6%99%b0%e9%ab%98%e6%95%88%e7%9a%84%e9%80%bb%e8%be%91%e5%8d%95%e5%85%83%e5%88%92%e5%88%86%e3%80%82%0aAOP%e5%88%99%e6%98%af%e9%92%88%e5%af%b9%e4%b8%9a%e5%8a%a1%e5%a4%84%e7%90%86%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%88%87%e9%9d%a2%e8%bf%9b%e8%a1%8c%e6%8f%90%e5%8f%96%ef%bc%8c%e5%ae%83%e6%89%80%e9%9d%a2%e5%af%b9%e7%9a%84%e6%98%af%e5%a4%84%e7%90%86%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e6%9f%90%e4%b8%aa%e6%ad%a5%e9%aa%a4%e6%88%96%e9%98%b6%e6%ae%b5%ef%bc%8c%e4%bb%a5%e8%8e%b7%e5%be%97%e9%80%bb%e8%be%91%e8%bf%87%e7%a8%8b%e4%b8%ad%e5%90%84%e9%83%a8%e5%88%86%e4%b9%8b%e9%97%b4%e4%bd%8e%e8%80%a6%e5%90%88%e6%80%a7%e7%9a%84%e9%9a%94%e7%a6%bb%e6%95%88%e6%9e%9c%e3%80%82%0aOOP%e5%92%8cAOP%e5%b1%9e%e4%ba%8e%e4%b8%a4%e4%b8%aa%e4%b8%8d%e5%90%8c%e7%9a%84%e2%80%9c%e6%80%9d%e8%80%83%e6%96%b9%e5%bc%8f%e2%80%9d%e3%80%82OOP%e4%b8%93%e6%b3%a8%e4%ba%8e%e5%af%b9%e8%b1%a1%e7%9a%84%e5%b1%9e%e6%80%a7%e5%92%8c%e8%a1%8c%e4%b8%ba%e7%9a%84%e5%b0%81%e8%a3%85%ef%bc%8cAOP%e4%b8%93%e6%b3%a8%e4%ba%8e%e5%a4%84%e7%90%86%e6%9f%90%e4%b8%aa%e6%ad%a5%e9%aa%a4%e5%92%8c%e9%98%b6%e6%ae%b5%e7%9a%84%ef%bc%8c%e4%bb%8e%e4%b8%ad%e8%bf%9b%e8%a1%8c%e5%88%87%e9%9d%a2%e7%9a%84%e6%8f%90%e5%8f%96%e3%80%82%0a%e4%b8%be%e4%b8%aa%e4%be%8b%e5%ad%90%ef%bc%8c%e5%a6%82%e6%9e%9c%e6%9c%89%e4%b8%80%e4%b8%aa%e5%88%a4%e6%96%ad%e6%9d%83%e9%99%90%e7%9a%84%e9%9c%80%e6%b1%82%ef%bc%8cOOP%e7%9a%84%e5%81%9a%e6%b3%95%e8%82%af%e5%ae%9a%e6%98%af%e5%9c%a8%e6%af%8f%e4%b8%aa%e6%93%8d%e4%bd%9c%e5%89%8d%e9%83%bd%e5%8a%a0%e5%85%a5%e6%9d%83%e9%99%90%e5%88%a4%e6%96%ad%e3%80%82%e9%82%a3%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95%e6%80%8e%e4%b9%88%e5%8a%9e%ef%bc%9f%e5%9c%a8%e6%af%8f%e4%b8%aa%e6%96%b9%e6%b3%95%e7%9a%84%e5%bc%80%e5%a7%8b%e7%bb%93%e6%9d%9f%e7%9a%84%e5%9c%b0%e6%96%b9%e9%83%bd%e5%8a%a0%e4%b8%8a%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95%e3%80%82AOP%e5%b0%b1%e6%98%af%e6%8a%8a%e8%bf%99%e4%ba%9b%e9%87%8d%e5%a4%8d%e7%9a%84%e9%80%bb%e8%be%91%e5%92%8c%e6%93%8d%e4%bd%9c%ef%bc%8c%e6%8f%90%e5%8f%96%e5%87%ba%e6%9d%a5%ef%bc%8c%e8%bf%90%e7%94%a8%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%ef%bc%8c%e5%ae%9e%e7%8e%b0%e8%bf%99%e4%ba%9b%e6%a8%a1%e5%9d%97%e7%9a%84%e8%a7%a3%e8%80%a6%e3%80%82OOP%e5%92%8cAOP%e4%b8%8d%e6%98%af%e4%ba%92%e6%96%a5%ef%bc%8c%e8%80%8c%e6%98%af%e7%9b%b8%e4%ba%92%e9%85%8d%e5%90%88%e3%80%82%0a%e5%9c%a8iOS%e9%87%8c%e9%9d%a2%e4%bd%bf%e7%94%a8AOP%e8%bf%9b%e8%a1%8c%e7%bc%96%e7%a8%8b%ef%bc%8c%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e9%9d%9e%e4%be%b5%e5%85%a5%e3%80%82%e4%b8%8d%e9%9c%80%e8%a6%81%e6%9b%b4%e6%94%b9%e4%b9%8b%e5%89%8d%e7%9a%84%e4%bb%a3%e7%a0%81%e9%80%bb%e8%be%91%ef%bc%8c%e5%b0%b1%e8%83%bd%e5%8a%a0%e5%85%a5%e6%96%b0%e7%9a%84%e5%8a%9f%e8%83%bd%e3%80%82%e4%b8%bb%e8%a6%81%e7%94%a8%e6%9d%a5%e5%a4%84%e7%90%86%e4%b8%80%e4%ba%9b%e5%85%b7%e6%9c%89%e6%a8%aa%e5%88%87%e6%80%a7%e8%b4%a8%e7%9a%84%e7%b3%bb%e7%bb%9f%e6%80%a7%e6%9c%8d%e5%8a%a1%ef%bc%8c%e5%a6%82%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95%e3%80%81%e6%9d%83%e9%99%90%e7%ae%a1%e7%90%86%e3%80%81%e7%bc%93%e5%ad%98%e3%80%81%e5%af%b9%e8%b1%a1%e6%b1%a0%e7%ae%a1%e7%90%86%e7%ad%89%e3%80%82%0a%e4%ba%8c.%20%e4%bb%80%e4%b9%88%e6%98%afAspects%20Aspects%e6%98%af%e4%b8%80%e4%b8%aa%e8%bd%bb%e9%87%8f%e7%ba%a7%e7%9a%84%e9%9d%a2%e5%90%91%e5%88%87%e9%9d%a2%e7%bc%96%e7%a8%8b%e7%9a%84%e5%ba%93%e3%80%82%e5%ae%83%e8%83%bd%e5%85%81%e8%ae%b8%e4%bd%a0%e5%9c%a8%e6%af%8f%e4%b8%80%e4%b8%aa%e7%b1%bb%e5%92%8c%e6%af%8f%e4%b8%80%e4%b8%aa%e5%ae%9e%e4%be%8b%e4%b8%ad%e5%ad%98%e5%9c%a8%e7%9a%84%e6%96%b9%e6%b3%95%e9%87%8c%e9%9d%a2%e5%8a%a0%e5%85%a5%e4%bb%bb%e4%bd%95%e4%bb%a3%e7%a0%81%e3%80%82%e5%8f%af%e4%bb%a5%e5%9c%a8%e4%bb%a5%e4%b8%8b%e5%88%87%e5%85%a5%e7%82%b9%e6%8f%92%e5%85%a5%e4%bb%a3%e7%a0%81%ef%bc%9abefore%28%e5%9c%a8%e5%8e%9f%e5%a7%8b%e7%9a%84%e6%96%b9%e6%b3%95%e5%89%8d%e6%89%a7%e8%a1%8c%29%20%2f%20instead%28%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%a7%8b%e7%9a%84%e6%96%b9%e6%b3%95%e6%89%a7%e8%a1%8c%29%20%2f%20after%28%e5%9c%a8%e5%8e%9f%e5%a7%8b%e7%9a%84%e6%96%b9%e6%b3%95%e5%90%8e%e6%89%a7%e8%a1%8c%2c%e9%bb%98%e8%ae%a4%29%e3%80%82%e9%80%9a%e8%bf%87Runtime%e6%b6%88%e6%81%af%e8%bd%ac%e5%8f%91%e5%ae%9e%e7%8e%b0Hook%e3%80%82Aspects%e4%bc%9a%e8%87%aa%e5%8a%a8%e7%9a%84%e8%b0%83%e7%94%a8super%e6%96%b9%e6%b3%95%ef%bc%8c%e4%bd%bf%e7%94%a8method%20swizzling%e8%b5%b7%e6%9d%a5%e4%bc%9a%e6%9b%b4%e5%8a%a0%e6%96%b9%e4%be%bf%e3%80%82%0a%e8%bf%99%e4%b8%aa%e5%ba%93%e5%be%88%e7%a8%b3%e5%ae%9a%ef%bc%8c%e7%9b%ae%e5%89%8d%e7%94%a8%e5%9c%a8%e6%95%b0%e7%99%be%e6%ac%beapp%e4%b8%8a%e4%ba%86%e3%80%82%e5%ae%83%e4%b9%9f%e6%98%afPSPDFKit%e7%9a%84%e4%b8%80%e9%83%a8%e5%88%86%ef%bc%8cPSPDFKit%e6%98%af%e4%b8%80%e4%b8%aaiOS%20%e7%9c%8bPDF%e7%9a%84framework%e5%ba%93%e3%80%82%e4%bd%9c%e8%80%85%e6%9c%80%e7%bb%88%e5%86%b3%e5%ae%9a%e6%8a%8a%e5%ae%83%e5%bc%80%e6%ba%90%e5%87%ba%e6%9d%a5%e3%80%82%0a%e4%b8%89.Aspects%20%e4%b8%ad4%e4%b8%aa%e5%9f%ba%e6%9c%ac%e7%b1%bb%20%e8%a7%a3%e6%9e%90%20%e6%88%91%e4%bb%ac%e4%bb%8e%e5%a4%b4%e6%96%87%e4%bb%b6%e5%bc%80%e5%a7%8b%e7%9c%8b%e8%b5%b7%e3%80%82%0a1.Aspects.h%20typedef%20NS_OPTIONS%28NSUInteger%2c%20AspectOptions%29%20%7b%20AspectPositionAfter%20%3d%200%2c%c2%a0%2f%2f%2f%20Called%20after%20the%20original%20implementation%20%28default%29%20%c2%a0AspectPositionInstead%20%3d%201%2c%c2%a0%2f%2f%2f%20Will%20replace%20the%20original%20implementation."><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&t=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div><div id=toc><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#目录>目录</a></li><li><a href=#一aspect-oriented-programming简介>一.Aspect Oriented Programming简介</a></li><li><a href=#二-什么是aspects>二. 什么是Aspects</a></li><li><a href=#三aspects-中4个基本类-解析>三.Aspects 中4个基本类 解析</a></li><li><a href=#四-aspects-hook前的准备工作>四. Aspects hook前的准备工作</a></li><li><a href=#五-aspects-hook过程详解>五. Aspects hook过程详解</a></li><li><a href=#六-关于aspects-的一些-坑>六. 关于Aspects 的一些 “坑”</a></li><li><a href=#最后>最后</a></li></ul></li></ul></li></ul></nav></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">iOS 如何实现 Aspect Oriented Programming</h1><div class=meta><div class=postdate><time datetime="2016-10-15 09:54:00 +0000 UTC" itemprop=datePublished>Oct 15</time></div><div class=article-category><i class="fas fa-archive"></i><a class=category-link href=/categories/ios>iOS</a>
,
<a class=category-link href=/categories/runtime>Runtime</a>
,
<a class=category-link href=/categories/aspect>Aspect</a>
,
<a class=category-link href=/categories/aop>AOP</a></div><div class=article-tag><i class="fas fa-tag"></i><a class=tag-link href=/tags/ios rel=tag>iOS</a>
,
<a class=tag-link href=/tags/runtime rel=tag>Runtime</a>
,
<a class=tag-link href=/tags/aspect rel=tag>Aspect</a>
,
<a class=tag-link href=/tags/aop rel=tag>AOP</a></div></div></header><div class=content itemprop=articleBody><h4 id=前言>前言</h4><p>在“Runtime病院”住院的后两天，分析了一下AOP的实现原理。“出院”后，发现Aspect库还没有详细分析，于是就有了这篇文章，今天就来说说iOS 是如何实现Aspect Oriented Programming。</p><h4 id=目录>目录</h4><ul><li>1.Aspect Oriented Programming简介</li><li>2.什么是Aspects</li><li>3.Aspects 中4个基本类 解析</li><li>4.Aspects hook前的准备工作</li><li>5.Aspects hook过程详解</li><li>6.关于Aspects的一些 “坑”</li></ul><h4 id=一aspect-oriented-programming简介>一.Aspect Oriented Programming简介</h4><p><strong>面向切面的程序设计</strong>（aspect-oriented programming，AOP，又译作<strong>面向方面的程序设计</strong>、<strong>观点导向编程</strong>、<strong>剖面导向程序设计</strong>）是<a href=https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6>计算机科学</a>中的一个术语，指一种<a href=https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%9E%8B>程序设计范型</a>。该范型以一种称为<strong>侧面</strong>（aspect，又译作<strong>方面</strong>）的语言构造为基础，<strong>侧面</strong>是一种新的模块化机制，用来描述分散在<a href=https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)>对象</a>、<a href=https://zh.wikipedia.org/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)>类</a>或<a href=https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)>函数</a>中的<strong>横切关注点</strong>（crosscutting concern）。</p><p>侧面的概念源于对<a href=https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1>面向对象的程序设计</a>的改进，但并不只限于此，它还可以用来改进传统的函数。与侧面相关的编程概念还包括<a href="https://zh.wikipedia.org/w/index.php?title=%E5%85%83%E5%AF%B9%E8%B1%A1%E5%8D%8F%E8%AE%AE&action=edit&redlink=1">元对象协议</a>、主题（subject）、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%B7%B7%E5%85%A5&action=edit&redlink=1">混入</a>（mixin）和委托。</p><p>AOP通过预编译方式和运行期<strong>动态代理</strong>实现程序功能的统一维护的一种技术。</p><p>OOP（面向对象编程）针对业务处理过程的<strong>实体</strong>及其<strong>属性</strong>和<strong>行为</strong>进行<strong>抽象封装</strong>，以获得更加清晰高效的逻辑单元划分。</p><p>AOP则是针对业务处理过程中的<strong>切面</strong>进行提取，它所面对的是处理过程中的某个<strong>步骤</strong>或<strong>阶段</strong>，以获得逻辑过程中各部分之间低耦合性的<strong>隔离效果</strong>。</p><p>OOP和AOP属于两个不同的“思考方式”。OOP专注于对象的属性和行为的封装，AOP专注于处理某个步骤和阶段的，从中进行切面的提取。</p><p>举个例子，如果有一个判断权限的需求，OOP的做法肯定是在每个操作前都加入权限判断。那日志记录怎么办？在每个方法的开始结束的地方都加上日志记录。AOP就是把这些重复的逻辑和操作，提取出来，运用动态代理，实现这些模块的解耦。OOP和AOP不是互斥，而是相互配合。</p><p>在iOS里面使用AOP进行编程，可以实现非侵入。不需要更改之前的代码逻辑，就能加入新的功能。主要用来处理一些具有横切性质的系统性服务，如日志记录、权限管理、缓存、对象池管理等。</p><h4 id=二-什么是aspects>二. 什么是Aspects</h4><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_1.png alt></p><p><a href=https://github.com/steipete/Aspects>Aspects</a>是一个轻量级的面向切面编程的库。它能允许你在每一个类和每一个实例中存在的方法里面加入任何代码。可以在以下切入点插入代码：before(在原始的方法前执行) / instead(替换原始的方法执行) / after(在原始的方法后执行,默认)。通过Runtime消息转发实现Hook。Aspects会自动的调用super方法，使用method swizzling起来会更加方便。</p><p>这个库很稳定，目前用在数百款app上了。它也是PSPDFKit的一部分，<a href=http://pspdfkit.com/>PSPDFKit</a>是一个iOS 看PDF的framework库。作者最终决定把它开源出来。</p><h4 id=三aspects-中4个基本类-解析>三.Aspects 中4个基本类 解析</h4><p>我们从头文件开始看起。</p><h5 id=1aspectsh>1.Aspects.h</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>NS_OPTIONS</span>(NSUInteger, AspectOptions) {
    AspectPositionAfter   <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,            <span style=color:#75715e>/// Called after the original implementation (default)
</span><span style=color:#75715e></span>    AspectPositionInstead <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,            <span style=color:#75715e>/// Will replace the original implementation.
</span><span style=color:#75715e></span>    AspectPositionBefore  <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>,            <span style=color:#75715e>/// Called before the original implementation.
</span><span style=color:#75715e></span>    
    AspectOptionAutomaticRemoval <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span> <span style=color:#75715e>/// Will remove the hook after the first execution.
</span><span style=color:#75715e></span>};

</code></pre></div><p>在头文件中定义了一个枚举。这个枚举里面是调用切片方法的时机。默认是AspectPositionAfter在原方法执行完之后调用。AspectPositionInstead是替换原方法。AspectPositionBefore是在原方法之前调用切片方法。AspectOptionAutomaticRemoval是在hook执行完自动移除。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>@protocol</span> <span style=color:#a6e22e>AspectToken</span> <span style=color:#f92672>&lt;</span>NSObject<span style=color:#f92672>&gt;</span>

<span style=color:#f92672>-</span> (<span style=color:#66d9ef>BOOL</span>)remove;

<span style=color:#66d9ef>@end</span>

</code></pre></div><p>定义了一个AspectToken的协议，这里的Aspect Token是隐式的，允许我们调用remove去撤销一个hook。remove方法返回YES代表撤销成功，返回NO就撤销失败。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>@protocol</span> <span style=color:#a6e22e>AspectInfo</span> <span style=color:#f92672>&lt;</span>NSObject<span style=color:#f92672>&gt;</span>

<span style=color:#f92672>-</span> (<span style=color:#66d9ef>id</span>)instance;
- (NSInvocation <span style=color:#f92672>*</span>)<span style=color:#a6e22e>originalInvocation</span>;
- (NSArray <span style=color:#f92672>*</span>)<span style=color:#a6e22e>arguments</span>;

<span style=color:#66d9ef>@end</span>

</code></pre></div><p>又定义了一个AspectInfo协议。AspectInfo protocol是我们block语法里面的第一个参数。</p><p>instance方法返回当前被hook的实例。originalInvocation方法返回被hooked方法的原始的invocation。arguments方法返回所有方法的参数。它的实现是懒加载。</p><p>头文件中还特意给了一段注释来说明Aspects的用法和注意点，值得我们关注。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#75715e>/**
</span><span style=color:#75715e> Aspects uses Objective-C message forwarding to hook into messages. This will create some overhead. Don&#39;t add aspects to methods that are called a lot. Aspects is meant for view/controller code that is not called a 1000 times per second.
</span><span style=color:#75715e>
</span><span style=color:#75715e> Adding aspects returns an opaque token which can be used to deregister again. All calls are thread safe.
</span><span style=color:#75715e> */</span>

</code></pre></div><p>Aspects利用的OC的消息转发机制，hook消息。这样会有一些性能开销。不要把Aspects加到经常被使用的方法里面。Aspects是用来设计给view/controller 代码使用的，而不是用来hook每秒调用1000次的方法的。</p><p>添加Aspects之后，会返回一个隐式的token，这个token会被用来注销hook方法的。所有的调用都是线程安全的。</p><p>关于线程安全，下面会详细分析。现在至少我们知道Aspects不应该被用在for循环这些方法里面，会造成很大的性能损耗。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>NSObject</span> (Aspects)

<span style=color:#75715e>/// Adds a block of code before/instead/after the current `selector` for a specific class.
</span><span style=color:#75715e>///
</span><span style=color:#75715e>/// @param block Aspects replicates the type signature of the method being hooked.
</span><span style=color:#75715e>/// The first parameter will be `id&lt;AspectInfo&gt;`, followed by all parameters of the method.
</span><span style=color:#75715e>/// These parameters are optional and will be filled to match the block signature.
</span><span style=color:#75715e>/// You can even use an empty block, or one that simple gets `id&lt;AspectInfo&gt;`.
</span><span style=color:#75715e>///
</span><span style=color:#75715e>/// @note Hooking static methods is not supported.
</span><span style=color:#75715e>/// @return A token which allows to later deregister the aspect.
</span><span style=color:#75715e></span>+ (<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>AspectToken<span style=color:#f92672>&gt;</span>)<span style=color:#a6e22e>aspect_hookSelector:</span>(<span style=color:#66d9ef>SEL</span>)selector
                           <span style=color:#a6e22e>withOptions:</span>(AspectOptions)options
                            <span style=color:#a6e22e>usingBlock:</span>(<span style=color:#66d9ef>id</span>)block
                                 <span style=color:#a6e22e>error:</span>(NSError <span style=color:#f92672>**</span>)error;

<span style=color:#75715e>/// Adds a block of code before/instead/after the current `selector` for a specific instance.
</span><span style=color:#75715e></span>- (<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>AspectToken<span style=color:#f92672>&gt;</span>)<span style=color:#a6e22e>aspect_hookSelector:</span>(<span style=color:#66d9ef>SEL</span>)selector
                           <span style=color:#a6e22e>withOptions:</span>(AspectOptions)options
                            <span style=color:#a6e22e>usingBlock:</span>(<span style=color:#66d9ef>id</span>)block
                                 <span style=color:#a6e22e>error:</span>(NSError <span style=color:#f92672>**</span>)error;

<span style=color:#66d9ef>@end</span>


</code></pre></div><p>Aspects整个库里面就只有这两个方法。这里可以看到，Aspects是NSobject的一个extension，只要是NSObject，都可以使用这两个方法。这两个方法名字都是同一个，入参和返回值也一样，唯一不同的是一个是加号方法一个是减号方法。一个是用来hook类方法，一个是用来hook实例方法。</p><p>方法里面有4个入参。第一个selector是要给它增加切面的原方法。第二个参数是AspectOptions类型，是代表这个切片增加在原方法的before / instead / after。第4个参数是返回的错误。</p><p>重点的就是第三个入参block。这个block复制了正在被hook的方法的签名signature类型。block遵循AspectInfo协议。我们甚至可以使用一个空的block。AspectInfo协议里面的参数是可选的，主要是用来匹配block签名的。</p><p>返回值是一个token，可以被用来注销这个Aspects。</p><p><strong>注意，Aspects是不支持hook 静态static方法的</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>NS_ENUM</span>(NSUInteger, AspectErrorCode) {
    AspectErrorSelectorBlacklisted,                   <span style=color:#75715e>/// Selectors like release, retain, autorelease are blacklisted.
</span><span style=color:#75715e></span>    AspectErrorDoesNotRespondToSelector,              <span style=color:#75715e>/// Selector could not be found.
</span><span style=color:#75715e></span>    AspectErrorSelectorDeallocPosition,               <span style=color:#75715e>/// When hooking dealloc, only AspectPositionBefore is allowed.
</span><span style=color:#75715e></span>    AspectErrorSelectorAlreadyHookedInClassHierarchy, <span style=color:#75715e>/// Statically hooking the same method in subclasses is not allowed.
</span><span style=color:#75715e></span>    AspectErrorFailedToAllocateClassPair,             <span style=color:#75715e>/// The runtime failed creating a class pair.
</span><span style=color:#75715e></span>    AspectErrorMissingBlockSignature,                 <span style=color:#75715e>/// The block misses compile time signature info and can&#39;t be called.
</span><span style=color:#75715e></span>    AspectErrorIncompatibleBlockSignature,            <span style=color:#75715e>/// The block signature does not match the method or is too large.
</span><span style=color:#75715e></span>
    AspectErrorRemoveObjectAlreadyDeallocated <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>   <span style=color:#75715e>/// (for removing) The object hooked is already deallocated.
</span><span style=color:#75715e></span>};

<span style=color:#66d9ef>extern</span> NSString <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> AspectErrorDomain;


</code></pre></div><p>这里定义了错误码的类型。出错的时候方便我们调试。</p><h5 id=2aspectsm>2.Aspects.m</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>#import &#34;Aspects.h&#34;
</span><span style=color:#75715e>#import &lt;libkern/OSAtomic.h&gt;
</span><span style=color:#75715e>#import &lt;objc/runtime.h&gt;
</span><span style=color:#75715e>#import &lt;objc/message.h&gt;
</span><span style=color:#75715e></span>
</code></pre></div><p>#import &lt;libkern/OSAtomic.h>导入这个头文件是为了下面用到的自旋锁。#import &lt;objc/runtime.h> 和 #import &lt;objc/message.h>是使用Runtime的必备头文件。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>NS_OPTIONS</span>(<span style=color:#66d9ef>int</span>, AspectBlockFlags) {
      AspectBlockFlagsHasCopyDisposeHelpers <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>25</span>),
      AspectBlockFlagsHasSignature          <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>30</span>)
};

</code></pre></div><p>定义了AspectBlockFlags，这是一个flag，用来标记两种情况，是否需要Copy和Dispose的Helpers，是否需要方法签名Signature 。</p><p>在Aspects中定义的4个类，分别是AspectInfo，AspectIdentifier，AspectsContainer，AspectTracker。接下来就分别看看这4个类是怎么定义的。</p><h5 id=3-aspectinfo>3. AspectInfo</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>AspectInfo</span> : <span style=color:#a6e22e>NSObject</span> <span style=color:#f92672>&lt;</span>AspectInfo<span style=color:#f92672>&gt;</span>
<span style=color:#f92672>-</span> (<span style=color:#66d9ef>id</span>)initWithInstance:(__unsafe_unretained <span style=color:#66d9ef>id</span>)instance invocation:(NSInvocation <span style=color:#f92672>*</span>)invocation;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>unsafe_unretained</span>, <span style=color:#66d9ef>readonly</span>) <span style=color:#66d9ef>id</span> instance;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>, <span style=color:#66d9ef>readonly</span>) NSArray <span style=color:#f92672>*</span>arguments;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>, <span style=color:#66d9ef>readonly</span>) NSInvocation <span style=color:#f92672>*</span>originalInvocation;
<span style=color:#66d9ef>@end</span>

</code></pre></div><p>AspectInfo对应的实现</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#75715e>#pragma mark - AspectInfo
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>AspectInfo</span>

<span style=color:#66d9ef>@synthesize</span> arguments <span style=color:#f92672>=</span> _arguments;

- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>initWithInstance:</span>(__unsafe_unretained <span style=color:#66d9ef>id</span>)instance <span style=color:#a6e22e>invocation:</span>(NSInvocation <span style=color:#f92672>*</span>)invocation {
    NSCParameterAssert(instance);
    NSCParameterAssert(invocation);
    <span style=color:#66d9ef>if</span> (self <span style=color:#f92672>=</span> [super init]) {
        _instance <span style=color:#f92672>=</span> instance;
        _originalInvocation <span style=color:#f92672>=</span> invocation;
    }
    <span style=color:#66d9ef>return</span> self;
}

- (NSArray <span style=color:#f92672>*</span>)<span style=color:#a6e22e>arguments</span> {
    <span style=color:#75715e>// Lazily evaluate arguments, boxing is expensive.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>_arguments) {
        _arguments <span style=color:#f92672>=</span> self.originalInvocation.aspects_arguments;
    }
    <span style=color:#66d9ef>return</span> _arguments;
}

</code></pre></div><p>AspectInfo是继承于NSObject，并且遵循了AspectInfo协议。在其 - (id)initWithInstance: invocation:方法中，把外面传进来的实例instance，和原始的invocation保存到AspectInfo类对应的成员变量中。- (NSArray *)arguments方法是一个懒加载，返回的是原始的invocation里面的aspects参数数组。</p><p>aspects_arguments这个getter方法是怎么实现的呢？作者是通过一个为NSInvocation添加一个分类来实现的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>NSInvocation</span> (Aspects)
- (NSArray <span style=color:#f92672>*</span>)<span style=color:#a6e22e>aspects_arguments</span>;
<span style=color:#66d9ef>@end</span>

</code></pre></div><p>为原始的NSInvocation类添加一个Aspects分类，这个分类中只增加一个方法，aspects_arguments，返回值是一个数组，数组里面包含了当前invocation的所有参数。</p><p>对应的实现</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>#pragma mark - NSInvocation (Aspects)
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>NSInvocation</span> (Aspects)

- (NSArray <span style=color:#f92672>*</span>)<span style=color:#a6e22e>aspects_arguments</span> {
 NSMutableArray <span style=color:#f92672>*</span>argumentsArray <span style=color:#f92672>=</span> [NSMutableArray array];
 <span style=color:#66d9ef>for</span> (NSUInteger idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; idx <span style=color:#f92672>&lt;</span> self.methodSignature.numberOfArguments; idx<span style=color:#f92672>++</span>) {
  [argumentsArray addObject:[self aspect_argumentAtIndex:idx] <span style=color:#f92672>?:</span> NSNull.null];
 }
 <span style=color:#66d9ef>return</span> [argumentsArray <span style=color:#66d9ef>copy</span>];
}

<span style=color:#66d9ef>@end</span>

</code></pre></div><p>- (NSArray *)aspects_arguments实现很简单，就是一层for循环，把methodSignature方法签名里面的参数，都加入到数组里，最后把数组返回。</p><p>关于获取方法所有参数的这个- (NSArray *)aspects_arguments方法的实现，有2个地方需要详细说明。一是为什么循环从2开始，二是[self aspect_argumentAtIndex:idx]内部是怎么实现的。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_2.png alt></p><p>先来说说为啥循环从2开始。</p><p>Type Encodings作为对Runtime的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的selector关联在一起。这种编码方案在其它情况下也是非常有用的，因此我们可以使用@encode编译器指令来获取它。当给定一个类型时，@encode返回这个类型的字符串编码。这些类型可以是诸如int、指针这样的基本类型，也可以是结构体、类等类型。事实上，任何可以作为sizeof()操作参数的类型都可以用于@encode()。</p><p>在Objective-C Runtime Programming Guide中的<a href=https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html>Type Encoding</a>一节中，列出了Objective-C中所有的类型编码。需要注意的是这些类型很多是与我们用于存档和分发的编码类型是相同的。但有一些不能在存档时使用。</p><p>注：Objective-C不支持long double类型。@encode(long double)返回d，与double是一样的。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_3.png alt></p><p>OC为支持消息的转发和动态调用，Objective-C Method 的 Type 信息以 “返回值 Type + 参数 Types” 的形式<strong>组合编码</strong>，还需要考虑到 self 和 _cmd 这两个隐含参数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#f92672>-</span> (<span style=color:#66d9ef>void</span>)tap; <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;v@:&#34;</span>
<span style=color:#f92672>-</span> (<span style=color:#66d9ef>int</span>)tapWithView:(<span style=color:#66d9ef>double</span>)pointx; <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;i@:d&#34;</span>

</code></pre></div><p>按照上面的表，我们可以知道，编码出来的字符串，前3位分别是返回值Type，self隐含参数Type @，_cmd隐含参数Type ：。</p><p>所以从第3位开始，是入参。</p><p>假设我们以- (void)tapView:(UIView *)view atIndex:(NSInteger)index为例，打印一下methodSignature</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
(lldb) po self.methodSignature
<span style=color:#f92672>&lt;</span>NSMethodSignature: <span style=color:#ae81ff>0x60800007df00</span><span style=color:#f92672>&gt;</span>
number of arguments <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
frame size <span style=color:#f92672>=</span> <span style=color:#ae81ff>224</span>
is special <span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>return</span><span style=color:#f92672>?</span> NO
<span style=color:#66d9ef>return</span> value: <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span>
type encoding (v) <span style=color:#e6db74>&#39;v&#39;</span>
flags {}
modifiers {}
frame {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, offset adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
memory {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
argument <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span>
type encoding (<span style=color:#960050;background-color:#1e0010>@</span>) <span style=color:#e6db74>&#39;@&#39;</span>
flags {isObject}
modifiers {}
frame {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, offset adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>, size adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
memory {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>}
argument <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span>
type encoding (<span style=color:#f92672>:</span>) <span style=color:#e6db74>&#39;:&#39;</span>
flags {}
modifiers {}
frame {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>, offset adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>, size adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
memory {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>}
argument <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span>
type encoding (<span style=color:#960050;background-color:#1e0010>@</span>) <span style=color:#e6db74>&#39;@&#39;</span>
flags {isObject}
modifiers {}
frame {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>, offset adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>, size adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
memory {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>}
argument <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span>
type encoding (q) <span style=color:#e6db74>&#39;q&#39;</span>
flags {isSigned}
modifiers {}
frame {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>, offset adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>, size adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
memory {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>}


</code></pre></div><p>number of arguments = 4，因为有2个隐含参数self和_cmd，加上入参view和index。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_4.png alt></p><p>第一个argument的frame {offset = 0, offset adjust = 0, size = 0, size adjust = 0}memory {offset = 0, size = 0}，返回值在这里不占size。第二个argument是self，frame {offset = 0, offset adjust = 0, size = 8, size adjust = 0}memory {offset = 0, size = 8}。由于size = 8，下一个frame的offset就是8，之后是16，以此类推。</p><p>至于为何这里要传递2，还跟aspect_argumentAtIndex具体实现有关系。</p><p>再来看看aspect_argumentAtIndex的具体实现。这个方法还要感谢ReactiveCocoa团队，为获取方法签名的参数提供了一种优雅的实现方式。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>// Thanks to the ReactiveCocoa team for providing a generic solution for this.
</span><span style=color:#75715e></span>- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>aspect_argumentAtIndex:</span>(NSUInteger)index {
 <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argType <span style=color:#f92672>=</span> [self.methodSignature getArgumentTypeAtIndex:index];
 <span style=color:#75715e>// Skip const type qualifier.
</span><span style=color:#75715e></span> <span style=color:#66d9ef>if</span> (argType[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> _C_CONST) argType<span style=color:#f92672>++</span>;

<span style=color:#75715e>#define WRAP_AND_RETURN(type) do { type val = 0; [self getArgument:&amp;val atIndex:(NSInteger)index]; return @(val); } while (0)
</span><span style=color:#75715e></span>
 <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>id</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>Class</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    <span style=color:#66d9ef>__autoreleasing</span> <span style=color:#66d9ef>id</span> returnObj;
    [self getArgument:<span style=color:#f92672>&amp;</span>returnObj atIndex:(NSInteger)index];
    <span style=color:#66d9ef>return</span> returnObj;
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>SEL</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    <span style=color:#66d9ef>SEL</span> selector <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    [self getArgument:<span style=color:#f92672>&amp;</span>selector atIndex:(NSInteger)index];
    <span style=color:#66d9ef>return</span> NSStringFromSelector(selector);
} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>Class</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    <span style=color:#66d9ef>__autoreleasing</span> <span style=color:#66d9ef>Class</span> theClass <span style=color:#f92672>=</span> Nil;
    [self getArgument:<span style=color:#f92672>&amp;</span>theClass atIndex:(NSInteger)index];
    <span style=color:#66d9ef>return</span> theClass;
    <span style=color:#75715e>// Using this list will box the number with the appropriate constructor, instead of the generic NSValue.
</span><span style=color:#75715e></span> } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>char</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>char</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>int</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>int</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>short</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>short</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>long</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>long</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>float</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>float</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>double</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>double</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>BOOL</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>BOOL</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>bool</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>BOOL</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    WRAP_AND_RETURN(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>);
 } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strcmp(argType, <span style=color:#66d9ef>@encode</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    __unsafe_unretained <span style=color:#66d9ef>id</span> block <span style=color:#f92672>=</span> nil;
    [self getArgument:<span style=color:#f92672>&amp;</span>block atIndex:(NSInteger)index];
    <span style=color:#66d9ef>return</span> [block <span style=color:#66d9ef>copy</span>];
 } <span style=color:#66d9ef>else</span> {
    NSUInteger valueSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    NSGetSizeAndAlignment(argType, <span style=color:#f92672>&amp;</span>valueSize, NULL);

    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> valueBytes[valueSize];
    [self getArgument:valueBytes atIndex:(NSInteger)index];

    <span style=color:#66d9ef>return</span> [NSValue valueWithBytes:valueBytes objCType:argType];
 }
 <span style=color:#66d9ef>return</span> nil;
<span style=color:#75715e>#undef WRAP_AND_RETURN
</span><span style=color:#75715e></span>}

</code></pre></div><p>getArgumentTypeAtIndex:这个方法是用来获取到methodSignature方法签名指定index的type encoding的字符串。这个方法传出来的字符串直接就是我们传进去的index值。比如我们传进去的是2，其实传出来的字符串是methodSignature对应的字符串的第3位。</p><p>由于第0位是函数返回值return value对应的type encoding，所以传进来的2，对应的是argument2。所以我们这里传递index = 2进来，就是过滤掉了前3个type encoding的字符串，从argument2开始比较。这就是为何循环从2开始的原因。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_5.png alt></p><p>_C_CONST是一个常量，用来判断encoding的字符串是不是CONST常量。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#75715e>#define _C_ID       &#39;@&#39;
</span><span style=color:#75715e>#define _C_CLASS    &#39;#&#39;
</span><span style=color:#75715e>#define _C_SEL      &#39;:&#39;
</span><span style=color:#75715e>#define _C_CHR      &#39;c&#39;
</span><span style=color:#75715e>#define _C_UCHR     &#39;C&#39;
</span><span style=color:#75715e>#define _C_SHT      &#39;s&#39;
</span><span style=color:#75715e>#define _C_USHT     &#39;S&#39;
</span><span style=color:#75715e>#define _C_INT      &#39;i&#39;
</span><span style=color:#75715e>#define _C_UINT     &#39;I&#39;
</span><span style=color:#75715e>#define _C_LNG      &#39;l&#39;
</span><span style=color:#75715e>#define _C_ULNG     &#39;L&#39;
</span><span style=color:#75715e>#define _C_LNG_LNG  &#39;q&#39;
</span><span style=color:#75715e>#define _C_ULNG_LNG &#39;Q&#39;
</span><span style=color:#75715e>#define _C_FLT      &#39;f&#39;
</span><span style=color:#75715e>#define _C_DBL      &#39;d&#39;
</span><span style=color:#75715e>#define _C_BFLD     &#39;b&#39;
</span><span style=color:#75715e>#define _C_BOOL     &#39;B&#39;
</span><span style=color:#75715e>#define _C_VOID     &#39;v&#39;
</span><span style=color:#75715e>#define _C_UNDEF    &#39;?&#39;
</span><span style=color:#75715e>#define _C_PTR      &#39;^&#39;
</span><span style=color:#75715e>#define _C_CHARPTR  &#39;*&#39;
</span><span style=color:#75715e>#define _C_ATOM     &#39;%&#39;
</span><span style=color:#75715e>#define _C_ARY_B    &#39;[&#39;
</span><span style=color:#75715e>#define _C_ARY_E    &#39;]&#39;
</span><span style=color:#75715e>#define _C_UNION_B  &#39;(&#39;
</span><span style=color:#75715e>#define _C_UNION_E  &#39;)&#39;
</span><span style=color:#75715e>#define _C_STRUCT_B &#39;{&#39;
</span><span style=color:#75715e>#define _C_STRUCT_E &#39;}&#39;
</span><span style=color:#75715e>#define _C_VECTOR   &#39;!&#39;
</span><span style=color:#75715e>#define _C_CONST    &#39;r&#39;
</span><span style=color:#75715e></span>
</code></pre></div><p>这里的Type和OC的Type 是完全一样的，只不过这里是一个C的char类型。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#75715e>#define WRAP_AND_RETURN(type) do { type val = 0; [self getArgument:&amp;val atIndex:(NSInteger)index]; return @(val); } while (0)
</span><span style=color:#75715e></span>
</code></pre></div><p>WRAP_AND_RETURN是一个宏定义。这个宏定义里面调用的getArgument:atIndex:方法是用来在NSInvocation中根据index得到对应的Argument，最后return的时候把val包装成对象，返回出去。</p><p>在下面大段的if - else判断中，有很多字符串比较的函数strcmp。</p><p>比如说strcmp(argType, @encode(id)) == 0，argType是一个char，内容是methodSignature取出来对应的type encoding，和@encode(id)是一样的type encoding。通过strcmp比较之后，如果是0，代表类型是相同的。</p><p>下面的大段的判断就是把入参都返回的过程，依次判断了id，class，SEL，接着是一大推基本类型，char，int，short，long，long long，unsigned char，unsigned int，unsigned short，unsigned long，unsigned long long，float，double，BOOL，bool，char *这些基本类型都会利用WRAP_AND_RETURN打包成对象返回。最后判断block和struct结构体，也会返回对应的对象。</p><p>这样入参就都返回到数组里面被接收了。假设还是上面- (void)tapView:(UIView *)view atIndex:(NSInteger)index为例子，执行完aspects_arguments，数组里面装的的是：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
(
  <span style=color:#f92672>&lt;</span>UIView: <span style=color:#ae81ff>0x7fa2e2504190</span>; frame <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>80</span>; <span style=color:#ae81ff>414</span> <span style=color:#ae81ff>40</span>); layer <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>CALayer: <span style=color:#ae81ff>0x6080000347c0</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#e6db74>&#34;,</span>
  <span style=color:#ae81ff>1</span>
)

</code></pre></div><p>总结，AspectInfo里面主要是 NSInvocation 信息。将NSInvocation包装一层，比如参数信息等。</p><h5 id=4-aspectidentifier>4. AspectIdentifier</h5><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_5_.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>// Tracks a single aspect.
</span><span style=color:#75715e></span><span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>AspectIdentifier</span> : <span style=color:#a6e22e>NSObject</span>
+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>identifierWithSelector:</span>(<span style=color:#66d9ef>SEL</span>)selector <span style=color:#a6e22e>object:</span>(<span style=color:#66d9ef>id</span>)object <span style=color:#a6e22e>options:</span>(AspectOptions)options <span style=color:#a6e22e>block:</span>(<span style=color:#66d9ef>id</span>)block <span style=color:#a6e22e>error:</span>(NSError <span style=color:#f92672>**</span>)error;
- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>invokeWithInfo:</span>(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>AspectInfo<span style=color:#f92672>&gt;</span>)info;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>assign</span>) <span style=color:#66d9ef>SEL</span> selector;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>) <span style=color:#66d9ef>id</span> block;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>) NSMethodSignature <span style=color:#f92672>*</span>blockSignature;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>weak</span>) <span style=color:#66d9ef>id</span> object;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>assign</span>) AspectOptions options;
<span style=color:#66d9ef>@end</span>

</code></pre></div><p>对应实现</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>#pragma mark - AspectIdentifier
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>AspectIdentifier</span>

+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>identifierWithSelector:</span>(<span style=color:#66d9ef>SEL</span>)selector <span style=color:#a6e22e>object:</span>(<span style=color:#66d9ef>id</span>)object <span style=color:#a6e22e>options:</span>(AspectOptions)options <span style=color:#a6e22e>block:</span>(<span style=color:#66d9ef>id</span>)block <span style=color:#a6e22e>error:</span>(NSError <span style=color:#f92672>**</span>)error {
    NSCParameterAssert(block);
    NSCParameterAssert(selector);
    NSMethodSignature <span style=color:#f92672>*</span>blockSignature <span style=color:#f92672>=</span> aspect_blockMethodSignature(block, error); <span style=color:#75715e>// TODO: check signature compatibility, etc.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>aspect_isCompatibleBlockSignature(blockSignature, object, selector, error)) {
        <span style=color:#66d9ef>return</span> nil;
    }

    AspectIdentifier <span style=color:#f92672>*</span>identifier <span style=color:#f92672>=</span> nil;
    <span style=color:#66d9ef>if</span> (blockSignature) {
        identifier <span style=color:#f92672>=</span> [AspectIdentifier new];
        identifier.selector <span style=color:#f92672>=</span> selector;
        identifier.block <span style=color:#f92672>=</span> block;
        identifier.blockSignature <span style=color:#f92672>=</span> blockSignature;
        identifier.options <span style=color:#f92672>=</span> options;
        identifier.object <span style=color:#f92672>=</span> object; <span style=color:#75715e>// weak
</span><span style=color:#75715e></span>    }
    <span style=color:#66d9ef>return</span> identifier;
}

- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>invokeWithInfo:</span>(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>AspectInfo<span style=color:#f92672>&gt;</span>)info {
    NSInvocation <span style=color:#f92672>*</span>blockInvocation <span style=color:#f92672>=</span> [NSInvocation invocationWithMethodSignature:self.blockSignature];
    NSInvocation <span style=color:#f92672>*</span>originalInvocation <span style=color:#f92672>=</span> info.originalInvocation;
    NSUInteger numberOfArguments <span style=color:#f92672>=</span> self.blockSignature.numberOfArguments;

    <span style=color:#75715e>// Be extra paranoid. We already check that on hook registration.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (numberOfArguments <span style=color:#f92672>&gt;</span> originalInvocation.methodSignature.numberOfArguments) {
        AspectLogError(<span style=color:#e6db74>@&#34;Block has too many arguments. Not calling %@&#34;</span>, info);
        <span style=color:#66d9ef>return</span> NO;
    }

    <span style=color:#75715e>// The `self` of the block will be the AspectInfo. Optional.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (numberOfArguments <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) {
        [blockInvocation setArgument:<span style=color:#f92672>&amp;</span>info atIndex:<span style=color:#ae81ff>1</span>];
    }
    
 <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>argBuf <span style=color:#f92672>=</span> NULL;
    <span style=color:#66d9ef>for</span> (NSUInteger idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; idx <span style=color:#f92672>&lt;</span> numberOfArguments; idx<span style=color:#f92672>++</span>) {
        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>type <span style=color:#f92672>=</span> [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];
  NSUInteger argSize;
  NSGetSizeAndAlignment(type, <span style=color:#f92672>&amp;</span>argSize, NULL);
        
  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(argBuf <span style=color:#f92672>=</span> reallocf(argBuf, argSize))) {
            AspectLogError(<span style=color:#e6db74>@&#34;Failed to allocate memory for block invocation.&#34;</span>);
   <span style=color:#66d9ef>return</span> NO;
  }
        
  [originalInvocation getArgument:argBuf atIndex:idx];
  [blockInvocation setArgument:argBuf atIndex:idx];
    }
    
    [blockInvocation invokeWithTarget:self.block];
    
    <span style=color:#66d9ef>if</span> (argBuf <span style=color:#f92672>!=</span> NULL) {
        free(argBuf);
    }
    <span style=color:#66d9ef>return</span> YES;
}

- (NSString <span style=color:#f92672>*</span>)<span style=color:#a6e22e>description</span> {
    <span style=color:#66d9ef>return</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;&lt;%@: %p, SEL:%@ object:%@ options:%tu block:%@ (#%tu args)&gt;&#34;</span>, self.<span style=color:#66d9ef>class</span>, self, NSStringFromSelector(self.selector), self.object, self.options, self.block, self.blockSignature.numberOfArguments];
}

- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>remove</span> {
    <span style=color:#66d9ef>return</span> aspect_remove(self, NULL);
}

<span style=color:#66d9ef>@end</span>


</code></pre></div><p>在instancetype方法中调用了aspect_blockMethodSignature方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>static</span> NSMethodSignature <span style=color:#f92672>*</span><span style=color:#a6e22e>aspect_blockMethodSignature</span>(<span style=color:#66d9ef>id</span> block, NSError <span style=color:#f92672>**</span>error) {
    AspectBlockRef layout <span style=color:#f92672>=</span> (<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)block;
 <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(layout<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> AspectBlockFlagsHasSignature)) {
        NSString <span style=color:#f92672>*</span>description <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;The block %@ doesn&#39;t contain a type signature.&#34;</span>, block];
        AspectError(AspectErrorMissingBlockSignature, description);
        <span style=color:#66d9ef>return</span> nil;
    }
 <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>desc <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>descriptor;
 desc <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span>);
 <span style=color:#66d9ef>if</span> (layout<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> AspectBlockFlagsHasCopyDisposeHelpers) {
  desc <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>);
    }
 <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>desc) {
        NSString <span style=color:#f92672>*</span>description <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;The block %@ doesn&#39;t has a type signature.&#34;</span>, block];
        AspectError(AspectErrorMissingBlockSignature, description);
        <span style=color:#66d9ef>return</span> nil;
    }
 <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>signature <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>)desc);
 <span style=color:#66d9ef>return</span> [NSMethodSignature signatureWithObjCTypes:signature];
}

</code></pre></div><p>这个aspect_blockMethodSignature的目的是把传递进来的AspectBlock转换成NSMethodSignature的方法签名。</p><p>AspectBlock的结构如下</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _AspectBlock {
 __unused <span style=color:#66d9ef>Class</span> isa;
 AspectBlockFlags flags;
 __unused <span style=color:#66d9ef>int</span> reserved;
 <span style=color:#66d9ef>void</span> (__unused <span style=color:#f92672>*</span>invoke)(<span style=color:#66d9ef>struct</span> _AspectBlock <span style=color:#f92672>*</span>block, ...);
 <span style=color:#66d9ef>struct</span> {
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> reserved;
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> size;
  <span style=color:#75715e>// requires AspectBlockFlagsHasCopyDisposeHelpers
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>copy</span>)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dst, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>src);
  <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>dispose)(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>);
  <span style=color:#75715e>// requires AspectBlockFlagsHasSignature
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>signature;
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>layout;
 } <span style=color:#f92672>*</span>descriptor;
 <span style=color:#75715e>// imported variables
</span><span style=color:#75715e></span>} <span style=color:#f92672>*</span>AspectBlockRef;

</code></pre></div><p>这里定义了一个Aspects内部使用的block类型。对系统的Block很熟悉的同学一眼就会感觉两者很像。不熟悉的可以看看我之前分析Block的文章。文章里，用Clang把Block转换成结构体，结构和这里定义的block很相似。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_6.png alt></p><p>了解了AspectBlock的结构之后，再看aspect_blockMethodSignature函数就比较清楚了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    AspectBlockRef layout <span style=color:#f92672>=</span> (<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)block;
 <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(layout<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> AspectBlockFlagsHasSignature)) {
        NSString <span style=color:#f92672>*</span>description <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;The block %@ doesn&#39;t contain a type signature.&#34;</span>, block];
        AspectError(AspectErrorMissingBlockSignature, description);
        <span style=color:#66d9ef>return</span> nil;
    }

</code></pre></div><p>AspectBlockRef layout = (__bridge void *)block，由于两者block实现类似，所以这里先把入参block强制转换成AspectBlockRef类型，然后判断是否有AspectBlockFlagsHasSignature的标志位，如果没有，报不包含方法签名的error。</p><p>注意，传入的block是全局类型的</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
  (__NSGlobalBlock) __NSGlobalBlock <span style=color:#f92672>=</span> {
    NSBlock <span style=color:#f92672>=</span> {
      NSObject <span style=color:#f92672>=</span> {
        isa <span style=color:#f92672>=</span> __NSGlobalBlock__
      }
    }
  }


</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
 <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>desc <span style=color:#f92672>=</span> layout<span style=color:#f92672>-&gt;</span>descriptor;
 desc <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span>);
 <span style=color:#66d9ef>if</span> (layout<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> AspectBlockFlagsHasCopyDisposeHelpers) {
  desc <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>);
    }
 <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>desc) {
        NSString <span style=color:#f92672>*</span>description <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;The block %@ doesn&#39;t has a type signature.&#34;</span>, block];
        AspectError(AspectErrorMissingBlockSignature, description);
        <span style=color:#66d9ef>return</span> nil;
    }


</code></pre></div><p>desc就是原来block里面对应的descriptor指针。descriptor指针往下偏移2个unsigned long int的位置就指向了copy函数的地址，如果包含Copy和Dispose函数，那么继续往下偏移2个(void *)的大小。这时指针肯定移动到了const char *signature的位置。如果desc不存在，那么也会报错，该block不包含方法签名。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
 <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>signature <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>)desc);
 <span style=color:#66d9ef>return</span> [NSMethodSignature signatureWithObjCTypes:signature];


</code></pre></div><p>到了这里，就保证有方法签名，且存在。最后调用NSMethodSignature的signatureWithObjCTypes方法，返回方法签名。</p><p>举例说明aspect_blockMethodSignature最终生成的方法签名是什么样子的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    [UIView aspect_hookSelector:<span style=color:#66d9ef>@selector</span>(UIView:atIndex:) withOptions:AspectPositionAfter usingBlock:<span style=color:#f92672>^</span>(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>AspectInfo<span style=color:#f92672>&gt;</span> aspects, UIView <span style=color:#f92672>*</span>view, NSInteger index)
     {
         
         NSLog(<span style=color:#e6db74>@&#34;按钮点击了 %ld&#34;</span>,index);
         
     } error:nil];

</code></pre></div><p>const char *signature最终获得的字符串是这样</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>) signature <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0000000102f72676</span> <span style=color:#e6db74>&#34;v32@?0@</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&lt;AspectInfo&gt;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>8@</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>UIView</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>16q24&#34;</span>

</code></pre></div><p>v32@?0@&ldquo;"8@&ldquo;UIView"16q24是Block</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#f92672>^</span>(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>AspectInfo<span style=color:#f92672>&gt;</span> aspects, UIView <span style=color:#f92672>*</span>view, NSInteger index){

}

</code></pre></div><p>对应的Type。void返回值的Type是v，32是offset，@？是block对应的Type，@“”是第一个参数，@&ldquo;UIView"是第二个参数，NSInteger对应的Type就是q了。</p><p>每个Type后面跟的数字都是它们各自对应的offset。把最终转换好的NSMethodSignature打印出来。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

 <span style=color:#f92672>&lt;</span>NSMethodSignature: <span style=color:#ae81ff>0x600000263dc0</span><span style=color:#f92672>&gt;</span>
      number of arguments <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
      frame size <span style=color:#f92672>=</span> <span style=color:#ae81ff>224</span>
      is special <span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>return</span><span style=color:#f92672>?</span> NO
      <span style=color:#66d9ef>return</span> value: <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span>
          type encoding (v) <span style=color:#e6db74>&#39;v&#39;</span>
          flags {}
          modifiers {}
          frame {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, offset adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
          memory {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
      argument <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span>
          type encoding (@) <span style=color:#960050;background-color:#1e0010>&#39;</span>@<span style=color:#f92672>?</span><span style=color:#960050;background-color:#1e0010>&#39;</span>
          flags {isObject, isBlock}
          modifiers {}
          frame {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, offset adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>, size adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
          memory {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>}
      argument <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span>
          type encoding (@) <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#e6db74>@&#34;&lt;AspectInfo&gt;&#34;</span><span style=color:#960050;background-color:#1e0010>&#39;</span>
          flags {isObject}
          modifiers {}
          frame {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>, offset adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>, size adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
          memory {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>}
              conforms to protocol <span style=color:#960050;background-color:#1e0010>&#39;</span>AspectInfo<span style=color:#960050;background-color:#1e0010>&#39;</span>
      argument <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span>
          type encoding (@) <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#e6db74>@&#34;UIView&#34;</span><span style=color:#960050;background-color:#1e0010>&#39;</span>
          flags {isObject}
          modifiers {}
          frame {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>, offset adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>, size adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
          memory {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>}
              <span style=color:#66d9ef>class</span> <span style=color:#960050;background-color:#1e0010>&#39;</span>DLMenuView<span style=color:#960050;background-color:#1e0010>&#39;</span>
      argument <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span> <span style=color:#f92672>--------</span>
          type encoding (q) <span style=color:#e6db74>&#39;q&#39;</span>
          flags {isSigned}
          modifiers {}
          frame {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>, offset adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>, size adjust <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>}
          memory {offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>}

</code></pre></div><p>回到AspectIdentifier中继续看instancetype方法，获取到了传入的block的方法签名之后，又调用了aspect_isCompatibleBlockSignature方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>BOOL</span> <span style=color:#a6e22e>aspect_isCompatibleBlockSignature</span>(NSMethodSignature <span style=color:#f92672>*</span>blockSignature, <span style=color:#66d9ef>id</span> object, <span style=color:#66d9ef>SEL</span> selector, NSError <span style=color:#f92672>**</span>error) {
    NSCParameterAssert(blockSignature);
    NSCParameterAssert(object);
    NSCParameterAssert(selector);

    <span style=color:#66d9ef>BOOL</span> signaturesMatch <span style=color:#f92672>=</span> YES;
    NSMethodSignature <span style=color:#f92672>*</span>methodSignature <span style=color:#f92672>=</span> [[object <span style=color:#66d9ef>class</span>] instanceMethodSignatureForSelector:selector];
    <span style=color:#66d9ef>if</span> (blockSignature.numberOfArguments <span style=color:#f92672>&gt;</span> methodSignature.numberOfArguments) {
        signaturesMatch <span style=color:#f92672>=</span> NO;
    }<span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>if</span> (blockSignature.numberOfArguments <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) {
            <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>blockType <span style=color:#f92672>=</span> [blockSignature getArgumentTypeAtIndex:<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (blockType[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;@&#39;</span>) {
                signaturesMatch <span style=color:#f92672>=</span> NO;
            }
        }
        <span style=color:#75715e>// Argument 0 is self/block, argument 1 is SEL or id&lt;AspectInfo&gt;. We start comparing at argument 2.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// The block can have less arguments than the method, that&#39;s ok.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (signaturesMatch) {
            <span style=color:#66d9ef>for</span> (NSUInteger idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; idx <span style=color:#f92672>&lt;</span> blockSignature.numberOfArguments; idx<span style=color:#f92672>++</span>) {
                <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>methodType <span style=color:#f92672>=</span> [methodSignature getArgumentTypeAtIndex:idx];
                <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>blockType <span style=color:#f92672>=</span> [blockSignature getArgumentTypeAtIndex:idx];
                <span style=color:#75715e>// Only compare parameter, not the optional type data.
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>methodType <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>blockType <span style=color:#f92672>||</span> methodType[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>!=</span> blockType[<span style=color:#ae81ff>0</span>]) {
                    signaturesMatch <span style=color:#f92672>=</span> NO; <span style=color:#66d9ef>break</span>;
                }
            }
        }
    }

    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>signaturesMatch) {
        NSString <span style=color:#f92672>*</span>description <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;Block signature %@ doesn&#39;t match %@.&#34;</span>, blockSignature, methodSignature];
        AspectError(AspectErrorIncompatibleBlockSignature, description);
        <span style=color:#66d9ef>return</span> NO;
    }
    <span style=color:#66d9ef>return</span> YES;
}


</code></pre></div><p>这个函数的作用是把我们要替换的方法block和要替换的原方法，进行对比。如何对比呢？对比两者的方法签名。</p><p>入参selector是原方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>if</span> (blockSignature.numberOfArguments <span style=color:#f92672>&gt;</span> methodSignature.numberOfArguments) {
        signaturesMatch <span style=color:#f92672>=</span> NO;
    }<span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>if</span> (blockSignature.numberOfArguments <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) {
            <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>blockType <span style=color:#f92672>=</span> [blockSignature getArgumentTypeAtIndex:<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (blockType[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;@&#39;</span>) {
                signaturesMatch <span style=color:#f92672>=</span> NO;
            }
        }

</code></pre></div><p>先比较方法签名的参数个数是否相等，不等肯定是不匹配，signaturesMatch = NO。如果参数个数相等，再比较我们要替换的方法里面第一个参数是不是_cmd，对应的Type就是@，如果不是，也是不匹配，所以signaturesMatch = NO。如果上面两条都满足，signaturesMatch = YES，那么就进入下面更加严格的对比。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
     <span style=color:#66d9ef>if</span> (signaturesMatch) {
            <span style=color:#66d9ef>for</span> (NSUInteger idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; idx <span style=color:#f92672>&lt;</span> blockSignature.numberOfArguments; idx<span style=color:#f92672>++</span>) {
                <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>methodType <span style=color:#f92672>=</span> [methodSignature getArgumentTypeAtIndex:idx];
                <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>blockType <span style=color:#f92672>=</span> [blockSignature getArgumentTypeAtIndex:idx];
                <span style=color:#75715e>// Only compare parameter, not the optional type data.
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>methodType <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>blockType <span style=color:#f92672>||</span> methodType[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>!=</span> blockType[<span style=color:#ae81ff>0</span>]) {
                    signaturesMatch <span style=color:#f92672>=</span> NO; <span style=color:#66d9ef>break</span>;
                }
            }
        }


</code></pre></div><p>这里循环也是从2开始的。举个例子来说明为什么从第二位开始比较。还是用之前的例子。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
[UIView aspect_hookSelector:<span style=color:#66d9ef>@selector</span>(UIView:atIndex:) withOptions:AspectPositionAfter usingBlock:<span style=color:#f92672>^</span>(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>AspectInfo<span style=color:#f92672>&gt;</span> aspects, UIView <span style=color:#f92672>*</span>view, NSInteger index)
 {
     
     NSLog(<span style=color:#e6db74>@&#34;按钮点击了 %ld&#34;</span>,index);
     
 } error:nil];

</code></pre></div><p>这里我要替换的原方法是UIView:atIndex:，那么对应的Type是v@:@q。根据上面的分析，这里的blockSignature是之前调用转换出来的Type，应该是v@?@&ldquo;&rdquo;@&ldquo;UIView"q。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_7.png alt></p><p>methodSignature 和 blockSignature 的return value都是void，所以对应的都是v。methodSignature的argument 0 是隐含参数 self，所以对应的是@。blockSignature的argument 0 是block，所以对应的是@？。methodSignature的argument 1 是隐含参数 _cmd，所以对应的是:。blockSignature的argument 1 是，所以对应的是@&ldquo;&rdquo;。从argument 2开始才是方法签名后面的对应可能出现差异，需要比较的参数列表。</p><p>最后</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>signaturesMatch) {
        NSString <span style=color:#f92672>*</span>description <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;Block signature %@ doesn&#39;t match %@.&#34;</span>, blockSignature, methodSignature];
        AspectError(AspectErrorIncompatibleBlockSignature, description);
        <span style=color:#66d9ef>return</span> NO;
    }


</code></pre></div><p>如果经过上面的比较signaturesMatch都为NO，那么就抛出error，Block无法匹配方法签名。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    AspectIdentifier <span style=color:#f92672>*</span>identifier <span style=color:#f92672>=</span> nil;
    <span style=color:#66d9ef>if</span> (blockSignature) {
        identifier <span style=color:#f92672>=</span> [AspectIdentifier new];
        identifier.selector <span style=color:#f92672>=</span> selector;
        identifier.block <span style=color:#f92672>=</span> block;
        identifier.blockSignature <span style=color:#f92672>=</span> blockSignature;
        identifier.options <span style=color:#f92672>=</span> options;
        identifier.object <span style=color:#f92672>=</span> object; <span style=color:#75715e>// weak
</span><span style=color:#75715e></span>    }
    <span style=color:#66d9ef>return</span> identifier;


</code></pre></div><p>如果这里匹配成功了，就会blockSignature全部都赋值给AspectIdentifier。这也就是为何AspectIdentifier里面有一个单独的属性NSMethodSignature的原因。</p><p>AspectIdentifier还有另外一个方法invokeWithInfo。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#75715e>// Be extra paranoid. We already check that on hook registration.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (numberOfArguments <span style=color:#f92672>&gt;</span> originalInvocation.methodSignature.numberOfArguments) {
        AspectLogError(<span style=color:#e6db74>@&#34;Block has too many arguments. Not calling %@&#34;</span>, info);
        <span style=color:#66d9ef>return</span> NO;
    }


</code></pre></div><p>注释也写清楚了，这个判断是强迫症患者写的，到了这里block里面的参数是不会大于原始方法的方法签名里面参数的个数的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

    <span style=color:#75715e>// The `self` of the block will be the AspectInfo. Optional.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (numberOfArguments <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) {
        [blockInvocation setArgument:<span style=color:#f92672>&amp;</span>info atIndex:<span style=color:#ae81ff>1</span>];
    }


</code></pre></div><p>把AspectInfo存入到blockInvocation中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
 <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>argBuf <span style=color:#f92672>=</span> NULL;
    <span style=color:#66d9ef>for</span> (NSUInteger idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; idx <span style=color:#f92672>&lt;</span> numberOfArguments; idx<span style=color:#f92672>++</span>) {
        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>type <span style=color:#f92672>=</span> [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];
         NSUInteger argSize;
         NSGetSizeAndAlignment(type, <span style=color:#f92672>&amp;</span>argSize, NULL);
        
          <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(argBuf <span style=color:#f92672>=</span> reallocf(argBuf, argSize))) {
            AspectLogError(<span style=color:#e6db74>@&#34;Failed to allocate memory for block invocation.&#34;</span>);
            <span style=color:#66d9ef>return</span> NO;
          }
        
        [originalInvocation getArgument:argBuf atIndex:idx];
        [blockInvocation setArgument:argBuf atIndex:idx];
   }
    
    [blockInvocation invokeWithTarget:self.block];

</code></pre></div><p>这一段是循环把originalInvocation中取出参数，赋值到argBuf中，然后再赋值到blockInvocation里面。循环从2开始的原因上面已经说过了，这里不再赘述。最后把self.block赋值给blockInvocation的Target。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_8.png alt></p><p>总结，AspectIdentifier是一个切片Aspect的具体内容。里面会包含了单个的 Aspect 的具体信息，包括执行时机，要执行 block 所需要用到的具体信息：包括方法签名、参数等等。初始化AspectIdentifier的过程实质是把我们传入的block打包成AspectIdentifier。</p><h5 id=5-aspectscontainer>5. AspectsContainer</h5><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_9.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#75715e>// Tracks all aspects for an object/class.
</span><span style=color:#75715e></span><span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>AspectsContainer</span> : <span style=color:#a6e22e>NSObject</span>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>addAspect:</span>(AspectIdentifier <span style=color:#f92672>*</span>)aspect <span style=color:#a6e22e>withOptions:</span>(AspectOptions)injectPosition;
- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>removeAspect:</span>(<span style=color:#66d9ef>id</span>)aspect;
- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>hasAspects</span>;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>atomic</span>, <span style=color:#66d9ef>copy</span>) NSArray <span style=color:#f92672>*</span>beforeAspects;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>atomic</span>, <span style=color:#66d9ef>copy</span>) NSArray <span style=color:#f92672>*</span>insteadAspects;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>atomic</span>, <span style=color:#66d9ef>copy</span>) NSArray <span style=color:#f92672>*</span>afterAspects;
<span style=color:#66d9ef>@end</span>

</code></pre></div><p>对应实现</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>#pragma mark - AspectsContainer
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>AspectsContainer</span>

- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>hasAspects</span> {
    <span style=color:#66d9ef>return</span> self.beforeAspects.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> self.insteadAspects.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> self.afterAspects.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>;
}

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>addAspect:</span>(AspectIdentifier <span style=color:#f92672>*</span>)aspect <span style=color:#a6e22e>withOptions:</span>(AspectOptions)options {
    NSParameterAssert(aspect);
    NSUInteger position <span style=color:#f92672>=</span> options<span style=color:#f92672>&amp;</span>AspectPositionFilter;
    <span style=color:#66d9ef>switch</span> (position) {
        <span style=color:#66d9ef>case</span> AspectPositionBefore:  self.beforeAspects  <span style=color:#f92672>=</span> [(self.beforeAspects <span style=color:#f92672>?:</span><span style=color:#ae81ff>@[]</span>) arrayByAddingObject:aspect]; <span style=color:#66d9ef>break</span>;
        <span style=color:#66d9ef>case</span> AspectPositionInstead: self.insteadAspects <span style=color:#f92672>=</span> [(self.insteadAspects<span style=color:#f92672>?:</span><span style=color:#ae81ff>@[]</span>) arrayByAddingObject:aspect]; <span style=color:#66d9ef>break</span>;
        <span style=color:#66d9ef>case</span> AspectPositionAfter:   self.afterAspects   <span style=color:#f92672>=</span> [(self.afterAspects  <span style=color:#f92672>?:</span><span style=color:#ae81ff>@[]</span>) arrayByAddingObject:aspect]; <span style=color:#66d9ef>break</span>;
    }
}

- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>removeAspect:</span>(<span style=color:#66d9ef>id</span>)aspect {
    <span style=color:#66d9ef>for</span> (NSString <span style=color:#f92672>*</span>aspectArrayName <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>@[</span>NSStringFromSelector(<span style=color:#66d9ef>@selector</span>(beforeAspects)),
                                        NSStringFromSelector(<span style=color:#66d9ef>@selector</span>(insteadAspects)),
                                        NSStringFromSelector(<span style=color:#66d9ef>@selector</span>(afterAspects))<span style=color:#ae81ff>]</span>) {
        NSArray <span style=color:#f92672>*</span>array <span style=color:#f92672>=</span> [self valueForKey:aspectArrayName];
        NSUInteger index <span style=color:#f92672>=</span> [array indexOfObjectIdenticalTo:aspect];
        <span style=color:#66d9ef>if</span> (array <span style=color:#f92672>&amp;&amp;</span> index <span style=color:#f92672>!=</span> NSNotFound) {
            NSMutableArray <span style=color:#f92672>*</span>newArray <span style=color:#f92672>=</span> [NSMutableArray arrayWithArray:array];
            [newArray removeObjectAtIndex:index];
            [self setValue:newArray forKey:aspectArrayName];
            <span style=color:#66d9ef>return</span> YES;
        }
    }
    <span style=color:#66d9ef>return</span> NO;
}

- (NSString <span style=color:#f92672>*</span>)<span style=color:#a6e22e>description</span> {
    <span style=color:#66d9ef>return</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;&lt;%@: %p, before:%@, instead:%@, after:%@&gt;&#34;</span>, self.<span style=color:#66d9ef>class</span>, self, self.beforeAspects, self.insteadAspects, self.afterAspects];
}

<span style=color:#66d9ef>@end</span>

</code></pre></div><p>AspectsContainer比较好理解。addAspect会按照切面的时机分别把切片Aspects放到对应的数组里面。removeAspects会循环移除所有的Aspects。hasAspects判断是否有Aspects。</p><p>AspectsContainer是一个对象或者类的所有的 Aspects 的容器。所有会有两种容器。</p><p>值得我们注意的是这里数组是通过Atomic修饰的。关于Atomic需要注意在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(Atomicity)。如果属性具备nonatomic特质，则不需要同步锁。</p><h5 id=6-aspecttracker>6. AspectTracker</h5><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_10.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>AspectTracker</span> : <span style=color:#a6e22e>NSObject</span>
- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>initWithTrackedClass:</span>(<span style=color:#66d9ef>Class</span>)trackedClass;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>) <span style=color:#66d9ef>Class</span> trackedClass;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>readonly</span>) NSString <span style=color:#f92672>*</span>trackedClassName;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>) NSMutableSet <span style=color:#f92672>*</span>selectorNames;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>) NSMutableDictionary <span style=color:#f92672>*</span>selectorNamesToSubclassTrackers;
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>addSubclassTracker:</span>(AspectTracker <span style=color:#f92672>*</span>)subclassTracker <span style=color:#a6e22e>hookingSelectorName:</span>(NSString <span style=color:#f92672>*</span>)selectorName;
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>removeSubclassTracker:</span>(AspectTracker <span style=color:#f92672>*</span>)subclassTracker <span style=color:#a6e22e>hookingSelectorName:</span>(NSString <span style=color:#f92672>*</span>)selectorName;
- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>subclassHasHookedSelectorName:</span>(NSString <span style=color:#f92672>*</span>)selectorName;
- (NSSet <span style=color:#f92672>*</span>)<span style=color:#a6e22e>subclassTrackersHookingSelectorName:</span>(NSString <span style=color:#f92672>*</span>)selectorName;
<span style=color:#66d9ef>@end</span>


</code></pre></div><p>对应实现</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>AspectTracker</span>

- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>initWithTrackedClass:</span>(<span style=color:#66d9ef>Class</span>)trackedClass {
    <span style=color:#66d9ef>if</span> (self <span style=color:#f92672>=</span> [super init]) {
        _trackedClass <span style=color:#f92672>=</span> trackedClass;
        _selectorNames <span style=color:#f92672>=</span> [NSMutableSet new];
        _selectorNamesToSubclassTrackers <span style=color:#f92672>=</span> [NSMutableDictionary new];
    }
    <span style=color:#66d9ef>return</span> self;
}

- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>subclassHasHookedSelectorName:</span>(NSString <span style=color:#f92672>*</span>)selectorName {
    <span style=color:#66d9ef>return</span> self.selectorNamesToSubclassTrackers[selectorName] <span style=color:#f92672>!=</span> nil;
}

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>addSubclassTracker:</span>(AspectTracker <span style=color:#f92672>*</span>)subclassTracker <span style=color:#a6e22e>hookingSelectorName:</span>(NSString <span style=color:#f92672>*</span>)selectorName {
    NSMutableSet <span style=color:#f92672>*</span>trackerSet <span style=color:#f92672>=</span> self.selectorNamesToSubclassTrackers[selectorName];
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>trackerSet) {
        trackerSet <span style=color:#f92672>=</span> [NSMutableSet new];
        self.selectorNamesToSubclassTrackers[selectorName] <span style=color:#f92672>=</span> trackerSet;
    }
    [trackerSet addObject:subclassTracker];
}
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>removeSubclassTracker:</span>(AspectTracker <span style=color:#f92672>*</span>)subclassTracker <span style=color:#a6e22e>hookingSelectorName:</span>(NSString <span style=color:#f92672>*</span>)selectorName {
    NSMutableSet <span style=color:#f92672>*</span>trackerSet <span style=color:#f92672>=</span> self.selectorNamesToSubclassTrackers[selectorName];
    [trackerSet removeObject:subclassTracker];
    <span style=color:#66d9ef>if</span> (trackerSet.count <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
        [self.selectorNamesToSubclassTrackers removeObjectForKey:selectorName];
    }
}
- (NSSet <span style=color:#f92672>*</span>)<span style=color:#a6e22e>subclassTrackersHookingSelectorName:</span>(NSString <span style=color:#f92672>*</span>)selectorName {
    NSMutableSet <span style=color:#f92672>*</span>hookingSubclassTrackers <span style=color:#f92672>=</span> [NSMutableSet new];
    <span style=color:#66d9ef>for</span> (AspectTracker <span style=color:#f92672>*</span>tracker <span style=color:#66d9ef>in</span> self.selectorNamesToSubclassTrackers[selectorName]) {
        <span style=color:#66d9ef>if</span> ([tracker.selectorNames containsObject:selectorName]) {
            [hookingSubclassTrackers addObject:tracker];
        }
        [hookingSubclassTrackers unionSet:[tracker subclassTrackersHookingSelectorName:selectorName]];
    }
    <span style=color:#66d9ef>return</span> hookingSubclassTrackers;
}
- (NSString <span style=color:#f92672>*</span>)<span style=color:#a6e22e>trackedClassName</span> {
    <span style=color:#66d9ef>return</span> NSStringFromClass(self.trackedClass);
}

- (NSString <span style=color:#f92672>*</span>)<span style=color:#a6e22e>description</span> {
    <span style=color:#66d9ef>return</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;&lt;%@: %@, trackedClass: %@, selectorNames:%@, subclass selector names: %@&gt;&#34;</span>, self.<span style=color:#66d9ef>class</span>, self, NSStringFromClass(self.trackedClass), self.selectorNames, self.selectorNamesToSubclassTrackers.allKeys];
}

<span style=color:#66d9ef>@end</span>

</code></pre></div><p>AspectTracker这个类是用来跟踪要被hook的类。trackedClass是被追踪的类。trackedClassName是被追踪类的类名。selectorNames是一个NSMutableSet，这里会记录要被hook替换的方法名，用NSMutableSet是为了防止重复替换方法。selectorNamesToSubclassTrackers是一个字典，key是hookingSelectorName，value是装满AspectTracker的NSMutableSet。</p><p>addSubclassTracker方法是把AspectTracker加入到对应selectorName的集合中。removeSubclassTracker方法是把AspectTracker从对应的selectorName的集合中移除。subclassTrackersHookingSelectorName方法是一个并查集，传入一个selectorName，通过递归查找，找到所有包含这个selectorName的set，最后把这些set合并在一起作为返回值返回。</p><h4 id=四-aspects-hook前的准备工作>四. Aspects hook前的准备工作</h4><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_11.png alt></p><p>Aspects 库中就两个函数，一个是针对类的，一个是针对实例的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>AspectToken<span style=color:#f92672>&gt;</span>)<span style=color:#a6e22e>aspect_hookSelector:</span>(<span style=color:#66d9ef>SEL</span>)selector
                      <span style=color:#a6e22e>withOptions:</span>(AspectOptions)options
                       <span style=color:#a6e22e>usingBlock:</span>(<span style=color:#66d9ef>id</span>)block
                            <span style=color:#a6e22e>error:</span>(NSError <span style=color:#f92672>**</span>)error {
    <span style=color:#66d9ef>return</span> aspect_add((<span style=color:#66d9ef>id</span>)self, selector, options, block, error);
}

- (<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>AspectToken<span style=color:#f92672>&gt;</span>)<span style=color:#a6e22e>aspect_hookSelector:</span>(<span style=color:#66d9ef>SEL</span>)selector
                      <span style=color:#a6e22e>withOptions:</span>(AspectOptions)options
                       <span style=color:#a6e22e>usingBlock:</span>(<span style=color:#66d9ef>id</span>)block
                            <span style=color:#a6e22e>error:</span>(NSError <span style=color:#f92672>**</span>)error {
    <span style=color:#66d9ef>return</span> aspect_add(self, selector, options, block, error);
}

</code></pre></div><p>两个方法的实现都是调用同一个方法aspect_add，只是传入的参数不同罢了。所以我们只要从aspect_add开始研究即可。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#f92672>-</span> aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError <span style=color:#f92672>**</span>)error
<span style=color:#960050;background-color:#1e0010>└──</span> aspect_add(self, selector, options, block, error);
    <span style=color:#960050;background-color:#1e0010>└──</span> aspect_performLocked
        <span style=color:#960050;background-color:#1e0010>├──</span> aspect_isSelectorAllowedAndTrack
        <span style=color:#960050;background-color:#1e0010>└──</span> aspect_prepareClassAndHookSelector

</code></pre></div><p>这是函数调用栈。从aspect_add开始研究。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>id</span> <span style=color:#a6e22e>aspect_add</span>(<span style=color:#66d9ef>id</span> self, <span style=color:#66d9ef>SEL</span> selector, AspectOptions options, <span style=color:#66d9ef>id</span> block, NSError <span style=color:#f92672>**</span>error) {
    NSCParameterAssert(self);
    NSCParameterAssert(selector);
    NSCParameterAssert(block);

    <span style=color:#66d9ef>__block</span> AspectIdentifier <span style=color:#f92672>*</span>identifier <span style=color:#f92672>=</span> nil;
    aspect_performLocked(<span style=color:#f92672>^</span>{
        <span style=color:#66d9ef>if</span> (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) {
            AspectsContainer <span style=color:#f92672>*</span>aspectContainer <span style=color:#f92672>=</span> aspect_getContainerForObject(self, selector);
            identifier <span style=color:#f92672>=</span> [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];
            <span style=color:#66d9ef>if</span> (identifier) {
                [aspectContainer addAspect:identifier withOptions:options];

                <span style=color:#75715e>// Modify the class to allow message interception.
</span><span style=color:#75715e></span>                aspect_prepareClassAndHookSelector(self, selector, error);
            }
        }
    });
    <span style=color:#66d9ef>return</span> identifier;
}

</code></pre></div><p>aspect_add函数一共5个入参，第一个参数是self，selector是外面传进来需要hook的SEL，options是切片的时间，block是切片的执行方法，最后的error是错误。</p><p>aspect_performLocked是一个自旋锁。自旋锁是效率比较高的一种锁，相比@synchronized来说效率高得多。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>aspect_performLocked</span>(dispatch_block_t block) {
    <span style=color:#66d9ef>static</span> OSSpinLock aspect_lock <span style=color:#f92672>=</span> OS_SPINLOCK_INIT;
    OSSpinLockLock(<span style=color:#f92672>&amp;</span>aspect_lock);
    block();
    OSSpinLockUnlock(<span style=color:#f92672>&amp;</span>aspect_lock);
}

</code></pre></div><p>如果对iOS中8大锁不了解的，可以看以下两篇文章</p><p><a href=http://www.jianshu.com/p/ddbe44064ca4>iOS 常见知识点（三）：Lock</a><br><a href=http://www.jianshu.com/p/8781ff49e05b>深入理解 iOS 开发中的锁</a></p><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_12.png alt></p><p>但是自旋锁也是有可能出现问题的：
如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等(busy-wait)状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。<a href=http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/>不再安全的 OSSpinLock</a></p><p>OSSpinLock的问题在于，如果访问这个所的线程不是同一优先级的话，会有死锁的潜在风险。</p><p>这里暂时认为是相同优先级的线程，所以OSSpinLock保证了线程安全。也就是说aspect_performLocked是保护了block的线程安全。</p><p>现在就剩下aspect_isSelectorAllowedAndTrack函数和aspect_prepareClassAndHookSelector函数了。</p><p>接下来先看看aspect_isSelectorAllowedAndTrack函数实现过程。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>static</span> NSSet <span style=color:#f92672>*</span>disallowedSelectorList;
    <span style=color:#66d9ef>static</span> dispatch_once_t pred;
    dispatch_once(<span style=color:#f92672>&amp;</span>pred, <span style=color:#f92672>^</span>{
        disallowedSelectorList <span style=color:#f92672>=</span> [NSSet setWithObjects:<span style=color:#e6db74>@&#34;retain&#34;</span>, <span style=color:#e6db74>@&#34;release&#34;</span>, <span style=color:#e6db74>@&#34;autorelease&#34;</span>, <span style=color:#e6db74>@&#34;forwardInvocation:&#34;</span>, nil];
    });

</code></pre></div><p>先定义了一个NSSet，这里面是一个“黑名单”，是不允许hook的函数名。retain, release, autorelease, forwardInvocation:是不允许被hook的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    NSString <span style=color:#f92672>*</span>selectorName <span style=color:#f92672>=</span> NSStringFromSelector(selector);
    <span style=color:#66d9ef>if</span> ([disallowedSelectorList containsObject:selectorName]) {
        NSString <span style=color:#f92672>*</span>errorDescription <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;Selector %@ is blacklisted.&#34;</span>, selectorName];
        AspectError(AspectErrorSelectorBlacklisted, errorDescription);
        <span style=color:#66d9ef>return</span> NO;
    }


</code></pre></div><p>当检测到selector的函数名是黑名单里面的函数名，立即报错。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    AspectOptions position <span style=color:#f92672>=</span> options<span style=color:#f92672>&amp;</span>AspectPositionFilter;
    <span style=color:#66d9ef>if</span> ([selectorName isEqualToString:<span style=color:#e6db74>@&#34;dealloc&#34;</span>] <span style=color:#f92672>&amp;&amp;</span> position <span style=color:#f92672>!=</span> AspectPositionBefore) {
        NSString <span style=color:#f92672>*</span>errorDesc <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;AspectPositionBefore is the only valid position when hooking dealloc.&#34;</span>;
        AspectError(AspectErrorSelectorDeallocPosition, errorDesc);
        <span style=color:#66d9ef>return</span> NO;
    }

</code></pre></div><p>再次检查如果要切片dealloc，切片时间只能在dealloc之前，如果不是AspectPositionBefore，也要报错。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>[self respondsToSelector:selector] <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>[self.<span style=color:#66d9ef>class</span> instancesRespondToSelector:selector]) {
        NSString <span style=color:#f92672>*</span>errorDesc <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;Unable to find selector -[%@ %@].&#34;</span>, NSStringFromClass(self.<span style=color:#66d9ef>class</span>), selectorName];
        AspectError(AspectErrorDoesNotRespondToSelector, errorDesc);
        <span style=color:#66d9ef>return</span> NO;
    }

</code></pre></div><p>当selector不在黑名单里面了，如果切片是dealloc，且selector在其之前了。这时候就该判断该方法是否存在。如果self和self.class里面都找不到该selector，会报错找不到该方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>if</span> (class_isMetaClass(object_getClass(self))) {
        <span style=color:#66d9ef>Class</span> klass <span style=color:#f92672>=</span> [self <span style=color:#66d9ef>class</span>];
        NSMutableDictionary <span style=color:#f92672>*</span>swizzledClassesDict <span style=color:#f92672>=</span> aspect_getSwizzledClassesDict();
        <span style=color:#66d9ef>Class</span> currentClass <span style=color:#f92672>=</span> [self <span style=color:#66d9ef>class</span>];

        AspectTracker <span style=color:#f92672>*</span>tracker <span style=color:#f92672>=</span> swizzledClassesDict[currentClass];
        <span style=color:#66d9ef>if</span> ([tracker subclassHasHookedSelectorName:selectorName]) {
            NSSet <span style=color:#f92672>*</span>subclassTracker <span style=color:#f92672>=</span> [tracker subclassTrackersHookingSelectorName:selectorName];
            NSSet <span style=color:#f92672>*</span>subclassNames <span style=color:#f92672>=</span> [subclassTracker valueForKey:<span style=color:#e6db74>@&#34;trackedClassName&#34;</span>];
            NSString <span style=color:#f92672>*</span>errorDescription <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;Error: %@ already hooked subclasses: %@. A method can only be hooked once per class hierarchy.&#34;</span>, selectorName, subclassNames];
            AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);
            <span style=color:#66d9ef>return</span> NO;
        }

</code></pre></div><p>class_isMetaClass 先判断是不是元类。接下来的判断都是判断元类里面能否允许被替换方法。</p><p>subclassHasHookedSelectorName会判断当前tracker的subclass里面是否包含selectorName。因为一个方法在一个类的层级里面只能被hook一次。如果已经tracker里面已经包含了一次，那么会报错。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
        <span style=color:#66d9ef>do</span> {
            tracker <span style=color:#f92672>=</span> swizzledClassesDict[currentClass];
            <span style=color:#66d9ef>if</span> ([tracker.selectorNames containsObject:selectorName]) {
                <span style=color:#66d9ef>if</span> (klass <span style=color:#f92672>==</span> currentClass) {
                    <span style=color:#75715e>// Already modified and topmost!
</span><span style=color:#75715e></span>                    <span style=color:#66d9ef>return</span> YES;
                }
                NSString <span style=color:#f92672>*</span>errorDescription <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy.&#34;</span>, selectorName, NSStringFromClass(currentClass)];
                AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);
                <span style=color:#66d9ef>return</span> NO;
            }
        } <span style=color:#66d9ef>while</span> ((currentClass <span style=color:#f92672>=</span> class_getSuperclass(currentClass)));


</code></pre></div><p>在这个do-while循环中，currentClass = class_getSuperclass(currentClass)这个判断会从currentClass的superclass开始，一直往上找，直到这个类为根类NSObject。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
        currentClass <span style=color:#f92672>=</span> klass;
        AspectTracker <span style=color:#f92672>*</span>subclassTracker <span style=color:#f92672>=</span> nil;
        <span style=color:#66d9ef>do</span> {
            tracker <span style=color:#f92672>=</span> swizzledClassesDict[currentClass];
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>tracker) {
                tracker <span style=color:#f92672>=</span> [[AspectTracker alloc] initWithTrackedClass:currentClass];
                swizzledClassesDict[(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>NSCopying<span style=color:#f92672>&gt;</span>)currentClass] <span style=color:#f92672>=</span> tracker;
            }
            <span style=color:#66d9ef>if</span> (subclassTracker) {
                [tracker addSubclassTracker:subclassTracker hookingSelectorName:selectorName];
            } <span style=color:#66d9ef>else</span> {
                [tracker.selectorNames addObject:selectorName];
            }

            <span style=color:#75715e>// All superclasses get marked as having a subclass that is modified.
</span><span style=color:#75715e></span>            subclassTracker <span style=color:#f92672>=</span> tracker;
        }<span style=color:#66d9ef>while</span> ((currentClass <span style=color:#f92672>=</span> class_getSuperclass(currentClass)));

</code></pre></div><p>经过上面合法性hook判断和类方法不允许重复替换的检查后，到此，就可以把要hook的信息记录下来，用AspectTracker标记。在标记过程中，一旦子类被更改，父类也需要跟着一起被标记。do-while的终止条件还是currentClass = class_getSuperclass(currentClass)。</p><p>以上是元类的类方法hook判断合法性的代码。</p><p>如果不是元类，只要不是hook这"retain&rdquo;, &ldquo;release&rdquo;, &ldquo;autorelease&rdquo;, &ldquo;forwardInvocation:&ldquo;4种方法，而且hook “dealloc”方法的时机必须是before，并且selector能被找到，那么方法就可以被hook。</p><p>通过了selector是否能被hook合法性的检查之后，就要获取或者创建AspectsContainer容器了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>// Loads or creates the aspect container.
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> AspectsContainer <span style=color:#f92672>*</span><span style=color:#a6e22e>aspect_getContainerForObject</span>(NSObject <span style=color:#f92672>*</span>self, <span style=color:#66d9ef>SEL</span> selector) {
    NSCParameterAssert(self);
    <span style=color:#66d9ef>SEL</span> aliasSelector <span style=color:#f92672>=</span> aspect_aliasForSelector(selector);
    AspectsContainer <span style=color:#f92672>*</span>aspectContainer <span style=color:#f92672>=</span> objc_getAssociatedObject(self, aliasSelector);
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>aspectContainer) {
        aspectContainer <span style=color:#f92672>=</span> [AspectsContainer new];
        objc_setAssociatedObject(self, aliasSelector, aspectContainer, OBJC_ASSOCIATION_RETAIN);
    }
    <span style=color:#66d9ef>return</span> aspectContainer;
}

</code></pre></div><p>在读取或者创建AspectsContainer之前，第一步是先标记一下selector。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>SEL</span> <span style=color:#a6e22e>aspect_aliasForSelector</span>(<span style=color:#66d9ef>SEL</span> selector) {
    NSCParameterAssert(selector);
 <span style=color:#66d9ef>return</span> NSSelectorFromString([AspectsMessagePrefix stringByAppendingFormat:<span style=color:#e6db74>@&#34;_%@&#34;</span>, NSStringFromSelector(selector)]);
}

</code></pre></div><p>在全局代码里面定义了一个常量字符串</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>static</span> NSString <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> AspectsMessagePrefix <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;aspects_&#34;</span>;

</code></pre></div><p>用这个字符串标记所有的selector，都加上前缀"aspects_"。然后获得其对应的AssociatedObject关联对象，如果获取不到，就创建一个关联对象。最终得到selector有"aspects_&ldquo;前缀，对应的aspectContainer。</p><p>得到了aspectContainer之后，就可以开始准备我们要hook方法的一些信息。这些信息都装在AspectIdentifier中，所以我们需要新建一个AspectIdentifier。</p><p>调用AspectIdentifier的instancetype方法，创建一个新的AspectIdentifier</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>identifierWithSelector:</span>(<span style=color:#66d9ef>SEL</span>)selector <span style=color:#a6e22e>object:</span>(<span style=color:#66d9ef>id</span>)object <span style=color:#a6e22e>options:</span>(AspectOptions)options <span style=color:#a6e22e>block:</span>(<span style=color:#66d9ef>id</span>)block <span style=color:#a6e22e>error:</span>(NSError <span style=color:#f92672>**</span>)error

</code></pre></div><p>这个instancetype方法，只有一种情况会创建失败，那就是aspect_isCompatibleBlockSignature方法返回NO。返回NO就意味着，我们要替换的方法block和要替换的原方法，两者的方法签名是不相符的。（这个函数在上面详解过了，这里不再赘述）。方法签名匹配成功之后，就会创建好一个AspectIdentifier。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
[aspectContainer addAspect:identifier withOptions:options];

</code></pre></div><p>aspectContainer容器会把它加入到容器中。完成了容器和AspectIdentifier初始化之后，就可以开始准备进行hook了。通过options选项分别添加到容器中的beforeAspects,insteadAspects,afterAspects这三个数组</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>// Modify the class to allow message interception.
</span><span style=color:#75715e></span>       aspect_prepareClassAndHookSelector(self, selector, error);

</code></pre></div><p>小结一下，aspect_add干了一些什么准备工作：</p><ol><li>首先调用aspect_performLocked ，利用自旋锁，保证整个操作的线程安全</li><li>接着调用aspect_isSelectorAllowedAndTrack对传进来的参数进行强校验，保证参数合法性。</li><li>接着创建AspectsContainer容器，利用AssociatedObject关联对象动态添加到NSObject分类中作为属性的。</li><li>再由入参selector，option，创建AspectIdentifier实例。AspectIdentifier主要包含了单个的 Aspect的具体信息，包括执行时机，要执行block 所需要用到的具体信息。</li><li>再将单个的 AspectIdentifier 的具体信息加到属性AspectsContainer容器中。通过options选项分别添加到容器中的beforeAspects,insteadAspects,afterAspects这三个数组。</li><li>最后调用prepareClassAndHookSelector准备hook。</li></ol><p><img src=https://img.halfrost.com/Blog/ArticleImage/27_13.png alt></p><h4 id=五-aspects-hook过程详解>五. Aspects hook过程详解</h4><p>先看看函数调用栈的情况</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#f92672>-</span> aspect_prepareClassAndHookSelector(self, selector, error);
  <span style=color:#960050;background-color:#1e0010>├──</span> aspect_hookClass(self, error)
  <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>├──</span>aspect_swizzleClassInPlace
  <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>├──</span>aspect_swizzleForwardInvocation
  <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>│</span>  <span style=color:#960050;background-color:#1e0010>└──</span>__ASPECTS_ARE_BEING_CALLED__
  <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>│</span>       <span style=color:#960050;background-color:#1e0010>├──</span>aspect_aliasForSelector
  <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>│</span>       <span style=color:#960050;background-color:#1e0010>├──</span>aspect_getContainerForClass
  <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>│</span>       <span style=color:#960050;background-color:#1e0010>├──</span>aspect_invoke
  <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>│</span>       <span style=color:#960050;background-color:#1e0010>└──</span>aspect_remove
  <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>└──</span> aspect_hookedGetClass
  <span style=color:#960050;background-color:#1e0010>├──</span> aspect_isMsgForwardIMP
  <span style=color:#960050;background-color:#1e0010>├──</span>aspect_aliasForSelector(selector)
  <span style=color:#960050;background-color:#1e0010>└──</span> aspect_getMsgForwardIMP

</code></pre></div><p>从调用栈可以看出，Aspects hook过程主要分4个阶段，hookClass，ASPECTS_ARE_BEING_CALLED，prepareClassAndHookSelector，remove。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/28_1.jpg alt></p><h5 id=1-hookclass>1. hookClass</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

 NSCParameterAssert(self);
 <span style=color:#66d9ef>Class</span> statedClass <span style=color:#f92672>=</span> self.<span style=color:#66d9ef>class</span>;
 <span style=color:#66d9ef>Class</span> baseClass <span style=color:#f92672>=</span> object_getClass(self);
 NSString <span style=color:#f92672>*</span>className <span style=color:#f92672>=</span> NSStringFromClass(baseClass);

</code></pre></div><p>statedClass 和 baseClass是有区别的的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>Class</span> <span style=color:#a6e22e>object_getClass</span>(<span style=color:#66d9ef>id</span> obj)
{
    <span style=color:#66d9ef>if</span> (obj) <span style=color:#66d9ef>return</span> obj<span style=color:#f92672>-&gt;</span>getIsa();
    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> Nil;
}

+ (<span style=color:#66d9ef>Class</span>)<span style=color:#a6e22e>class</span> {
    <span style=color:#66d9ef>return</span> self;
}


</code></pre></div><p>statedClass 是获取类对象，baseClass是获取到类的isa。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#75715e>// Already subclassed
</span><span style=color:#75715e></span> <span style=color:#66d9ef>if</span> ([className hasSuffix:AspectsSubclassSuffix]) {
  <span style=color:#66d9ef>return</span> baseClass;

        <span style=color:#75715e>// We swizzle a class object, not a single object.
</span><span style=color:#75715e></span> }<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (class_isMetaClass(baseClass)) {
        <span style=color:#66d9ef>return</span> aspect_swizzleClassInPlace((<span style=color:#66d9ef>Class</span>)self);
        <span style=color:#75715e>// Probably a KVO&#39;ed class. Swizzle in place. Also swizzle meta classes in place.
</span><span style=color:#75715e></span>    }<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (statedClass <span style=color:#f92672>!=</span> baseClass) {
        <span style=color:#66d9ef>return</span> aspect_swizzleClassInPlace(baseClass);
    }

</code></pre></div><p>先判断是用来className是否包含hasSuffix:AspectsSubclassSuffix</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>static</span> NSString <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> AspectsSubclassSuffix <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;_Aspects_&#34;</span>;


</code></pre></div><p>如果包含了@"_Aspects_&ldquo;后缀，代表该类已经被hook过了，直接return。
如果不包含@"_Aspects_&ldquo;后缀，再判断是否是baseClass是否是元类，如果是元类，调用aspect_swizzleClassInPlace。如果也不是元类，再判断statedClass 和 baseClass是否相等，如果不相等，说明为KVO过的对象，因为KVO的对象isa指针会指向一个中间类。对KVO中间类调用aspect_swizzleClassInPlace。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>Class</span> <span style=color:#a6e22e>aspect_swizzleClassInPlace</span>(<span style=color:#66d9ef>Class</span> klass) {
    NSCParameterAssert(klass);
    NSString <span style=color:#f92672>*</span>className <span style=color:#f92672>=</span> NSStringFromClass(klass);

    _aspect_modifySwizzledClasses(<span style=color:#f92672>^</span>(NSMutableSet <span style=color:#f92672>*</span>swizzledClasses) {
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>[swizzledClasses containsObject:className]) {
            aspect_swizzleForwardInvocation(klass);
            [swizzledClasses addObject:className];
        }
    });
    <span style=color:#66d9ef>return</span> klass;
}


</code></pre></div><p>_aspect_modifySwizzledClasses会传入一个入参为(NSMutableSet *swizzledClasses)的block，block里面就是判断在这个Set里面是否包含当前的ClassName，如果不包含，就调用aspect_swizzleForwardInvocation()方法，并把className加入到Set集合里面。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>_aspect_modifySwizzledClasses</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>block)(NSMutableSet <span style=color:#f92672>*</span>swizzledClasses)) {
    <span style=color:#66d9ef>static</span> NSMutableSet <span style=color:#f92672>*</span>swizzledClasses;
    <span style=color:#66d9ef>static</span> dispatch_once_t pred;
    dispatch_once(<span style=color:#f92672>&amp;</span>pred, <span style=color:#f92672>^</span>{
        swizzledClasses <span style=color:#f92672>=</span> [NSMutableSet new];
    });
    <span style=color:#66d9ef>@synchronized</span>(swizzledClasses) {
        block(swizzledClasses);
    }
}

</code></pre></div><p>_aspect_modifySwizzledClasses方法里面保证了swizzledClasses这个Set集合是全局唯一的，并且给传入的block加上了线程锁@synchronized( )，保证了block调用中线程是安全的。</p><p>关于调用aspect_swizzleForwardInvocation，将原IMP指向forwardInvocation是下个阶段的事情，我们先把hookClass看完。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>// Default case. Create dynamic subclass.
</span><span style=color:#75715e></span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>subclassName <span style=color:#f92672>=</span> [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;
 <span style=color:#66d9ef>Class</span> subclass <span style=color:#f92672>=</span> objc_getClass(subclassName);

 <span style=color:#66d9ef>if</span> (subclass <span style=color:#f92672>==</span> nil) {
  subclass <span style=color:#f92672>=</span> objc_allocateClassPair(baseClass, subclassName, <span style=color:#ae81ff>0</span>);
  <span style=color:#66d9ef>if</span> (subclass <span style=color:#f92672>==</span> nil) {
            NSString <span style=color:#f92672>*</span>errrorDesc <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;objc_allocateClassPair failed to allocate class %s.&#34;</span>, subclassName];
            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);
            <span style=color:#66d9ef>return</span> nil;
        }

  aspect_swizzleForwardInvocation(subclass);
  aspect_hookedGetClass(subclass, statedClass);
  aspect_hookedGetClass(object_getClass(subclass), statedClass);
  objc_registerClassPair(subclass);
 }

 object_setClass(self, subclass);

</code></pre></div><p>当className没有包含@"_Aspects_&ldquo;后缀，并且也不是元类，也不是KVO的中间类，即statedClass = = baseClass 的情况，于是，默认的新建一个子类subclass。</p><p>到此，我们可以了解到Aspects的设计思想，<strong>hook 是在runtime中动态创建子类的基础上实现的</strong>。所有的 swizzling 操作都发生在子类，这样做的好处是你不需要去更改对象本身的类，也就是，当你在 remove aspects 的时候，如果发现当前对象的 aspect 都被移除了，那么，你可以将 isa 指针重新指回对象本身的类，从而消除了该对象的 swizzling ,同时也不会影响到其他该类的不同对象)这样对原来替换的类或者对象没有任何影响而且可以在子类基础上新增或者删除aspect。</p><p>新建的类的名字，会先加上AspectsSubclassSuffix后缀，即在className后面加上@"_Aspects_"，标记成子类。再调用objc_getClass方法，创建这个子类。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>/***********************************************************************
</span><span style=color:#75715e>* objc_getClass.  Return the id of the named class.  If the class does
</span><span style=color:#75715e>* not exist, call _objc_classLoader and then objc_classHandler, either of 
</span><span style=color:#75715e>* which may create a new class.
</span><span style=color:#75715e>* Warning: doesn&#39;t work if aClassName is the name of a posed-for class&#39;s isa!
</span><span style=color:#75715e>**********************************************************************/</span>
<span style=color:#66d9ef>Class</span> <span style=color:#a6e22e>objc_getClass</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>aClassName)
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>aClassName) <span style=color:#66d9ef>return</span> Nil;

    <span style=color:#75715e>// NO unconnected, YES class handler
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> look_up_class(aClassName, NO, YES);
}

</code></pre></div><p>objc_getClass会调用look_up_class方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>/***********************************************************************
</span><span style=color:#75715e>* look_up_class
</span><span style=color:#75715e>* Look up a class by name, and realize it.
</span><span style=color:#75715e>* Locking: acquires runtimeLock
</span><span style=color:#75715e>**********************************************************************/</span>
<span style=color:#66d9ef>Class</span> <span style=color:#a6e22e>look_up_class</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, 
              <span style=color:#66d9ef>bool</span> includeUnconnected __attribute__((unused)), 
              <span style=color:#66d9ef>bool</span> includeClassHandler __attribute__((unused)))
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>name) <span style=color:#66d9ef>return</span> nil;

    <span style=color:#66d9ef>Class</span> result;
    <span style=color:#66d9ef>bool</span> unrealized;
    {
        rwlock_reader_t lock(runtimeLock);
        result <span style=color:#f92672>=</span> getClass(name);
        unrealized <span style=color:#f92672>=</span> result  <span style=color:#f92672>&amp;&amp;</span>  <span style=color:#f92672>!</span>result<span style=color:#f92672>-&gt;</span>isRealized();
    }
    <span style=color:#66d9ef>if</span> (unrealized) {
        rwlock_writer_t lock(runtimeLock);
        realizeClass(result);
    }
    <span style=color:#66d9ef>return</span> result;
}


</code></pre></div><p>这个方法会去查看有没有实现叫name的class，查看过程中会用到rwlock_reader_t lock(runtimeLock)，读写锁，底层是用pthread_rwlock_t实现的。</p><p>由于是我们刚刚新建的一个子类名，很有可能是objc_getClass()返回nil。那么我们需要新建这个子类。调用objc_allocateClassPair()方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>/***********************************************************************
</span><span style=color:#75715e>* objc_allocateClassPair
</span><span style=color:#75715e>* fixme
</span><span style=color:#75715e>* Locking: acquires runtimeLock
</span><span style=color:#75715e>**********************************************************************/</span>
<span style=color:#66d9ef>Class</span> <span style=color:#a6e22e>objc_allocateClassPair</span>(<span style=color:#66d9ef>Class</span> superclass, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, 
                             size_t extraBytes)
{
    <span style=color:#66d9ef>Class</span> cls, meta;

    rwlock_writer_t lock(runtimeLock);

    <span style=color:#75715e>// Fail if the class name is in use.
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Fail if the superclass isn&#39;t kosher.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (getClass(name)  <span style=color:#f92672>||</span>  <span style=color:#f92672>!</span>verifySuperclass(superclass, true<span style=color:#75715e>/*rootOK*/</span>)) {
        <span style=color:#66d9ef>return</span> nil;
    }

    <span style=color:#75715e>// Allocate new classes.
</span><span style=color:#75715e></span>    cls  <span style=color:#f92672>=</span> alloc_class_for_subclass(superclass, extraBytes);
    meta <span style=color:#f92672>=</span> alloc_class_for_subclass(superclass, extraBytes);

    <span style=color:#75715e>// fixme mangle the name if it looks swift-y?
</span><span style=color:#75715e></span>    objc_initializeClassPair_internal(superclass, name, cls, meta);

    <span style=color:#66d9ef>return</span> cls;
}

</code></pre></div><p>调用objc_allocateClassPair会新建一个子类，它的父类是入参superclass。</p><p>如果新建的子类subclass = = nil，就会报错，objc_allocateClassPair failed to allocate class。</p><p>aspect_swizzleForwardInvocation(subclass)这是下一阶段的事情，主要作用是替换当前类forwardInvocation方法的实现为__ASPECTS_ARE_BEING_CALLED__，先略过。</p><p>接着调用aspect_hookedGetClass( ) 方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>aspect_hookedGetClass</span>(<span style=color:#66d9ef>Class</span> <span style=color:#66d9ef>class</span>, <span style=color:#66d9ef>Class</span> statedClass) {
    NSCParameterAssert(<span style=color:#66d9ef>class</span>);
    NSCParameterAssert(statedClass);
 Method method <span style=color:#f92672>=</span> class_getInstanceMethod(<span style=color:#66d9ef>class</span>, <span style=color:#66d9ef>@selector</span>(<span style=color:#66d9ef>class</span>));
 <span style=color:#66d9ef>IMP</span> newIMP <span style=color:#f92672>=</span> imp_implementationWithBlock(<span style=color:#f92672>^</span>(<span style=color:#66d9ef>id</span> self) {
  <span style=color:#66d9ef>return</span> statedClass;
 });
 class_replaceMethod(<span style=color:#66d9ef>class</span>, <span style=color:#66d9ef>@selector</span>(<span style=color:#66d9ef>class</span>), newIMP, method_getTypeEncoding(method));
}

</code></pre></div><p>aspect_hookedGetClass方法是把class的实例方法替换成返回statedClass，也就是说把调用class时候的isa指向了statedClass了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
  aspect_hookedGetClass(subclass, statedClass);
  aspect_hookedGetClass(object_getClass(subclass), statedClass);

</code></pre></div><p>这两句的意图我们也就明白了。</p><p>第一句是把subclass的isa指向了statedClass，第二句是把subclass的元类的isa，也指向了statedClass。</p><p>最后调用objc_registerClassPair( ) 注册刚刚新建的子类subclass，再调用object_setClass(self, subclass);把当前self的isa指向子类subclass。</p><p>至此，hookClass阶段就完成了，成功的把self hook成了其子类 xxx_Aspects_。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/28_2.png alt></p><h5 id=2-aspects_are_being_called>2. ASPECTS_ARE_BEING_CALLED</h5><p>在上一阶段hookClass的时候，有几处都调用了aspect_swizzleForwardInvocation方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> NSString <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> AspectsForwardInvocationSelectorName <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;__aspects_forwardInvocation:&#34;</span>;

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>aspect_swizzleForwardInvocation</span>(<span style=color:#66d9ef>Class</span> klass) {
    NSCParameterAssert(klass);
    <span style=color:#75715e>// If there is no method, replace will act like class_addMethod.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>IMP</span> originalImplementation <span style=color:#f92672>=</span> class_replaceMethod(klass, <span style=color:#66d9ef>@selector</span>(forwardInvocation:), (<span style=color:#66d9ef>IMP</span>)__ASPECTS_ARE_BEING_CALLED__, <span style=color:#e6db74>&#34;v@:@&#34;</span>);
    <span style=color:#66d9ef>if</span> (originalImplementation) {
        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, <span style=color:#e6db74>&#34;v@:@&#34;</span>);
    }
    AspectLog(<span style=color:#e6db74>@&#34;Aspects: %@ is now aspect aware.&#34;</span>, NSStringFromClass(klass));
}

</code></pre></div><p>aspect_swizzleForwardInvocation就是整个Aspects hook方法的开始。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>/***********************************************************************
</span><span style=color:#75715e>* class_replaceMethod
</span><span style=color:#75715e>**********************************************************************/</span>
<span style=color:#66d9ef>IMP</span> <span style=color:#a6e22e>class_replaceMethod</span>(<span style=color:#66d9ef>Class</span> cls, <span style=color:#66d9ef>SEL</span> name, <span style=color:#66d9ef>IMP</span> imp, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>types)
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>cls) <span style=color:#66d9ef>return</span> nil;

    <span style=color:#66d9ef>return</span> _class_addMethod(cls, name, imp, types, YES);
}

</code></pre></div><p>调用class_replaceMethod方法，实际底层实现是调用_class_addMethod方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>IMP</span> <span style=color:#a6e22e>_class_addMethod</span>(<span style=color:#66d9ef>Class</span> cls, <span style=color:#66d9ef>SEL</span> name, <span style=color:#66d9ef>IMP</span> imp, 
                            <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>types, <span style=color:#66d9ef>bool</span> replace)
{
    old_method <span style=color:#f92672>*</span>m;
    <span style=color:#66d9ef>IMP</span> result <span style=color:#f92672>=</span> nil;

    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>types) types <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;

    mutex_locker_t lock(methodListLock);

    <span style=color:#66d9ef>if</span> ((m <span style=color:#f92672>=</span> _findMethodInClass(cls, name))) {
        <span style=color:#75715e>// already exists
</span><span style=color:#75715e></span>        <span style=color:#75715e>// fixme atomic
</span><span style=color:#75715e></span>        result <span style=color:#f92672>=</span> method_getImplementation((Method)m);
        <span style=color:#66d9ef>if</span> (replace) {
            method_setImplementation((Method)m, imp);
        }
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#75715e>// fixme could be faster
</span><span style=color:#75715e></span>        old_method_list <span style=color:#f92672>*</span>mlist <span style=color:#f92672>=</span> 
            (old_method_list <span style=color:#f92672>*</span>)calloc(<span style=color:#66d9ef>sizeof</span>(old_method_list), <span style=color:#ae81ff>1</span>);
        mlist<span style=color:#f92672>-&gt;</span>obsolete <span style=color:#f92672>=</span> fixed_up_method_list;
        mlist<span style=color:#f92672>-&gt;</span>method_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
        mlist<span style=color:#f92672>-&gt;</span>method_list[<span style=color:#ae81ff>0</span>].method_name <span style=color:#f92672>=</span> name;
        mlist<span style=color:#f92672>-&gt;</span>method_list[<span style=color:#ae81ff>0</span>].method_types <span style=color:#f92672>=</span> strdup(types);
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ignoreSelector(name)) {
            mlist<span style=color:#f92672>-&gt;</span>method_list[<span style=color:#ae81ff>0</span>].method_imp <span style=color:#f92672>=</span> imp;
        } <span style=color:#66d9ef>else</span> {
            mlist<span style=color:#f92672>-&gt;</span>method_list[<span style=color:#ae81ff>0</span>].method_imp <span style=color:#f92672>=</span> (<span style=color:#66d9ef>IMP</span>)<span style=color:#f92672>&amp;</span>_objc_ignored_method;
        }
        
        _objc_insertMethods(cls, mlist, nil);
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(cls<span style=color:#f92672>-&gt;</span>info <span style=color:#f92672>&amp;</span> CLS_CONSTRUCTING)) {
            flush_caches(cls, NO);
        } <span style=color:#66d9ef>else</span> {
            <span style=color:#75715e>// in-construction class has no subclasses
</span><span style=color:#75715e></span>            flush_cache(cls);
        }
        result <span style=color:#f92672>=</span> nil;
    }

    <span style=color:#66d9ef>return</span> result;
}

</code></pre></div><p>从上述源码中，我们可以看到，先_findMethodInClass(cls, name)，从cls中查找有没有name的方法。如果有，并且能找到对应的IMP的话，就进行替换method_setImplementation((Method)m, imp)，把name方法的IMP替换成imp。这种方式_class_addMethod返回的是name方法对应的IMP，实际上就是我们替换完的imp。</p><p>如果在cls中没有找到name方法，那么就添加该方法，在mlist -> method_list[0] 的位置插入新的name方法，对应的IMP就是传入的imp。这种方式_class_addMethod返回的是nil。</p><p>回到aspect_swizzleForwardInvocation中，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>IMP</span> originalImplementation <span style=color:#f92672>=</span> class_replaceMethod(klass, <span style=color:#66d9ef>@selector</span>(forwardInvocation:), (<span style=color:#66d9ef>IMP</span>)__ASPECTS_ARE_BEING_CALLED__, <span style=color:#e6db74>&#34;v@:@&#34;</span>);
<span style=color:#66d9ef>if</span> (originalImplementation) {
   class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, <span style=color:#e6db74>&#34;v@:@&#34;</span>);
}

</code></pre></div><p>把forwardInvocation:的IMP替换成__ASPECTS_ARE_BEING_CALLED__ 。如果在klass里面找不到forwardInvocation:方法，就会新添加该方法。</p><p><del>由于子类本身并没有实现 forwardInvocation ，隐藏返回的 originalImplementation 将为空值，所以也不会生成 NSSelectorFromString(AspectsForwardInvocationSelectorName) 。所以还需要_class_addMethod会为我们添加了forwardInvocation:方法的实现</del></p><p>谢谢简书的大神 @zhao0 指点，这个坑在Aspects 1.4.1中已经修复了。</p><p>在aspect_swizzleForwardInvocation中，class_replaceMethod返回的是原方法的IMP，originalImplementation不为空的话说明原方法有实现，添加一个新方法__aspects_forwardInvocation:指向了原来的originalImplementation，在__ASPECTS_ARE_BEING_CALLED__那里如果不能处理，判断是否有实现__aspects_forwardInvocation，有的话就转发，这样就可以解决不兼容的问题。</p><p>如果originalImplementation返回的不是nil，就说明已经替换成功。替换完方法之后，我们在klass中再加入一个叫“__aspects_forwardInvocation:”的方法，对应的实现也是(IMP)__ASPECTS_ARE_BEING_CALLED__。</p><p>接下来就是整个Aspects的核心实现了：__ASPECTS_ARE_BEING_CALLED__</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__ASPECTS_ARE_BEING_CALLED__</span>(__unsafe_unretained NSObject <span style=color:#f92672>*</span>self, <span style=color:#66d9ef>SEL</span> selector, NSInvocation <span style=color:#f92672>*</span>invocation) {
    NSCParameterAssert(self);
    NSCParameterAssert(invocation);
    <span style=color:#66d9ef>SEL</span> originalSelector <span style=color:#f92672>=</span> invocation.selector;
    <span style=color:#66d9ef>SEL</span> aliasSelector <span style=color:#f92672>=</span> aspect_aliasForSelector(invocation.selector);
    invocation.selector <span style=color:#f92672>=</span> aliasSelector;
    AspectsContainer <span style=color:#f92672>*</span>objectContainer <span style=color:#f92672>=</span> objc_getAssociatedObject(self, aliasSelector);
    AspectsContainer <span style=color:#f92672>*</span>classContainer <span style=color:#f92672>=</span> aspect_getContainerForClass(object_getClass(self), aliasSelector);
    AspectInfo <span style=color:#f92672>*</span>info <span style=color:#f92672>=</span> [[AspectInfo alloc] initWithInstance:self invocation:invocation];
    NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>,info.arguments);
    NSArray <span style=color:#f92672>*</span>aspectsToRemove <span style=color:#f92672>=</span> nil;

    <span style=color:#960050;background-color:#1e0010>……</span> <span style=color:#960050;background-color:#1e0010>……</span>
}
</code></pre></div><p>这一段是hook前的准备工作：</p><ol><li>获取原始的selector</li><li>获取带有aspects_xxxx前缀的方法</li><li>替换selector</li><li>获取实例对象的容器objectContainer，这里是之前aspect_add关联过的对象。</li><li>获取获得类对象容器classContainer</li><li>初始化AspectInfo，传入self、invocation参数</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#75715e>// Before hooks.
</span><span style=color:#75715e></span>    aspect_invoke(classContainer.beforeAspects, info);
    aspect_invoke(objectContainer.beforeAspects, info);

</code></pre></div><p>调用宏定义执行Aspects切片功能</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>#define aspect_invoke(aspects, info) \
</span><span style=color:#75715e>for (AspectIdentifier *aspect in aspects) {\
</span><span style=color:#75715e>    [aspect invokeWithInfo:info];\
</span><span style=color:#75715e>    if (aspect.options &amp; AspectOptionAutomaticRemoval) { \
</span><span style=color:#75715e>        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \
</span><span style=color:#75715e>    } \
</span><span style=color:#75715e>}
</span><span style=color:#75715e></span>
</code></pre></div><p>之所以这里用一个宏定义来实现里面的功能，是为了获得一个更加清晰的堆栈信息。</p><p>宏定义里面就做了两件事情，一个是执行了[aspect invokeWithInfo:info]方法，一个是把需要remove的Aspects加入等待被移除的数组中。</p><p>[aspect invokeWithInfo:info]方法在上篇里面详细分析过了其实现，这个函数的主要目的是把blockSignature初始化blockSignature得到invocation。然后处理参数，如果参数block中的参数大于1个，则把传入的AspectInfo放入blockInvocation中。然后从originalInvocation中取出参数给blockInvocation赋值。最后调用[blockInvocation invokeWithTarget:self.block];这里Target设置为self.block。也就执行了我们hook方法的block。</p><p>所以只要调用aspect_invoke(classContainer.Aspects, info);这个核心替换的方法，就能hook我们原有的SEL。对应的，函数第一个参数分别传入的是classContainer.beforeAspects、classContainer.insteadAspects、classContainer.afterAspects就能对应的实现before、instead、after对应时间的Aspects切片的hook。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#75715e>// Instead hooks.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>BOOL</span> respondsToAlias <span style=color:#f92672>=</span> YES;
    <span style=color:#66d9ef>if</span> (objectContainer.insteadAspects.count <span style=color:#f92672>||</span> classContainer.insteadAspects.count) {
        aspect_invoke(classContainer.insteadAspects, info);
        aspect_invoke(objectContainer.insteadAspects, info);
    }<span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>Class</span> klass <span style=color:#f92672>=</span> object_getClass(invocation.target);
        <span style=color:#66d9ef>do</span> {
            <span style=color:#66d9ef>if</span> ((respondsToAlias <span style=color:#f92672>=</span> [klass instancesRespondToSelector:aliasSelector])) {
                [invocation invoke];
                <span style=color:#66d9ef>break</span>;
            }
        }<span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>respondsToAlias <span style=color:#f92672>&amp;&amp;</span> (klass <span style=color:#f92672>=</span> class_getSuperclass(klass)));
    }


</code></pre></div><p>这一段代码是实现Instead hooks的。先判断当前insteadAspects是否有数据，如果没有数据则判断当前继承链是否能响应aspects_xxx方法,如果能，则直接调用aliasSelector。<strong>注意：这里的aliasSelector是原方法method</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#75715e>// After hooks.
</span><span style=color:#75715e></span>    aspect_invoke(classContainer.afterAspects, info);
    aspect_invoke(objectContainer.afterAspects, info);


</code></pre></div><p>这两行是对应的执行After hooks的。原理如上。</p><p>至此，before、instead、after对应时间的Aspects切片的hook如果能被执行的，都执行完毕了。</p><p>如果hook没有被正常执行，那么就应该执行原来的方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#75715e>// If no hooks are installed, call original implementation (usually to throw an exception)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>respondsToAlias) {
        invocation.selector <span style=color:#f92672>=</span> originalSelector;
        <span style=color:#66d9ef>SEL</span> originalForwardInvocationSEL <span style=color:#f92672>=</span> NSSelectorFromString(AspectsForwardInvocationSelectorName);
        <span style=color:#66d9ef>if</span> ([self respondsToSelector:originalForwardInvocationSEL]) {
            ((<span style=color:#66d9ef>void</span>( <span style=color:#f92672>*</span>)(<span style=color:#66d9ef>id</span>, <span style=color:#66d9ef>SEL</span>, NSInvocation <span style=color:#f92672>*</span>))objc_msgSend)(self, originalForwardInvocationSEL, invocation);
        }<span style=color:#66d9ef>else</span> {
            [self doesNotRecognizeSelector:invocation.selector];
        }
    }

</code></pre></div><p>invocation.selector先换回原来的originalSelector，如果没有被hook成功，那么AspectsForwardInvocationSelectorName还能再拿到原来的IMP对应的SEL。如果能相应，就调用原来的SEL，否则就报出doesNotRecognizeSelector的错误。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
[aspectsToRemove makeObjectsPerformSelector:<span style=color:#66d9ef>@selector</span>(remove)];

</code></pre></div><p>最后调用移除方法，移除hook。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/28_3.png alt></p><h5 id=3-prepareclassandhookselector>3. prepareClassAndHookSelector</h5><p>现在又要回到上篇中提到的aspect_prepareClassAndHookSelector方法中来了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>aspect_prepareClassAndHookSelector</span>(NSObject <span style=color:#f92672>*</span>self, <span style=color:#66d9ef>SEL</span> selector, NSError <span style=color:#f92672>**</span>error) {
    NSCParameterAssert(selector);
    <span style=color:#66d9ef>Class</span> klass <span style=color:#f92672>=</span> aspect_hookClass(self, error);
    Method targetMethod <span style=color:#f92672>=</span> class_getInstanceMethod(klass, selector);
    <span style=color:#66d9ef>IMP</span> targetMethodIMP <span style=color:#f92672>=</span> method_getImplementation(targetMethod);
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>aspect_isMsgForwardIMP(targetMethodIMP)) {
        <span style=color:#75715e>// Make a method alias for the existing method implementation, it not already copied.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>typeEncoding <span style=color:#f92672>=</span> method_getTypeEncoding(targetMethod);
        <span style=color:#66d9ef>SEL</span> aliasSelector <span style=color:#f92672>=</span> aspect_aliasForSelector(selector);
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>[klass instancesRespondToSelector:aliasSelector]) {
            __unused <span style=color:#66d9ef>BOOL</span> addedAlias <span style=color:#f92672>=</span> class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
            NSCAssert(addedAlias, <span style=color:#e6db74>@&#34;Original implementation for %@ is already copied to %@ on %@&#34;</span>, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);
        }

        <span style=color:#75715e>// We use forwardInvocation to hook in.
</span><span style=color:#75715e></span>        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);
        AspectLog(<span style=color:#e6db74>@&#34;Aspects: Installed hook for -[%@ %@].&#34;</span>, klass, NSStringFromSelector(selector));
    }
}

</code></pre></div><p>klass是我们hook完原始的class之后得到的子类，名字是带有_Aspects_后缀的子类。因为它是当前类的子类，所以也可以从它这里获取到原有的selector的IMP。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>BOOL</span> <span style=color:#a6e22e>aspect_isMsgForwardIMP</span>(<span style=color:#66d9ef>IMP</span> impl) {
    <span style=color:#66d9ef>return</span> impl <span style=color:#f92672>==</span> _objc_msgForward
<span style=color:#75715e>#if !defined(__arm64__)
</span><span style=color:#75715e></span>    <span style=color:#f92672>||</span> impl <span style=color:#f92672>==</span> (<span style=color:#66d9ef>IMP</span>)_objc_msgForward_stret
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    ;
}


</code></pre></div><p>这里是判断当前IMP是不是_objc_msgForward或者_objc_msgForward_stret，即判断当前IMP是不是消息转发。</p><p>如果不是消息转发，就先获取当前原始的selector对应的IMP的方法编码typeEncoding。</p><p>如果子类里面不能响应aspects_xxxx，就为klass添加aspects_xxxx方法，方法的实现为原生方法的实现。</p><p>Aspects整个hook的入口就是这句话：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);

</code></pre></div><p>由于我们将slector指向_objc_msgForward 和_objc_msgForward_stret，可想而知，当selector被执行的时候，也会触发消息转发从而进入forwardInvocation，而我们又对forwardInvacation进行了swizzling，因此，最终转入我们自己的处理逻辑代码中。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/28_4.png alt></p><h5 id=4-aspect_remove>4. aspect_remove</h5><p>aspect_remove整个销毁过程的函数调用栈</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#f92672>-</span> aspect_remove(AspectIdentifier <span style=color:#f92672>*</span>aspect, NSError <span style=color:#f92672>**</span>error)
  <span style=color:#960050;background-color:#1e0010>└──</span> aspect_cleanupHookedClassAndSelector
      <span style=color:#960050;background-color:#1e0010>├──</span>aspect_deregisterTrackedSelector
      <span style=color:#960050;background-color:#1e0010>│</span>   <span style=color:#960050;background-color:#1e0010>└──</span> aspect_getSwizzledClassesDict
      <span style=color:#960050;background-color:#1e0010>├──</span>aspect_destroyContainerForObject
      <span style=color:#960050;background-color:#1e0010>└──</span> aspect_undoSwizzleClassInPlace
          <span style=color:#960050;background-color:#1e0010>└──</span> _aspect_modifySwizzledClasses
                <span style=color:#960050;background-color:#1e0010>└──</span>aspect_undoSwizzleForwardInvocation

</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>BOOL</span> <span style=color:#a6e22e>aspect_remove</span>(AspectIdentifier <span style=color:#f92672>*</span>aspect, NSError <span style=color:#f92672>**</span>error) {
    NSCAssert([aspect isKindOfClass:AspectIdentifier.<span style=color:#66d9ef>class</span>], <span style=color:#e6db74>@&#34;Must have correct type.&#34;</span>);
    
    <span style=color:#66d9ef>__block</span> <span style=color:#66d9ef>BOOL</span> success <span style=color:#f92672>=</span> NO;
    aspect_performLocked(<span style=color:#f92672>^</span>{
        <span style=color:#66d9ef>id</span> self <span style=color:#f92672>=</span> aspect.object; <span style=color:#75715e>// strongify
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (self) {
            AspectsContainer <span style=color:#f92672>*</span>aspectContainer <span style=color:#f92672>=</span> aspect_getContainerForObject(self, aspect.selector);
            success <span style=color:#f92672>=</span> [aspectContainer removeAspect:aspect];
            
            aspect_cleanupHookedClassAndSelector(self, aspect.selector);
            <span style=color:#75715e>// destroy token
</span><span style=color:#75715e></span>            aspect.object <span style=color:#f92672>=</span> nil;
            aspect.block <span style=color:#f92672>=</span> nil;
            aspect.selector <span style=color:#f92672>=</span> NULL;
        }<span style=color:#66d9ef>else</span> {
            NSString <span style=color:#f92672>*</span>errrorDesc <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;Unable to deregister hook. Object already deallocated: %@&#34;</span>, aspect];
            AspectError(AspectErrorRemoveObjectAlreadyDeallocated, errrorDesc);
        }
    });
    <span style=color:#66d9ef>return</span> success;
}


</code></pre></div><p>aspect_remove 是整个 aspect_add的逆过程。
aspect_performLocked是保证线程安全。把AspectsContainer都置为空，remove最关键的过程就是aspect_cleanupHookedClassAndSelector(self, aspect.selector);移除之前hook的class和selector。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>aspect_cleanupHookedClassAndSelector</span>(NSObject <span style=color:#f92672>*</span>self, <span style=color:#66d9ef>SEL</span> selector) {
    NSCParameterAssert(self);
    NSCParameterAssert(selector);
    
    <span style=color:#66d9ef>Class</span> klass <span style=color:#f92672>=</span> object_getClass(self);
    <span style=color:#66d9ef>BOOL</span> isMetaClass <span style=color:#f92672>=</span> class_isMetaClass(klass);
    <span style=color:#66d9ef>if</span> (isMetaClass) {
        klass <span style=color:#f92672>=</span> (<span style=color:#66d9ef>Class</span>)self;
    }

    <span style=color:#960050;background-color:#1e0010>……</span>  <span style=color:#960050;background-color:#1e0010>……</span>
}

</code></pre></div><p>klass是现在的class，如果是元类，就转换成元类。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#75715e>// Check if the method is marked as forwarded and undo that.
</span><span style=color:#75715e></span>    Method targetMethod <span style=color:#f92672>=</span> class_getInstanceMethod(klass, selector);
    <span style=color:#66d9ef>IMP</span> targetMethodIMP <span style=color:#f92672>=</span> method_getImplementation(targetMethod);
    <span style=color:#66d9ef>if</span> (aspect_isMsgForwardIMP(targetMethodIMP)) {
        <span style=color:#75715e>// Restore the original method implementation.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>typeEncoding <span style=color:#f92672>=</span> method_getTypeEncoding(targetMethod);
        <span style=color:#66d9ef>SEL</span> aliasSelector <span style=color:#f92672>=</span> aspect_aliasForSelector(selector);
        Method originalMethod <span style=color:#f92672>=</span> class_getInstanceMethod(klass, aliasSelector);
        <span style=color:#66d9ef>IMP</span> originalIMP <span style=color:#f92672>=</span> method_getImplementation(originalMethod);
        NSCAssert(originalMethod, <span style=color:#e6db74>@&#34;Original implementation for %@ not found %@ on %@&#34;</span>, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);
        
        class_replaceMethod(klass, selector, originalIMP, typeEncoding);
        AspectLog(<span style=color:#e6db74>@&#34;Aspects: Removed hook for -[%@ %@].&#34;</span>, klass, NSStringFromSelector(selector));
    }


</code></pre></div><p>先回复MsgForward消息转发函数，获得方法签名，然后把原始转发方法替换回我们hook过的方法。</p><p>这里有一个需要注意的问题。</p><p>如果当前Student有2个实例，stu1和stu2，并且他们都同时hook了相同的方法study( )，stu2在执行完aspect_remove，把stu2的study( )方法还原了。这里会把stu1的study( )方法也还原了。因为remove方法这个操作是对整个类的所有实例都生效的。</p><p>要想每个实例还原各自的方法，不影响其他实例，上述这段代码删除即可。因为在执行 remove 操作的时候，其实和这个对象相关的数据结构都已经被清除了，即使不去恢复 stu2 的study( ) 的执行，在进入 __ASPECTS_ARE_BEING_CALLED__，由于这个没有响应的 aspects ，其实会直接跳到原来的处理逻辑，并不会有其他附加影响。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>aspect_deregisterTrackedSelector</span>(<span style=color:#66d9ef>id</span> self, <span style=color:#66d9ef>SEL</span> selector) {
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>class_isMetaClass(object_getClass(self))) <span style=color:#66d9ef>return</span>;
    
    NSMutableDictionary <span style=color:#f92672>*</span>swizzledClassesDict <span style=color:#f92672>=</span> aspect_getSwizzledClassesDict();
    NSString <span style=color:#f92672>*</span>selectorName <span style=color:#f92672>=</span> NSStringFromSelector(selector);
    <span style=color:#66d9ef>Class</span> currentClass <span style=color:#f92672>=</span> [self <span style=color:#66d9ef>class</span>];
    AspectTracker <span style=color:#f92672>*</span>subclassTracker <span style=color:#f92672>=</span> nil;
    <span style=color:#66d9ef>do</span> {
        AspectTracker <span style=color:#f92672>*</span>tracker <span style=color:#f92672>=</span> swizzledClassesDict[currentClass];
        <span style=color:#66d9ef>if</span> (subclassTracker) {
            [tracker removeSubclassTracker:subclassTracker hookingSelectorName:selectorName];
        } <span style=color:#66d9ef>else</span> {
            [tracker.selectorNames removeObject:selectorName];
        }
        <span style=color:#66d9ef>if</span> (tracker.selectorNames.count <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> tracker.selectorNamesToSubclassTrackers) {
            [swizzledClassesDict removeObjectForKey:currentClass];
        }
        subclassTracker <span style=color:#f92672>=</span> tracker;
    }<span style=color:#66d9ef>while</span> ((currentClass <span style=color:#f92672>=</span> class_getSuperclass(currentClass)));
}


</code></pre></div><p>还要移除AspectTracker里面所有标记的swizzledClassesDict。销毁全部记录的selector。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
   AspectsContainer <span style=color:#f92672>*</span>container <span style=color:#f92672>=</span> aspect_getContainerForObject(self, selector);
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>container.hasAspects) {
        <span style=color:#75715e>// Destroy the container
</span><span style=color:#75715e></span>        aspect_destroyContainerForObject(self, selector);
        
        <span style=color:#75715e>// Figure out how the class was modified to undo the changes.
</span><span style=color:#75715e></span>        NSString <span style=color:#f92672>*</span>className <span style=color:#f92672>=</span> NSStringFromClass(klass);
        <span style=color:#66d9ef>if</span> ([className hasSuffix:AspectsSubclassSuffix]) {
            <span style=color:#66d9ef>Class</span> originalClass <span style=color:#f92672>=</span> NSClassFromString([className stringByReplacingOccurrencesOfString:AspectsSubclassSuffix withString:<span style=color:#e6db74>@&#34;&#34;</span>]);
            NSCAssert(originalClass <span style=color:#f92672>!=</span> nil, <span style=color:#e6db74>@&#34;Original class must exist&#34;</span>);
            object_setClass(self, originalClass);
            AspectLog(<span style=color:#e6db74>@&#34;Aspects: %@ has been restored.&#34;</span>, NSStringFromClass(originalClass));
            
            <span style=color:#75715e>// We can only dispose the class pair if we can ensure that no instances exist using our subclass.
</span><span style=color:#75715e></span>            <span style=color:#75715e>// Since we don&#39;t globally track this, we can&#39;t ensure this - but there&#39;s also not much overhead in keeping it around.
</span><span style=color:#75715e></span>            <span style=color:#75715e>//objc_disposeClassPair(object.class);
</span><span style=color:#75715e></span>        }<span style=color:#66d9ef>else</span> {
            <span style=color:#75715e>// Class is most likely swizzled in place. Undo that.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (isMetaClass) {
                aspect_undoSwizzleClassInPlace((<span style=color:#66d9ef>Class</span>)self);
            }<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (self.<span style=color:#66d9ef>class</span> <span style=color:#f92672>!=</span> klass) {
                aspect_undoSwizzleClassInPlace(klass);
            }
        }
    }


</code></pre></div><p>最后，我们还需要还原类的AssociatedObject关联对象，以及用到的AspectsContainer容器。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>aspect_destroyContainerForObject</span>(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>NSObject<span style=color:#f92672>&gt;</span> self, <span style=color:#66d9ef>SEL</span> selector) {
    NSCParameterAssert(self);
    <span style=color:#66d9ef>SEL</span> aliasSelector <span style=color:#f92672>=</span> aspect_aliasForSelector(selector);
    objc_setAssociatedObject(self, aliasSelector, nil, OBJC_ASSOCIATION_RETAIN);
}

</code></pre></div><p>这个方法销毁了AspectsContainer容器，并且把关联对象也置成了nil。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>aspect_undoSwizzleClassInPlace</span>(<span style=color:#66d9ef>Class</span> klass) {
    NSCParameterAssert(klass);
    NSString <span style=color:#f92672>*</span>className <span style=color:#f92672>=</span> NSStringFromClass(klass);
    
    _aspect_modifySwizzledClasses(<span style=color:#f92672>^</span>(NSMutableSet <span style=color:#f92672>*</span>swizzledClasses) {
        <span style=color:#66d9ef>if</span> ([swizzledClasses containsObject:className]) {
            aspect_undoSwizzleForwardInvocation(klass);
            [swizzledClasses removeObject:className];
        }
    });
}


</code></pre></div><p>aspect_undoSwizzleClassInPlace会再调用aspect_undoSwizzleForwardInvocation方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>aspect_undoSwizzleForwardInvocation</span>(<span style=color:#66d9ef>Class</span> klass) {
    NSCParameterAssert(klass);
    Method originalMethod <span style=color:#f92672>=</span> class_getInstanceMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName));
    Method objectMethod <span style=color:#f92672>=</span> class_getInstanceMethod(NSObject.<span style=color:#66d9ef>class</span>, <span style=color:#66d9ef>@selector</span>(forwardInvocation:));
    <span style=color:#75715e>// There is no class_removeMethod, so the best we can do is to retore the original implementation, or use a dummy.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>IMP</span> originalImplementation <span style=color:#f92672>=</span> method_getImplementation(originalMethod <span style=color:#f92672>?:</span> objectMethod);
    class_replaceMethod(klass, <span style=color:#66d9ef>@selector</span>(forwardInvocation:), originalImplementation, <span style=color:#e6db74>&#34;v@:@&#34;</span>);
    
    AspectLog(<span style=color:#e6db74>@&#34;Aspects: %@ has been restored.&#34;</span>, NSStringFromClass(klass));
}

</code></pre></div><p>最后还原ForwardInvocation的Swizzling，把原来的ForwardInvocation再交换回来。</p><h4 id=六-关于aspects-的一些-坑>六. 关于Aspects 的一些 “坑”</h4><p><img src=https://img.halfrost.com/Blog/ArticleImage/28_5.png alt></p><p>在Aspects这个库了，用到了Method Swizzling有几处，这几处如果处理不好，就会掉“坑”里了。</p><h5 id=1aspect_prepareclassandhookselector-中可能遇到的坑>1.aspect_prepareClassAndHookSelector 中可能遇到的“坑”</h5><p>在aspect_prepareClassAndHookSelector方法中，会把原始的selector hook成_objc_msgForward。但是如果这里的selector就是_objc_msgForward会发生什么呢？</p><p>其实这里的坑在作者的代码注释里面已经隐藏的提到了。</p><p>在__ASPECTS_ARE_BEING_CALLED__方法中，最后转发消息的那段代码里面有这样一段注释</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#75715e>// If no hooks are installed, call original implementation (usually to throw an exception)
</span><span style=color:#75715e></span>
</code></pre></div><p>看到这段注释以后，你肯定会思考，为何到了这里就会throw an exception呢？原因是因为找不到NSSelectorFromString(AspectsForwardInvocationSelectorName)对应的IMP。</p><p>再往上找，就可以找到原因了。在实现aspect_prepareClassAndHookSelector中，会判断当前的selector是不是_objc_msgForward，如果不是msgForward，接下来什么也不会做。那么aliasSelector是没有对应的实现的。</p><p>由于 forwardInvocation 被 aspects 所 hook ,最终会进入到 aspects 的处理逻辑__ASPECTS_ARE_BEING_CALLED__中来，此时如果没有找不到 aliasSelector 的 IMP 实现，因此会在此进行消息转发。而且子类并没有实现 NSSelectorFromString(AspectsForwardInvocationSelectorName)，于是转发就会抛出异常。</p><p>这里的“坑”就在于，hook的selector如果变成了_objc_msgForward，就会出现异常了，但是一般我们不会去hook _objc_msgForward这个方法，出现这个问题的原因是有其他的Swizzling会去hook这个方法。</p><p>比如说JSPatch把传入的 selector 先被 JSPatch hook ,那么，这里我们将不会再处理,也就不会生成 aliasSelector 。就会出现闪退的异常了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>Class</span> <span style=color:#a6e22e>aspect_hookClass</span>(NSObject <span style=color:#f92672>*</span>self, NSError <span style=color:#f92672>**</span>error) {
    ...
    subclass <span style=color:#f92672>=</span> objc_allocateClassPair(baseClass, subclassName, <span style=color:#ae81ff>0</span>);
    ...
    <span style=color:#66d9ef>IMP</span> originalImplementation <span style=color:#f92672>=</span> class_replaceMethod(subclass, <span style=color:#66d9ef>@selector</span>(forwardInvocation:), (<span style=color:#66d9ef>IMP</span>)__ASPECTS_ARE_BEING_CALLED__, <span style=color:#e6db74>&#34;v@:@&#34;</span>);
    <span style=color:#66d9ef>if</span> (originalImplementation) {
        class_addMethod(subclass, NSSelectorFromString(AspectsForwardInvocationSelectorName),   originalImplementation, <span style=color:#e6db74>&#34;v@:@&#34;</span>);
    } <span style=color:#66d9ef>else</span> {
        Method baseTargetMethod <span style=color:#f92672>=</span> class_getInstanceMethod(baseClass, <span style=color:#66d9ef>@selector</span>(forwardInvocation:));
        <span style=color:#66d9ef>IMP</span> baseTargetMethodIMP <span style=color:#f92672>=</span> method_getImplementation(baseTargetMethod);
        <span style=color:#66d9ef>if</span> (baseTargetMethodIMP) {
            class_addMethod(subclass, NSSelectorFromString(AspectsForwardInvocationSelectorName), baseTargetMethodIMP, <span style=color:#e6db74>&#34;v@:@&#34;</span>);
        }
    }
    ...
}


</code></pre></div><p>这里在这篇<a href=http://wereadteam.github.io/2016/06/30/Aspects/>文章</a>中给出了一个解决办法：</p><p>在对子类的 forwardInvocation方法进行交换而不仅仅是替换，实现逻辑如下，强制生成一个 NSSelectorFromString(AspectsForwardInvocationSelectorName)指向原对象的 forwardInvocation的实现。</p><p>注意如果 originalImplementation为空，那么生成的 NSSelectorFromString(AspectsForwardInvocationSelectorName)
将指向 baseClass 也就是真正的这个对象的 forwradInvocation ,这个其实也就是 JSPatch hook 的方法。同时为了保证 block 的执行顺序（也就是前面介绍的 before hooks / instead hooks / after hooks ），这里需要将这段代码提前到 after hooks 执行之前进行。这样就解决了 forwardInvocation 在外面已经被 hook 之后的冲突问题。</p><p>谢谢简书的大神 @zhao0 指点，这篇文章详细分析了<a href=http://www.jianshu.com/p/dc1deaa1b28e>Aspect和JSPatch各种兼容性问题</a>，经过详细的分析，最后只有4种不兼容的情况。</p><h5 id=2-aspect_hookselector-可能出现的-坑>2. aspect_hookSelector 可能出现的 “坑”</h5><p>在Aspects中主要是hook selector，此时如果有多个地方会和Aspects去hook相同方法，那么也会出现doesNotRecognizeSelector的问题。</p><p>举个例子，比如说在NSArray中用Aspects 去hook了objectAtIndex的方法，然后在NSMutableArray中Swizzling了objectAtIndex方法。在
NSMutableArray中，调用objectAtIndex就有可能出错。</p><p>因为还是在于Aspects hook 了selector之后，会把原来的selector变成_objc_msgForward。等到NSMutableArray再去hook这个方法的时候，记录的是IMP就是_objc_msgForward这个了。如果这时objc_msgSend执行原有实现，就会出错了。因为原有实现已经被替换为_objc_msgForward，而真的IMP由于被Aspects先Swizzling掉了，所以找不到。</p><p>解决办法还是类似JSPatch的解决办法：</p><p>把-forwardInvocation:也进行Swizzling，在自己的-forwardInvocation:方法中进行同样的操作，就是判断传入的NSInvocation的Selector，被Swizzling的方法指向了_objc_msgForward（或_objc_msgForward_stret）如果是自己可以识别的Selector，那么就将Selector变为原有Selector在执行，如果不识别，就直接转发。</p><h4 id=最后>最后</h4><p>最后用一张图总结一下Aspects整体流程：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/28_6.png alt></p><p>请大家多多指教。</p><img src=https://img.halfrost.com/wechat-qr-code.png></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div id=toc-footer style=display:none><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#目录>目录</a></li><li><a href=#一aspect-oriented-programming简介>一.Aspect Oriented Programming简介</a></li><li><a href=#二-什么是aspects>二. 什么是Aspects</a></li><li><a href=#三aspects-中4个基本类-解析>三.Aspects 中4个基本类 解析</a></li><li><a href=#四-aspects-hook前的准备工作>四. Aspects hook前的准备工作</a></li><li><a href=#五-aspects-hook过程详解>五. Aspects hook过程详解</a></li><li><a href=#六-关于aspects-的一些-坑>六. 关于Aspects 的一些 “坑”</a></li><li><a href=#最后>最后</a></li></ul></li></ul></li></ul></nav></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f"><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&text=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&title=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&is_video=false&description=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f"><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&title=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&title=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&title=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-stumbleupon fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&title=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-digg fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&name=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming&description=%e5%89%8d%e8%a8%80%20%e5%9c%a8%e2%80%9cRuntime%e7%97%85%e9%99%a2%e2%80%9d%e4%bd%8f%e9%99%a2%e7%9a%84%e5%90%8e%e4%b8%a4%e5%a4%a9%ef%bc%8c%e5%88%86%e6%9e%90%e4%ba%86%e4%b8%80%e4%b8%8bAOP%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e3%80%82%e2%80%9c%e5%87%ba%e9%99%a2%e2%80%9d%e5%90%8e%ef%bc%8c%e5%8f%91%e7%8e%b0Aspect%e5%ba%93%e8%bf%98%e6%b2%a1%e6%9c%89%e8%af%a6%e7%bb%86%e5%88%86%e6%9e%90%ef%bc%8c%e4%ba%8e%e6%98%af%e5%b0%b1%e6%9c%89%e4%ba%86%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%ef%bc%8c%e4%bb%8a%e5%a4%a9%e5%b0%b1%e6%9d%a5%e8%af%b4%e8%af%b4iOS%20%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0Aspect%20Oriented%20Programming%e3%80%82%0a%e7%9b%ae%e5%bd%95%20%201.Aspect%20Oriented%20Programming%e7%ae%80%e4%bb%8b%202.%e4%bb%80%e4%b9%88%e6%98%afAspects%203.Aspects%20%e4%b8%ad4%e4%b8%aa%e5%9f%ba%e6%9c%ac%e7%b1%bb%20%e8%a7%a3%e6%9e%90%204.Aspects%20hook%e5%89%8d%e7%9a%84%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c%205.Aspects%20hook%e8%bf%87%e7%a8%8b%e8%af%a6%e8%a7%a3%206.%e5%85%b3%e4%ba%8eAspects%e7%9a%84%e4%b8%80%e4%ba%9b%20%e2%80%9c%e5%9d%91%e2%80%9d%20%20%e4%b8%80.Aspect%20Oriented%20Programming%e7%ae%80%e4%bb%8b%20%e9%9d%a2%e5%90%91%e5%88%87%e9%9d%a2%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%ef%bc%88aspect-oriented%20programming%ef%bc%8cAOP%ef%bc%8c%e5%8f%88%e8%af%91%e4%bd%9c%e9%9d%a2%e5%90%91%e6%96%b9%e9%9d%a2%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e3%80%81%e8%a7%82%e7%82%b9%e5%af%bc%e5%90%91%e7%bc%96%e7%a8%8b%e3%80%81%e5%89%96%e9%9d%a2%e5%af%bc%e5%90%91%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%ef%bc%89%e6%98%af%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6%e4%b8%ad%e7%9a%84%e4%b8%80%e4%b8%aa%e6%9c%af%e8%af%ad%ef%bc%8c%e6%8c%87%e4%b8%80%e7%a7%8d%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e8%8c%83%e5%9e%8b%e3%80%82%e8%af%a5%e8%8c%83%e5%9e%8b%e4%bb%a5%e4%b8%80%e7%a7%8d%e7%a7%b0%e4%b8%ba%e4%be%a7%e9%9d%a2%ef%bc%88aspect%ef%bc%8c%e5%8f%88%e8%af%91%e4%bd%9c%e6%96%b9%e9%9d%a2%ef%bc%89%e7%9a%84%e8%af%ad%e8%a8%80%e6%9e%84%e9%80%a0%e4%b8%ba%e5%9f%ba%e7%a1%80%ef%bc%8c%e4%be%a7%e9%9d%a2%e6%98%af%e4%b8%80%e7%a7%8d%e6%96%b0%e7%9a%84%e6%a8%a1%e5%9d%97%e5%8c%96%e6%9c%ba%e5%88%b6%ef%bc%8c%e7%94%a8%e6%9d%a5%e6%8f%8f%e8%bf%b0%e5%88%86%e6%95%a3%e5%9c%a8%e5%af%b9%e8%b1%a1%e3%80%81%e7%b1%bb%e6%88%96%e5%87%bd%e6%95%b0%e4%b8%ad%e7%9a%84%e6%a8%aa%e5%88%87%e5%85%b3%e6%b3%a8%e7%82%b9%ef%bc%88crosscutting%20concern%ef%bc%89%e3%80%82%0a%e4%be%a7%e9%9d%a2%e7%9a%84%e6%a6%82%e5%bf%b5%e6%ba%90%e4%ba%8e%e5%af%b9%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e7%9a%84%e6%94%b9%e8%bf%9b%ef%bc%8c%e4%bd%86%e5%b9%b6%e4%b8%8d%e5%8f%aa%e9%99%90%e4%ba%8e%e6%ad%a4%ef%bc%8c%e5%ae%83%e8%bf%98%e5%8f%af%e4%bb%a5%e7%94%a8%e6%9d%a5%e6%94%b9%e8%bf%9b%e4%bc%a0%e7%bb%9f%e7%9a%84%e5%87%bd%e6%95%b0%e3%80%82%e4%b8%8e%e4%be%a7%e9%9d%a2%e7%9b%b8%e5%85%b3%e7%9a%84%e7%bc%96%e7%a8%8b%e6%a6%82%e5%bf%b5%e8%bf%98%e5%8c%85%e6%8b%ac%e5%85%83%e5%af%b9%e8%b1%a1%e5%8d%8f%e8%ae%ae%e3%80%81%e4%b8%bb%e9%a2%98%ef%bc%88subject%ef%bc%89%e3%80%81%e6%b7%b7%e5%85%a5%ef%bc%88mixin%ef%bc%89%e5%92%8c%e5%a7%94%e6%89%98%e3%80%82%0aAOP%e9%80%9a%e8%bf%87%e9%a2%84%e7%bc%96%e8%af%91%e6%96%b9%e5%bc%8f%e5%92%8c%e8%bf%90%e8%a1%8c%e6%9c%9f%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e5%ae%9e%e7%8e%b0%e7%a8%8b%e5%ba%8f%e5%8a%9f%e8%83%bd%e7%9a%84%e7%bb%9f%e4%b8%80%e7%bb%b4%e6%8a%a4%e7%9a%84%e4%b8%80%e7%a7%8d%e6%8a%80%e6%9c%af%e3%80%82%0aOOP%ef%bc%88%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b%ef%bc%89%e9%92%88%e5%af%b9%e4%b8%9a%e5%8a%a1%e5%a4%84%e7%90%86%e8%bf%87%e7%a8%8b%e7%9a%84%e5%ae%9e%e4%bd%93%e5%8f%8a%e5%85%b6%e5%b1%9e%e6%80%a7%e5%92%8c%e8%a1%8c%e4%b8%ba%e8%bf%9b%e8%a1%8c%e6%8a%bd%e8%b1%a1%e5%b0%81%e8%a3%85%ef%bc%8c%e4%bb%a5%e8%8e%b7%e5%be%97%e6%9b%b4%e5%8a%a0%e6%b8%85%e6%99%b0%e9%ab%98%e6%95%88%e7%9a%84%e9%80%bb%e8%be%91%e5%8d%95%e5%85%83%e5%88%92%e5%88%86%e3%80%82%0aAOP%e5%88%99%e6%98%af%e9%92%88%e5%af%b9%e4%b8%9a%e5%8a%a1%e5%a4%84%e7%90%86%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%88%87%e9%9d%a2%e8%bf%9b%e8%a1%8c%e6%8f%90%e5%8f%96%ef%bc%8c%e5%ae%83%e6%89%80%e9%9d%a2%e5%af%b9%e7%9a%84%e6%98%af%e5%a4%84%e7%90%86%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e6%9f%90%e4%b8%aa%e6%ad%a5%e9%aa%a4%e6%88%96%e9%98%b6%e6%ae%b5%ef%bc%8c%e4%bb%a5%e8%8e%b7%e5%be%97%e9%80%bb%e8%be%91%e8%bf%87%e7%a8%8b%e4%b8%ad%e5%90%84%e9%83%a8%e5%88%86%e4%b9%8b%e9%97%b4%e4%bd%8e%e8%80%a6%e5%90%88%e6%80%a7%e7%9a%84%e9%9a%94%e7%a6%bb%e6%95%88%e6%9e%9c%e3%80%82%0aOOP%e5%92%8cAOP%e5%b1%9e%e4%ba%8e%e4%b8%a4%e4%b8%aa%e4%b8%8d%e5%90%8c%e7%9a%84%e2%80%9c%e6%80%9d%e8%80%83%e6%96%b9%e5%bc%8f%e2%80%9d%e3%80%82OOP%e4%b8%93%e6%b3%a8%e4%ba%8e%e5%af%b9%e8%b1%a1%e7%9a%84%e5%b1%9e%e6%80%a7%e5%92%8c%e8%a1%8c%e4%b8%ba%e7%9a%84%e5%b0%81%e8%a3%85%ef%bc%8cAOP%e4%b8%93%e6%b3%a8%e4%ba%8e%e5%a4%84%e7%90%86%e6%9f%90%e4%b8%aa%e6%ad%a5%e9%aa%a4%e5%92%8c%e9%98%b6%e6%ae%b5%e7%9a%84%ef%bc%8c%e4%bb%8e%e4%b8%ad%e8%bf%9b%e8%a1%8c%e5%88%87%e9%9d%a2%e7%9a%84%e6%8f%90%e5%8f%96%e3%80%82%0a%e4%b8%be%e4%b8%aa%e4%be%8b%e5%ad%90%ef%bc%8c%e5%a6%82%e6%9e%9c%e6%9c%89%e4%b8%80%e4%b8%aa%e5%88%a4%e6%96%ad%e6%9d%83%e9%99%90%e7%9a%84%e9%9c%80%e6%b1%82%ef%bc%8cOOP%e7%9a%84%e5%81%9a%e6%b3%95%e8%82%af%e5%ae%9a%e6%98%af%e5%9c%a8%e6%af%8f%e4%b8%aa%e6%93%8d%e4%bd%9c%e5%89%8d%e9%83%bd%e5%8a%a0%e5%85%a5%e6%9d%83%e9%99%90%e5%88%a4%e6%96%ad%e3%80%82%e9%82%a3%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95%e6%80%8e%e4%b9%88%e5%8a%9e%ef%bc%9f%e5%9c%a8%e6%af%8f%e4%b8%aa%e6%96%b9%e6%b3%95%e7%9a%84%e5%bc%80%e5%a7%8b%e7%bb%93%e6%9d%9f%e7%9a%84%e5%9c%b0%e6%96%b9%e9%83%bd%e5%8a%a0%e4%b8%8a%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95%e3%80%82AOP%e5%b0%b1%e6%98%af%e6%8a%8a%e8%bf%99%e4%ba%9b%e9%87%8d%e5%a4%8d%e7%9a%84%e9%80%bb%e8%be%91%e5%92%8c%e6%93%8d%e4%bd%9c%ef%bc%8c%e6%8f%90%e5%8f%96%e5%87%ba%e6%9d%a5%ef%bc%8c%e8%bf%90%e7%94%a8%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%ef%bc%8c%e5%ae%9e%e7%8e%b0%e8%bf%99%e4%ba%9b%e6%a8%a1%e5%9d%97%e7%9a%84%e8%a7%a3%e8%80%a6%e3%80%82OOP%e5%92%8cAOP%e4%b8%8d%e6%98%af%e4%ba%92%e6%96%a5%ef%bc%8c%e8%80%8c%e6%98%af%e7%9b%b8%e4%ba%92%e9%85%8d%e5%90%88%e3%80%82%0a%e5%9c%a8iOS%e9%87%8c%e9%9d%a2%e4%bd%bf%e7%94%a8AOP%e8%bf%9b%e8%a1%8c%e7%bc%96%e7%a8%8b%ef%bc%8c%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e9%9d%9e%e4%be%b5%e5%85%a5%e3%80%82%e4%b8%8d%e9%9c%80%e8%a6%81%e6%9b%b4%e6%94%b9%e4%b9%8b%e5%89%8d%e7%9a%84%e4%bb%a3%e7%a0%81%e9%80%bb%e8%be%91%ef%bc%8c%e5%b0%b1%e8%83%bd%e5%8a%a0%e5%85%a5%e6%96%b0%e7%9a%84%e5%8a%9f%e8%83%bd%e3%80%82%e4%b8%bb%e8%a6%81%e7%94%a8%e6%9d%a5%e5%a4%84%e7%90%86%e4%b8%80%e4%ba%9b%e5%85%b7%e6%9c%89%e6%a8%aa%e5%88%87%e6%80%a7%e8%b4%a8%e7%9a%84%e7%b3%bb%e7%bb%9f%e6%80%a7%e6%9c%8d%e5%8a%a1%ef%bc%8c%e5%a6%82%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95%e3%80%81%e6%9d%83%e9%99%90%e7%ae%a1%e7%90%86%e3%80%81%e7%bc%93%e5%ad%98%e3%80%81%e5%af%b9%e8%b1%a1%e6%b1%a0%e7%ae%a1%e7%90%86%e7%ad%89%e3%80%82%0a%e4%ba%8c.%20%e4%bb%80%e4%b9%88%e6%98%afAspects%20Aspects%e6%98%af%e4%b8%80%e4%b8%aa%e8%bd%bb%e9%87%8f%e7%ba%a7%e7%9a%84%e9%9d%a2%e5%90%91%e5%88%87%e9%9d%a2%e7%bc%96%e7%a8%8b%e7%9a%84%e5%ba%93%e3%80%82%e5%ae%83%e8%83%bd%e5%85%81%e8%ae%b8%e4%bd%a0%e5%9c%a8%e6%af%8f%e4%b8%80%e4%b8%aa%e7%b1%bb%e5%92%8c%e6%af%8f%e4%b8%80%e4%b8%aa%e5%ae%9e%e4%be%8b%e4%b8%ad%e5%ad%98%e5%9c%a8%e7%9a%84%e6%96%b9%e6%b3%95%e9%87%8c%e9%9d%a2%e5%8a%a0%e5%85%a5%e4%bb%bb%e4%bd%95%e4%bb%a3%e7%a0%81%e3%80%82%e5%8f%af%e4%bb%a5%e5%9c%a8%e4%bb%a5%e4%b8%8b%e5%88%87%e5%85%a5%e7%82%b9%e6%8f%92%e5%85%a5%e4%bb%a3%e7%a0%81%ef%bc%9abefore%28%e5%9c%a8%e5%8e%9f%e5%a7%8b%e7%9a%84%e6%96%b9%e6%b3%95%e5%89%8d%e6%89%a7%e8%a1%8c%29%20%2f%20instead%28%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%a7%8b%e7%9a%84%e6%96%b9%e6%b3%95%e6%89%a7%e8%a1%8c%29%20%2f%20after%28%e5%9c%a8%e5%8e%9f%e5%a7%8b%e7%9a%84%e6%96%b9%e6%b3%95%e5%90%8e%e6%89%a7%e8%a1%8c%2c%e9%bb%98%e8%ae%a4%29%e3%80%82%e9%80%9a%e8%bf%87Runtime%e6%b6%88%e6%81%af%e8%bd%ac%e5%8f%91%e5%ae%9e%e7%8e%b0Hook%e3%80%82Aspects%e4%bc%9a%e8%87%aa%e5%8a%a8%e7%9a%84%e8%b0%83%e7%94%a8super%e6%96%b9%e6%b3%95%ef%bc%8c%e4%bd%bf%e7%94%a8method%20swizzling%e8%b5%b7%e6%9d%a5%e4%bc%9a%e6%9b%b4%e5%8a%a0%e6%96%b9%e4%be%bf%e3%80%82%0a%e8%bf%99%e4%b8%aa%e5%ba%93%e5%be%88%e7%a8%b3%e5%ae%9a%ef%bc%8c%e7%9b%ae%e5%89%8d%e7%94%a8%e5%9c%a8%e6%95%b0%e7%99%be%e6%ac%beapp%e4%b8%8a%e4%ba%86%e3%80%82%e5%ae%83%e4%b9%9f%e6%98%afPSPDFKit%e7%9a%84%e4%b8%80%e9%83%a8%e5%88%86%ef%bc%8cPSPDFKit%e6%98%af%e4%b8%80%e4%b8%aaiOS%20%e7%9c%8bPDF%e7%9a%84framework%e5%ba%93%e3%80%82%e4%bd%9c%e8%80%85%e6%9c%80%e7%bb%88%e5%86%b3%e5%ae%9a%e6%8a%8a%e5%ae%83%e5%bc%80%e6%ba%90%e5%87%ba%e6%9d%a5%e3%80%82%0a%e4%b8%89.Aspects%20%e4%b8%ad4%e4%b8%aa%e5%9f%ba%e6%9c%ac%e7%b1%bb%20%e8%a7%a3%e6%9e%90%20%e6%88%91%e4%bb%ac%e4%bb%8e%e5%a4%b4%e6%96%87%e4%bb%b6%e5%bc%80%e5%a7%8b%e7%9c%8b%e8%b5%b7%e3%80%82%0a1.Aspects.h%20typedef%20NS_OPTIONS%28NSUInteger%2c%20AspectOptions%29%20%7b%20AspectPositionAfter%20%3d%200%2c%c2%a0%2f%2f%2f%20Called%20after%20the%20original%20implementation%20%28default%29%20%c2%a0AspectPositionInstead%20%3d%201%2c%c2%a0%2f%2f%2f%20Will%20replace%20the%20original%20implementation."><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fios_aspect%2f&t=iOS%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20Aspect%20Oriented%20Programming"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu class=icon href=# onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden=true></i>Menu</a>
<a id=toc class=icon href=# onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden=true></i>TOC</a>
<a id=share class=icon href=# onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden=true></i>share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i>Top</a></div></div></div><footer id=footer><div class=footer-left><p class=copyright style=float:left;margin-bottom:0><a href=https://github.com/halfrost/Halfrost-Field class=github-repo style=height:18px><span class=gadget-github></span>Star</a>
Copyright &copy;halfrost 2016 - 2021
<a href=http://www.miit.gov.cn/>鄂ICP备16014744号</a></p><br><p class="copyright statistics" style=margin-bottom:20px><span id=busuanzi_container_site_pv>Cumulative Page Views <span id=busuanzi_value_site_pv></span>| Unique Visitors <span id=busuanzi_value_site_uv></span></span></p></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/main.min.f870a4d110314b9e50e65f8ac982dc1c9c376c8f1a5083d39c62cfc49073f011.js></script><script async src=/prism.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>
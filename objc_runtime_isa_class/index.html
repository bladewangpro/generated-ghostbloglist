<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=theme-color content="#FFFFFF"><meta http-equiv=x-ua-compatible content="IE=edge"><title>神经病院 Objective-C Runtime 入院第一天—— isa 和 Class | prometheus</title><meta name=description content="Explore in every moment of the hard thinking"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="神经病院 Objective-C Runtime 入院第一天—— isa 和 Class"><meta property="og:description" content="前言 我第一次开始重视Objective-C Runtime是从2014年11月1日，@唐巧老师在微博上发的一条微博开始。
这是sunnyxx在线下的一次分享会。会上还给了4道题目。
这4道题以我当时的知识，很多就不确定，拿不准。从这次入院考试开始，就成功入院了。后来这两年对Runtime的理解慢慢增加了，打算今天自己总结总结平时一直躺在我印象笔记里面的笔记。有些人可能有疑惑，学习Runtime到底有啥用，平时好像并不会用到。希望看完我这次的总结，心中能解开一些疑惑。
####目录
 1.Runtime简介 2.NSObject起源  (1) isa_t结构体的具体实现 (2) cache_t的具体实现 (3) class_data_bits_t的具体实现   3.入院考试  一. Runtime简介 Runtime 又叫运行时，是一套底层的 C 语言 API，是 iOS 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。
C语言中，在编译期，函数的调用就会决定调用哪个函数。 而OC的函数，属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。
Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。
Objc 在三种层面上与 Runtime 系统进行交互：
1. 通过 Objective-C 源代码 一般情况开发者只需要编写 OC 代码即可，Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码，在运行时确定对应的数据结构和调用具体哪个方法。
2. 通过 Foundation 框架的 NSObject 类定义的方法 在OC的世界中，除了NSProxy类以外，所有的类都是NSObject的子类。在Foundation框架下，NSObject和NSProxy两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy是专门用于实现代理对象的类，这个类暂时本篇文章不提。这两个类都遵循了NSObject协议。在NSObject协议中，声明了所有OC对象的公共方法。
在NSObject协议中，有以下5个方法，是可以从Runtime中获取信息，让对象进行自我检查。
- (Class)class OBJC_SWIFT_UNAVAILABLE(&#34;use 'anObject.dynamicType' instead&#34;); - (BOOL)isKindOfClass:(Class)aClass; - (BOOL)isMemberOfClass:(Class)aClass; - (BOOL)conformsToProtocol:(Protocol *)aProtocol; - (BOOL)respondsToSelector:(SEL)aSelector; -class方法返回对象的类； -isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中； -respondsToSelector: 检查对象能否响应指定的消息； -conformsToProtocol:检查对象是否实现了指定协议类的方法；"><meta property="og:type" content="article"><meta property="og:url" content="https://new.halfrost.com/objc_runtime_isa_class/"><meta property="article:published_time" content="2016-09-10T01:25:00+00:00"><meta property="article:modified_time" content="2016-09-10T01:25:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="神经病院 Objective-C Runtime 入院第一天—— isa 和 Class"><meta name=twitter:description content="前言 我第一次开始重视Objective-C Runtime是从2014年11月1日，@唐巧老师在微博上发的一条微博开始。
这是sunnyxx在线下的一次分享会。会上还给了4道题目。
这4道题以我当时的知识，很多就不确定，拿不准。从这次入院考试开始，就成功入院了。后来这两年对Runtime的理解慢慢增加了，打算今天自己总结总结平时一直躺在我印象笔记里面的笔记。有些人可能有疑惑，学习Runtime到底有啥用，平时好像并不会用到。希望看完我这次的总结，心中能解开一些疑惑。
####目录
 1.Runtime简介 2.NSObject起源  (1) isa_t结构体的具体实现 (2) cache_t的具体实现 (3) class_data_bits_t的具体实现   3.入院考试  一. Runtime简介 Runtime 又叫运行时，是一套底层的 C 语言 API，是 iOS 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。
C语言中，在编译期，函数的调用就会决定调用哪个函数。 而OC的函数，属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。
Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。
Objc 在三种层面上与 Runtime 系统进行交互：
1. 通过 Objective-C 源代码 一般情况开发者只需要编写 OC 代码即可，Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码，在运行时确定对应的数据结构和调用具体哪个方法。
2. 通过 Foundation 框架的 NSObject 类定义的方法 在OC的世界中，除了NSProxy类以外，所有的类都是NSObject的子类。在Foundation框架下，NSObject和NSProxy两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy是专门用于实现代理对象的类，这个类暂时本篇文章不提。这两个类都遵循了NSObject协议。在NSObject协议中，声明了所有OC对象的公共方法。
在NSObject协议中，有以下5个方法，是可以从Runtime中获取信息，让对象进行自我检查。
- (Class)class OBJC_SWIFT_UNAVAILABLE(&#34;use 'anObject.dynamicType' instead&#34;); - (BOOL)isKindOfClass:(Class)aClass; - (BOOL)isMemberOfClass:(Class)aClass; - (BOOL)conformsToProtocol:(Protocol *)aProtocol; - (BOOL)respondsToSelector:(SEL)aSelector; -class方法返回对象的类； -isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中； -respondsToSelector: 检查对象能否响应指定的消息； -conformsToProtocol:检查对象是否实现了指定协议类的方法；"><link rel=stylesheet href=/css/style-white.min.css><link rel=manifest href=/manifest.json><link rel=stylesheet href=/prism.css><link href=/images/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=/images/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=/images/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=/images/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=/images/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=/images/apple-touch-icon-512x512.png rel=apple-touch-icon sizes=512x512><link href=/images/apple-touch-icon-1024x1024.png rel=apple-touch-icon sizes=1024x1024><script async>if('serviceWorker'in navigator){navigator.serviceWorker.register("\/serviceworker-v1.min.a64912b78d282eab1ad3715a0943da21616e5f326f8afea27034784ad445043b.js").then(function(){if(navigator.serviceWorker.controller){console.log('Assets cached by the controlling service worker.');}else{console.log('Please reload this page to allow the service worker to handle network operations.');}}).catch(function(error){console.log('ERROR: '+error);});}else{console.log('Service workers are not supported in the current browser.');}</script><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://new.halfrost.com/images/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-82753806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="single-max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a><a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a><a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast');" style=display:none><i class="fas fa-chevron-up fa-lg"></i></a><span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://new.halfrost.com/ios_block_retain_circle/><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li><li><a class=icon href=https://new.halfrost.com/objc_runtime_objc_msgsend/><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li><li><a class=icon href=#><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f"><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&text=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&title=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&is_video=false&description=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f"><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&title=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&title=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&title=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-stumbleupon" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&title=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-digg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&name=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class&description=%e5%89%8d%e8%a8%80%20%e6%88%91%e7%ac%ac%e4%b8%80%e6%ac%a1%e5%bc%80%e5%a7%8b%e9%87%8d%e8%a7%86Objective-C%20Runtime%e6%98%af%e4%bb%8e2014%e5%b9%b411%e6%9c%881%e6%97%a5%ef%bc%8c%40%e5%94%90%e5%b7%a7%e8%80%81%e5%b8%88%e5%9c%a8%e5%be%ae%e5%8d%9a%e4%b8%8a%e5%8f%91%e7%9a%84%e4%b8%80%e6%9d%a1%e5%be%ae%e5%8d%9a%e5%bc%80%e5%a7%8b%e3%80%82%0a%e8%bf%99%e6%98%afsunnyxx%e5%9c%a8%e7%ba%bf%e4%b8%8b%e7%9a%84%e4%b8%80%e6%ac%a1%e5%88%86%e4%ba%ab%e4%bc%9a%e3%80%82%e4%bc%9a%e4%b8%8a%e8%bf%98%e7%bb%99%e4%ba%864%e9%81%93%e9%a2%98%e7%9b%ae%e3%80%82%0a%e8%bf%994%e9%81%93%e9%a2%98%e4%bb%a5%e6%88%91%e5%bd%93%e6%97%b6%e7%9a%84%e7%9f%a5%e8%af%86%ef%bc%8c%e5%be%88%e5%a4%9a%e5%b0%b1%e4%b8%8d%e7%a1%ae%e5%ae%9a%ef%bc%8c%e6%8b%bf%e4%b8%8d%e5%87%86%e3%80%82%e4%bb%8e%e8%bf%99%e6%ac%a1%e5%85%a5%e9%99%a2%e8%80%83%e8%af%95%e5%bc%80%e5%a7%8b%ef%bc%8c%e5%b0%b1%e6%88%90%e5%8a%9f%e5%85%a5%e9%99%a2%e4%ba%86%e3%80%82%e5%90%8e%e6%9d%a5%e8%bf%99%e4%b8%a4%e5%b9%b4%e5%af%b9Runtime%e7%9a%84%e7%90%86%e8%a7%a3%e6%85%a2%e6%85%a2%e5%a2%9e%e5%8a%a0%e4%ba%86%ef%bc%8c%e6%89%93%e7%ae%97%e4%bb%8a%e5%a4%a9%e8%87%aa%e5%b7%b1%e6%80%bb%e7%bb%93%e6%80%bb%e7%bb%93%e5%b9%b3%e6%97%b6%e4%b8%80%e7%9b%b4%e8%ba%ba%e5%9c%a8%e6%88%91%e5%8d%b0%e8%b1%a1%e7%ac%94%e8%ae%b0%e9%87%8c%e9%9d%a2%e7%9a%84%e7%ac%94%e8%ae%b0%e3%80%82%e6%9c%89%e4%ba%9b%e4%ba%ba%e5%8f%af%e8%83%bd%e6%9c%89%e7%96%91%e6%83%91%ef%bc%8c%e5%ad%a6%e4%b9%a0Runtime%e5%88%b0%e5%ba%95%e6%9c%89%e5%95%a5%e7%94%a8%ef%bc%8c%e5%b9%b3%e6%97%b6%e5%a5%bd%e5%83%8f%e5%b9%b6%e4%b8%8d%e4%bc%9a%e7%94%a8%e5%88%b0%e3%80%82%e5%b8%8c%e6%9c%9b%e7%9c%8b%e5%ae%8c%e6%88%91%e8%bf%99%e6%ac%a1%e7%9a%84%e6%80%bb%e7%bb%93%ef%bc%8c%e5%bf%83%e4%b8%ad%e8%83%bd%e8%a7%a3%e5%bc%80%e4%b8%80%e4%ba%9b%e7%96%91%e6%83%91%e3%80%82%0a%23%23%23%23%e7%9b%ae%e5%bd%95%0a%201.Runtime%e7%ae%80%e4%bb%8b%202.NSObject%e8%b5%b7%e6%ba%90%20%20%281%29%20isa_t%e7%bb%93%e6%9e%84%e4%bd%93%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%20%282%29%20cache_t%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%20%283%29%20class_data_bits_t%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%20%20%203.%e5%85%a5%e9%99%a2%e8%80%83%e8%af%95%20%20%e4%b8%80.%20Runtime%e7%ae%80%e4%bb%8b%20Runtime%20%e5%8f%88%e5%8f%ab%e8%bf%90%e8%a1%8c%e6%97%b6%ef%bc%8c%e6%98%af%e4%b8%80%e5%a5%97%e5%ba%95%e5%b1%82%e7%9a%84%20C%20%e8%af%ad%e8%a8%80%20API%ef%bc%8c%e6%98%af%20iOS%20%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%a0%b8%e5%bf%83%e4%b9%8b%e4%b8%80%e3%80%82%e5%bc%80%e5%8f%91%e8%80%85%e5%9c%a8%e7%bc%96%e7%a0%81%e8%bf%87%e7%a8%8b%e4%b8%ad%ef%bc%8c%e5%8f%af%e4%bb%a5%e7%bb%99%e4%bb%bb%e6%84%8f%e4%b8%80%e4%b8%aa%e5%af%b9%e8%b1%a1%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af%ef%bc%8c%e5%9c%a8%e7%bc%96%e8%af%91%e9%98%b6%e6%ae%b5%e5%8f%aa%e6%98%af%e7%a1%ae%e5%ae%9a%e4%ba%86%e8%a6%81%e5%90%91%e6%8e%a5%e6%94%b6%e8%80%85%e5%8f%91%e9%80%81%e8%bf%99%e6%9d%a1%e6%b6%88%e6%81%af%ef%bc%8c%e8%80%8c%e6%8e%a5%e5%8f%97%e8%80%85%e5%b0%86%e8%a6%81%e5%a6%82%e4%bd%95%e5%93%8d%e5%ba%94%e5%92%8c%e5%a4%84%e7%90%86%e8%bf%99%e6%9d%a1%e6%b6%88%e6%81%af%ef%bc%8c%e9%82%a3%e5%b0%b1%e8%a6%81%e7%9c%8b%e8%bf%90%e8%a1%8c%e6%97%b6%e6%9d%a5%e5%86%b3%e5%ae%9a%e4%ba%86%e3%80%82%0aC%e8%af%ad%e8%a8%80%e4%b8%ad%ef%bc%8c%e5%9c%a8%e7%bc%96%e8%af%91%e6%9c%9f%ef%bc%8c%e5%87%bd%e6%95%b0%e7%9a%84%e8%b0%83%e7%94%a8%e5%b0%b1%e4%bc%9a%e5%86%b3%e5%ae%9a%e8%b0%83%e7%94%a8%e5%93%aa%e4%b8%aa%e5%87%bd%e6%95%b0%e3%80%82%20%e8%80%8cOC%e7%9a%84%e5%87%bd%e6%95%b0%ef%bc%8c%e5%b1%9e%e4%ba%8e%e5%8a%a8%e6%80%81%e8%b0%83%e7%94%a8%e8%bf%87%e7%a8%8b%ef%bc%8c%e5%9c%a8%e7%bc%96%e8%af%91%e6%9c%9f%e5%b9%b6%e4%b8%8d%e8%83%bd%e5%86%b3%e5%ae%9a%e7%9c%9f%e6%ad%a3%e8%b0%83%e7%94%a8%e5%93%aa%e4%b8%aa%e5%87%bd%e6%95%b0%ef%bc%8c%e5%8f%aa%e6%9c%89%e5%9c%a8%e7%9c%9f%e6%ad%a3%e8%bf%90%e8%a1%8c%e6%97%b6%e6%89%8d%e4%bc%9a%e6%a0%b9%e6%8d%ae%e5%87%bd%e6%95%b0%e7%9a%84%e5%90%8d%e7%a7%b0%e6%89%be%e5%88%b0%e5%af%b9%e5%ba%94%e7%9a%84%e5%87%bd%e6%95%b0%e6%9d%a5%e8%b0%83%e7%94%a8%e3%80%82%0aObjective-C%20%e6%98%af%e4%b8%80%e4%b8%aa%e5%8a%a8%e6%80%81%e8%af%ad%e8%a8%80%ef%bc%8c%e8%bf%99%e6%84%8f%e5%91%b3%e7%9d%80%e5%ae%83%e4%b8%8d%e4%bb%85%e9%9c%80%e8%a6%81%e4%b8%80%e4%b8%aa%e7%bc%96%e8%af%91%e5%99%a8%ef%bc%8c%e4%b9%9f%e9%9c%80%e8%a6%81%e4%b8%80%e4%b8%aa%e8%bf%90%e8%a1%8c%e6%97%b6%e7%b3%bb%e7%bb%9f%e6%9d%a5%e5%8a%a8%e6%80%81%e5%be%97%e5%88%9b%e5%bb%ba%e7%b1%bb%e5%92%8c%e5%af%b9%e8%b1%a1%e3%80%81%e8%bf%9b%e8%a1%8c%e6%b6%88%e6%81%af%e4%bc%a0%e9%80%92%e5%92%8c%e8%bd%ac%e5%8f%91%e3%80%82%0aObjc%20%e5%9c%a8%e4%b8%89%e7%a7%8d%e5%b1%82%e9%9d%a2%e4%b8%8a%e4%b8%8e%20Runtime%20%e7%b3%bb%e7%bb%9f%e8%bf%9b%e8%a1%8c%e4%ba%a4%e4%ba%92%ef%bc%9a%0a1.%20%e9%80%9a%e8%bf%87%20Objective-C%20%e6%ba%90%e4%bb%a3%e7%a0%81%20%e4%b8%80%e8%88%ac%e6%83%85%e5%86%b5%e5%bc%80%e5%8f%91%e8%80%85%e5%8f%aa%e9%9c%80%e8%a6%81%e7%bc%96%e5%86%99%20OC%20%e4%bb%a3%e7%a0%81%e5%8d%b3%e5%8f%af%ef%bc%8cRuntime%20%e7%b3%bb%e7%bb%9f%e8%87%aa%e5%8a%a8%e5%9c%a8%e5%b9%95%e5%90%8e%e6%8a%8a%e6%88%91%e4%bb%ac%e5%86%99%e7%9a%84%e6%ba%90%e4%bb%a3%e7%a0%81%e5%9c%a8%e7%bc%96%e8%af%91%e9%98%b6%e6%ae%b5%e8%bd%ac%e6%8d%a2%e6%88%90%e8%bf%90%e8%a1%8c%e6%97%b6%e4%bb%a3%e7%a0%81%ef%bc%8c%e5%9c%a8%e8%bf%90%e8%a1%8c%e6%97%b6%e7%a1%ae%e5%ae%9a%e5%af%b9%e5%ba%94%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%92%8c%e8%b0%83%e7%94%a8%e5%85%b7%e4%bd%93%e5%93%aa%e4%b8%aa%e6%96%b9%e6%b3%95%e3%80%82%0a2.%20%e9%80%9a%e8%bf%87%20Foundation%20%e6%a1%86%e6%9e%b6%e7%9a%84%20NSObject%20%e7%b1%bb%e5%ae%9a%e4%b9%89%e7%9a%84%e6%96%b9%e6%b3%95%20%e5%9c%a8OC%e7%9a%84%e4%b8%96%e7%95%8c%e4%b8%ad%ef%bc%8c%e9%99%a4%e4%ba%86NSProxy%e7%b1%bb%e4%bb%a5%e5%a4%96%ef%bc%8c%e6%89%80%e6%9c%89%e7%9a%84%e7%b1%bb%e9%83%bd%e6%98%afNSObject%e7%9a%84%e5%ad%90%e7%b1%bb%e3%80%82%e5%9c%a8Foundation%e6%a1%86%e6%9e%b6%e4%b8%8b%ef%bc%8cNSObject%e5%92%8cNSProxy%e4%b8%a4%e4%b8%aa%e5%9f%ba%e7%b1%bb%ef%bc%8c%e5%ae%9a%e4%b9%89%e4%ba%86%e7%b1%bb%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e4%b8%ad%e8%af%a5%e7%b1%bb%e4%b8%8b%e6%96%b9%e6%89%80%e6%9c%89%e7%b1%bb%e7%9a%84%e5%85%ac%e5%85%b1%e6%8e%a5%e5%8f%a3%e5%92%8c%e8%a1%8c%e4%b8%ba%e3%80%82NSProxy%e6%98%af%e4%b8%93%e9%97%a8%e7%94%a8%e4%ba%8e%e5%ae%9e%e7%8e%b0%e4%bb%a3%e7%90%86%e5%af%b9%e8%b1%a1%e7%9a%84%e7%b1%bb%ef%bc%8c%e8%bf%99%e4%b8%aa%e7%b1%bb%e6%9a%82%e6%97%b6%e6%9c%ac%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%8d%e6%8f%90%e3%80%82%e8%bf%99%e4%b8%a4%e4%b8%aa%e7%b1%bb%e9%83%bd%e9%81%b5%e5%be%aa%e4%ba%86NSObject%e5%8d%8f%e8%ae%ae%e3%80%82%e5%9c%a8NSObject%e5%8d%8f%e8%ae%ae%e4%b8%ad%ef%bc%8c%e5%a3%b0%e6%98%8e%e4%ba%86%e6%89%80%e6%9c%89OC%e5%af%b9%e8%b1%a1%e7%9a%84%e5%85%ac%e5%85%b1%e6%96%b9%e6%b3%95%e3%80%82%0a%e5%9c%a8NSObject%e5%8d%8f%e8%ae%ae%e4%b8%ad%ef%bc%8c%e6%9c%89%e4%bb%a5%e4%b8%8b5%e4%b8%aa%e6%96%b9%e6%b3%95%ef%bc%8c%e6%98%af%e5%8f%af%e4%bb%a5%e4%bb%8eRuntime%e4%b8%ad%e8%8e%b7%e5%8f%96%e4%bf%a1%e6%81%af%ef%bc%8c%e8%ae%a9%e5%af%b9%e8%b1%a1%e8%bf%9b%e8%a1%8c%e8%87%aa%e6%88%91%e6%a3%80%e6%9f%a5%e3%80%82%0a-%20%28Class%29class%20OBJC_SWIFT_UNAVAILABLE%28%26%2334%3buse%20%26%2339%3banObject.dynamicType%26%2339%3b%20instead%26%2334%3b%29%3b%20-%20%28BOOL%29isKindOfClass%3a%28Class%29aClass%3b%20-%20%28BOOL%29isMemberOfClass%3a%28Class%29aClass%3b%20-%20%28BOOL%29conformsToProtocol%3a%28Protocol%20%2a%29aProtocol%3b%20-%20%28BOOL%29respondsToSelector%3a%28SEL%29aSelector%3b%20-class%e6%96%b9%e6%b3%95%e8%bf%94%e5%9b%9e%e5%af%b9%e8%b1%a1%e7%9a%84%e7%b1%bb%ef%bc%9b%20-isKindOfClass%3a%20%e5%92%8c%20-isMemberOfClass%3a%20%e6%96%b9%e6%b3%95%e6%a3%80%e6%9f%a5%e5%af%b9%e8%b1%a1%e6%98%af%e5%90%a6%e5%ad%98%e5%9c%a8%e4%ba%8e%e6%8c%87%e5%ae%9a%e7%9a%84%e7%b1%bb%e7%9a%84%e7%bb%a7%e6%89%bf%e4%bd%93%e7%b3%bb%e4%b8%ad%ef%bc%9b%20-respondsToSelector%3a%20%e6%a3%80%e6%9f%a5%e5%af%b9%e8%b1%a1%e8%83%bd%e5%90%a6%e5%93%8d%e5%ba%94%e6%8c%87%e5%ae%9a%e7%9a%84%e6%b6%88%e6%81%af%ef%bc%9b%20-conformsToProtocol%3a%e6%a3%80%e6%9f%a5%e5%af%b9%e8%b1%a1%e6%98%af%e5%90%a6%e5%ae%9e%e7%8e%b0%e4%ba%86%e6%8c%87%e5%ae%9a%e5%8d%8f%e8%ae%ae%e7%b1%bb%e7%9a%84%e6%96%b9%e6%b3%95%ef%bc%9b"><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&t=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div><div id=toc><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#一-runtime简介>一. Runtime简介</a></li><li><a href=#二-nsobject起源>二. NSObject起源</a></li><li><a href=#三-入院考试>三. 入院考试</a></li><li><a href=#一self-class-与-super-class>（一）[self class] 与 [super class]</a></li><li><a href=#二iskindofclass-与-ismemberofclass>（二）isKindOfClass 与 isMemberOfClass</a></li><li><a href=#三class与内存地址>（三）Class与内存地址</a></li><li><a href=#最后>最后</a></li></ul></li></ul></li></ul></nav></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">神经病院 Objective-C Runtime 入院第一天—— isa 和 Class</h1><div class=meta><div class=postdate><time datetime="2016-09-10 01:25:00 +0000 UTC" itemprop=datePublished>Sep 10</time></div><div class=article-category><i class="fas fa-archive"></i><a class=category-link href=/categories/ios>iOS</a>
,
<a class=category-link href=/categories/runtime>Runtime</a>
,
<a class=category-link href=/categories/isa>isa</a>
,
<a class=category-link href=/categories/class>Class</a></div><div class=article-tag><i class="fas fa-tag"></i><a class=tag-link href=/tags/ios rel=tag>iOS</a>
,
<a class=tag-link href=/tags/runtime rel=tag>Runtime</a>
,
<a class=tag-link href=/tags/isa rel=tag>isa</a>
,
<a class=tag-link href=/tags/class rel=tag>Class</a></div></div></header><div class=content itemprop=articleBody><h4 id=前言>前言</h4><p>我第一次开始重视Objective-C Runtime是从2014年11月1日，@唐巧老师在微博上发的一条微博开始。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_1_.png alt></p><p>这是sunnyxx在线下的一次分享会。会上还给了4道题目。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_2.png alt></p><p>这4道题以我当时的知识，很多就不确定，拿不准。从这次入院考试开始，就成功入院了。后来这两年对Runtime的理解慢慢增加了，打算今天自己总结总结平时一直躺在我印象笔记里面的笔记。有些人可能有疑惑，学习Runtime到底有啥用，平时好像并不会用到。希望看完我这次的总结，心中能解开一些疑惑。</p><p>####目录</p><ul><li>1.Runtime简介</li><li>2.NSObject起源<ul><li>(1) isa_t结构体的具体实现</li><li>(2) cache_t的具体实现</li><li>(3) class_data_bits_t的具体实现</li></ul></li><li>3.入院考试</li></ul><h4 id=一-runtime简介>一. Runtime简介</h4><p>Runtime 又叫运行时，是一套底层的 C 语言 API，是 iOS 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。</p><p>C语言中，在编译期，函数的调用就会决定调用哪个函数。
而OC的函数，属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。</p><p>Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。</p><p>Objc 在三种层面上与 Runtime 系统进行交互：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_3.png alt></p><h5 id=1-通过-objective-c-源代码>1. 通过 Objective-C 源代码</h5><p>一般情况开发者只需要编写 OC 代码即可，Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码，在运行时确定对应的数据结构和调用具体哪个方法。</p><h5 id=2-通过-foundation-框架的-nsobject-类定义的方法>2. 通过 Foundation 框架的 NSObject 类定义的方法</h5><p>在OC的世界中，除了NSProxy类以外，所有的类都是NSObject的子类。在Foundation框架下，NSObject和NSProxy两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy是专门用于实现代理对象的类，这个类暂时本篇文章不提。这两个类都遵循了NSObject协议。在NSObject协议中，声明了所有OC对象的公共方法。</p><p>在NSObject协议中，有以下5个方法，是可以从Runtime中获取信息，让对象进行自我检查。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>- (<span style=color:#66d9ef>Class</span>)<span style=color:#a6e22e>class</span> OBJC_SWIFT_UNAVAILABLE(<span style=color:#e6db74>&#34;use &#39;anObject.dynamicType&#39; instead&#34;</span>);
- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>isKindOfClass:</span>(<span style=color:#66d9ef>Class</span>)aClass;
- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>isMemberOfClass:</span>(<span style=color:#66d9ef>Class</span>)aClass;
- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>conformsToProtocol:</span>(Protocol <span style=color:#f92672>*</span>)aProtocol;
- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>respondsToSelector:</span>(<span style=color:#66d9ef>SEL</span>)aSelector;
</code></pre></div><p>-class方法返回对象的类；
-isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中；
-respondsToSelector: 检查对象能否响应指定的消息；
-conformsToProtocol:检查对象是否实现了指定协议类的方法；</p><p>在NSObject的类中还定义了一个方法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>IMP</span>)<span style=color:#a6e22e>methodForSelector:</span>(<span style=color:#66d9ef>SEL</span>)aSelector;

</code></pre></div><p>这个方法会返回指定方法实现的地址IMP。</p><p>以上这些方法会在本篇文章中详细分析具体实现。</p><h5 id=3-通过对-runtime-库函数的直接调用>3. 通过对 Runtime 库函数的直接调用</h5><p>关于库函数可以在<a href=https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html>Objective-C Runtime Reference</a>中查看 Runtime 函数的详细文档。</p><p>关于这一点，其实还有一个小插曲。当我们导入了objc/Runtime.h和objc/message.h两个头文件之后，我们查找到了Runtime的函数之后，代码打完，发现没有代码提示了，那些函数里面的参数和描述都没有了。对于熟悉Runtime的开发者来说，这并没有什么难的，因为参数早已铭记于胸。但是对于新手来说，这是相当不友好的。而且，如果是从iOS6开始开发的同学，依稀可能能感受到，关于Runtime的具体实现的官方文档越来越少了？可能还怀疑是不是错觉。其实从Xcode5开始，苹果就不建议我们手动调用Runtime的API，也同样希望我们不要知道具体底层实现。所以IDE上面默认代了一个参数，禁止了Runtime的代码提示，源码和文档方面也删除了一些解释。</p><p>具体设置如下:</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_4.png alt></p><p>如果发现导入了两个库文件之后，仍然没有代码提示，就需要把这里的设置改成NO，即可。</p><h4 id=二-nsobject起源>二. NSObject起源</h4><p>由上面一章节，我们知道了与Runtime交互有3种方式，前两种方式都与NSObject有关，那我们就从NSObject基类开始说起。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_5.png alt></p><p>以下源码分析均来自<a href=http://opensource.apple.com//source/objc4/%C2%A0>objc4-680</a></p><p>NSObject的定义如下</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> objc_class <span style=color:#f92672>*</span><span style=color:#66d9ef>Class</span>;

<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>NSObject</span> <span style=color:#f92672>&lt;</span>NSObject<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>Class</span> isa  OBJC_ISA_AVAILABILITY;
}

</code></pre></div><p>在Objc2.0之前，objc_class源码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>struct</span> objc_class {
    <span style=color:#66d9ef>Class</span> isa  OBJC_ISA_AVAILABILITY;
    
<span style=color:#75715e>#if !__OBJC2__
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>Class</span> super_class                                        OBJC2_UNAVAILABLE;
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name                                         OBJC2_UNAVAILABLE;
    <span style=color:#66d9ef>long</span> version                                             OBJC2_UNAVAILABLE;
    <span style=color:#66d9ef>long</span> info                                                OBJC2_UNAVAILABLE;
    <span style=color:#66d9ef>long</span> instance_size                                       OBJC2_UNAVAILABLE;
    <span style=color:#66d9ef>struct</span> objc_ivar_list <span style=color:#f92672>*</span>ivars                             OBJC2_UNAVAILABLE;
    <span style=color:#66d9ef>struct</span> objc_method_list <span style=color:#f92672>**</span>methodLists                    OBJC2_UNAVAILABLE;
    <span style=color:#66d9ef>struct</span> objc_cache <span style=color:#f92672>*</span>cache                                 OBJC2_UNAVAILABLE;
    <span style=color:#66d9ef>struct</span> objc_protocol_list <span style=color:#f92672>*</span>protocols                     OBJC2_UNAVAILABLE;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    
} OBJC2_UNAVAILABLE;

</code></pre></div><p>在这里可以看到，在一个类中，有超类的指针，类名，版本的信息。
ivars是objc_ivar_list成员变量列表的指针；methodLists是指向objc_method_list指针的指针。*methodLists是指向方法列表的指针。这里如果动态修改*methodLists的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。</p><p>关于Category，这里推荐2篇文章可以仔细研读一下。<br><a href=http://tech.meituan.com/DiveIntoCategory.html>深入理解Objective-C：Category</a><br><a href=https://bestswifter.com/jie-he-category-gong-zuo-yuan-li-fen-xi-oc2-0-zhong-de-runtime/>结合 Category 工作原理分析 OC2.0 中的 runtime</a></p><p>然后在2006年苹果发布Objc 2.0之后，objc_class的定义就变成下面这个样子了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> objc_class <span style=color:#f92672>*</span><span style=color:#66d9ef>Class</span>;
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> objc_object <span style=color:#f92672>*</span><span style=color:#66d9ef>id</span>;

<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>Object</span> { 
    <span style=color:#66d9ef>Class</span> isa; 
}

<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>NSObject</span> <span style=color:#f92672>&lt;</span>NSObject<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>Class</span> isa  OBJC_ISA_AVAILABILITY;
}

<span style=color:#66d9ef>struct</span> objc_object {
private:
    isa_t isa;
}

<span style=color:#66d9ef>struct</span> objc_class : objc_object {
    <span style=color:#75715e>// Class ISA;
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>Class</span> superclass;
    cache_t cache;             <span style=color:#75715e>// formerly cache pointer and vtable
</span><span style=color:#75715e></span>    class_data_bits_t bits;    <span style=color:#75715e>// class_rw_t * plus custom rr/alloc flags
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>union</span> isa_t 
{
    isa_t() { }
    isa_t(uintptr_t value) <span style=color:#f92672>:</span> bits(value) { }
    <span style=color:#66d9ef>Class</span> cls;
    uintptr_t bits;
}

</code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_6.png alt></p><p>把源码的定义转化成类图，就是上图的样子。</p><p>从上述源码中，我们可以看到，<strong>Objective-C 对象都是 C 语言结构体实现的</strong>，在objc2.0中，所有的对象都会包含一个isa_t类型的结构体。</p><p>objc_object被源码typedef成了id类型，这也就是我们平时遇到的id类型。这个结构体中就只包含了一个isa_t类型的结构体。这个结构体在下面会详细分析。</p><p>objc_class继承于objc_object。所以在objc_class中也会包含isa_t类型的结构体isa。至此，可以得出结论：<strong>Objective-C 中类也是一个对象</strong>。在objc_class中，除了isa之外，还有3个成员变量，一个是父类的指针，一个是方法缓存，最后一个这个类的实例方法链表。</p><p>object类和NSObject类里面分别都包含一个objc_class类型的isa。</p><p>上图的左半边类的关系描述完了，接着先从isa来说起。</p><p>当一个对象的实例方法被调用的时候，会通过isa找到相应的类，然后在该类的class_data_bits_t中去查找方法。class_data_bits_t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。</p><p>但是在我们调用类方法的时候，类对象的isa里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。</p><p>关于元类，更多具体可以研究这篇文章<a href=http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html>What is a meta-class in Objective-C?</a></p><p>在引入元类之后，类对象和对象查找方法的机制就完全统一了。</p><p>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。
类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</p><p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p><p>对应关系的图如下图，下图很好的描述了对象，类，元类之间的关系:</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_7.png alt></p><p>图中实线是 super_class指针，虚线是isa指针。</p><ol><li>Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil。</li><li>每个Class都有一个isa指针指向唯一的Meta class</li><li>Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。</li><li>每个Meta class的isa指针都指向Root class (meta)。</li></ol><p>我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在main方法执行之前，从 dyld到runtime这期间，类对象和元类对象在这期间被创建。具体可看sunnyxx这篇<a href=http://blog.sunnyxx.com/2014/08/30/objc-pre-main/>iOS 程序 main 函数之前发生了什么</a></p><h5 id=1isa_t结构体的具体实现>（1）isa_t结构体的具体实现</h5><p>接下来我们就该研究研究isa的具体实现了。objc_object里面的isa是isa_t类型。通过查看源码，我们可以知道isa_t是一个union联合体。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>struct</span> objc_object {
private:
    isa_t isa;
public:
    <span style=color:#75715e>// initIsa() should be used to init the isa of new objects only.
</span><span style=color:#75715e></span>    <span style=color:#75715e>// If this object already has an isa, use changeIsa() for correctness.
</span><span style=color:#75715e></span>    <span style=color:#75715e>// initInstanceIsa(): objects with no custom RR/AWZ
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> initIsa(<span style=color:#66d9ef>Class</span> cls <span style=color:#75715e>/*indexed=false*/</span>);
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initInstanceIsa</span>(<span style=color:#66d9ef>Class</span> cls, <span style=color:#66d9ef>bool</span> hasCxxDtor);
private:
    <span style=color:#66d9ef>void</span> initIsa(<span style=color:#66d9ef>Class</span> newCls, <span style=color:#66d9ef>bool</span> indexed, <span style=color:#66d9ef>bool</span> hasCxxDtor);
<span style=color:#960050;background-color:#1e0010>｝</span>

</code></pre></div><p>那就从initIsa方法开始研究。下面以arm64为例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span>
objc_object<span style=color:#f92672>::</span>initInstanceIsa(<span style=color:#66d9ef>Class</span> cls, <span style=color:#66d9ef>bool</span> hasCxxDtor)
{
    initIsa(cls, true, hasCxxDtor);
}

<span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span>
objc_object<span style=color:#f92672>::</span>initIsa(<span style=color:#66d9ef>Class</span> cls, <span style=color:#66d9ef>bool</span> indexed, <span style=color:#66d9ef>bool</span> hasCxxDtor)
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>indexed) {
        isa.cls <span style=color:#f92672>=</span> cls;
    } <span style=color:#66d9ef>else</span> {
        isa.bits <span style=color:#f92672>=</span> ISA_MAGIC_VALUE;
        isa.has_cxx_dtor <span style=color:#f92672>=</span> hasCxxDtor;
        isa.shiftcls <span style=color:#f92672>=</span> (uintptr_t)cls <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>;
    }
}

</code></pre></div><p>initIsa第二个参数传入了一个true，所以initIsa就会执行else里面的语句。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#75715e># if __arm64__
</span><span style=color:#75715e>#   define ISA_MASK        0x0000000ffffffff8ULL
</span><span style=color:#75715e>#   define ISA_MAGIC_MASK  0x000003f000000001ULL
</span><span style=color:#75715e>#   define ISA_MAGIC_VALUE 0x000001a000000001ULL
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> {
        uintptr_t indexed           : <span style=color:#ae81ff>1</span>;
        uintptr_t has_assoc         : <span style=color:#ae81ff>1</span>;
        uintptr_t has_cxx_dtor      : <span style=color:#ae81ff>1</span>;
        uintptr_t shiftcls          : <span style=color:#ae81ff>33</span>; <span style=color:#75715e>// MACH_VM_MAX_ADDRESS 0x1000000000
</span><span style=color:#75715e></span>        uintptr_t magic             : <span style=color:#ae81ff>6</span>;
        uintptr_t weakly_referenced : <span style=color:#ae81ff>1</span>;
        uintptr_t deallocating      : <span style=color:#ae81ff>1</span>;
        uintptr_t has_sidetable_rc  : <span style=color:#ae81ff>1</span>;
        uintptr_t extra_rc          : <span style=color:#ae81ff>19</span>;
<span style=color:#75715e>#       define RC_ONE   (1ULL&lt;&lt;45)
</span><span style=color:#75715e>#       define RC_HALF  (1ULL&lt;&lt;18)
</span><span style=color:#75715e></span>    };

<span style=color:#75715e># elif __x86_64__
</span><span style=color:#75715e>#   define ISA_MASK        0x00007ffffffffff8ULL
</span><span style=color:#75715e>#   define ISA_MAGIC_MASK  0x001f800000000001ULL
</span><span style=color:#75715e>#   define ISA_MAGIC_VALUE 0x001d800000000001ULL
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> {
        uintptr_t indexed           : <span style=color:#ae81ff>1</span>;
        uintptr_t has_assoc         : <span style=color:#ae81ff>1</span>;
        uintptr_t has_cxx_dtor      : <span style=color:#ae81ff>1</span>;
        uintptr_t shiftcls          : <span style=color:#ae81ff>44</span>; <span style=color:#75715e>// MACH_VM_MAX_ADDRESS 0x7fffffe00000
</span><span style=color:#75715e></span>        uintptr_t magic             : <span style=color:#ae81ff>6</span>;
        uintptr_t weakly_referenced : <span style=color:#ae81ff>1</span>;
        uintptr_t deallocating      : <span style=color:#ae81ff>1</span>;
        uintptr_t has_sidetable_rc  : <span style=color:#ae81ff>1</span>;
        uintptr_t extra_rc          : <span style=color:#ae81ff>8</span>;
<span style=color:#75715e>#       define RC_ONE   (1ULL&lt;&lt;56)
</span><span style=color:#75715e>#       define RC_HALF  (1ULL&lt;&lt;7)
</span><span style=color:#75715e></span>    };


</code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_8.png alt></p><p>ISA_MAGIC_VALUE = 0x000001a000000001ULL转换成二进制是11010000000000000000000000000000000000001，结构如下图：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_9.png alt></p><p>关于参数的说明：</p><p>第一位index，代表是否开启isa指针优化。index = 1，代表开启isa指针优化。</p><p>在2013年9月，苹果推出了<a href=http://en.wikipedia.org/wiki/IPhone_5S>iPhone5s</a>，与此同时，iPhone5s配备了首个采用64位架构的<a href=http://en.wikipedia.org/wiki/Apple_A7>A7双核处理器</a>，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。</p><p>在WWDC2013的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。</p><p>假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。如下图所示：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_10.png alt></p><p>苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了Tagged Pointer对象之后，64位CPU下NSNumber的内存图变成了以下这样：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_11.png alt></p><p>关于<a href=http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/>Tagged Pointer技术</a>详细的，可以看上面链接那个文章。</p><p>has_assoc
对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</p><p>has_cxx_dtor
表示该对象是否有 C++ 或者 Objc 的析构器</p><p>shiftcls
类的指针。arm64架构中有33位可以存储类指针。</p><p>源码中isa.shiftcls = (uintptr_t)cls &#187; 3;
将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看<a href=https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md#shiftcls>从 NSObject 的初始化了解 isa</a>这篇文章里面的shiftcls分析。</p><ul><li><p>magic
判断对象是否初始化完成，在arm64中0x16是调试器判断当前对象是真的对象还是没有初始化的空间。</p></li><li><p>weakly_referenced
对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</p></li><li><p>deallocating
对象是否正在释放内存</p></li><li><p>has_sidetable_rc
判断该对象的引用计数是否过大，如果过大则需要其他散列表来进行存储。</p></li><li><p>extra_rc
存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc的值就为 9。</p></li></ul><p>ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取MAGIC值 和 isa类指针。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>Class</span> 
objc_object<span style=color:#f92672>::</span>ISA() 
{
    assert(<span style=color:#f92672>!</span>isTaggedPointer()); 
    <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>Class</span>)(isa.bits <span style=color:#f92672>&amp;</span> ISA_MASK);
}

</code></pre></div><p>关于x86_64的架构，具体可以看<a href=https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md>从 NSObject 的初始化了解 isa</a>文章里面的详细分析。</p><h5 id=2cache_t的具体实现>（2）cache_t的具体实现</h5><p>还是继续看源码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec><span style=color:#66d9ef>struct</span> cache_t {
    <span style=color:#66d9ef>struct</span> bucket_t <span style=color:#f92672>*</span>_buckets;
    mask_t _mask;
    mask_t _occupied;
}

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> uint32_t;
<span style=color:#66d9ef>typedef</span> uint32_t mask_t;  <span style=color:#75715e>// x86_64 &amp; arm64 asm are less efficient with 16-bits
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>  uintptr_t;
<span style=color:#66d9ef>typedef</span> uintptr_t cache_key_t;

<span style=color:#66d9ef>struct</span> bucket_t {
private:
    cache_key_t _key;
    <span style=color:#66d9ef>IMP</span> _imp;
}
</code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_12.png alt></p><p>根据源码，我们可以知道cache_t中存储了一个bucket_t的结构体，和两个unsigned int的变量。</p><p>mask：分配用来缓存bucket的总数。
occupied：表明目前实际占用的缓存bucket的个数。</p><p>bucket_t的结构体中存储了一个unsigned long和一个IMP。IMP是一个函数指针，指向了一个方法的具体实现。</p><p>cache_t中的bucket_t *_buckets其实就是一个散列表，用来存储Method的链表。</p><p>Cache的作用主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。</p><h5 id=3class_data_bits_t的具体实现>（3）class_data_bits_t的具体实现</h5><p>源码实现如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>struct</span> class_data_bits_t {

    <span style=color:#75715e>// Values are the FAST_ flags above.
</span><span style=color:#75715e></span>    uintptr_t bits;
}

<span style=color:#66d9ef>struct</span> class_rw_t {
    uint32_t flags;
    uint32_t version;

    <span style=color:#66d9ef>const</span> class_ro_t <span style=color:#f92672>*</span>ro;

    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    <span style=color:#66d9ef>Class</span> firstSubclass;
    <span style=color:#66d9ef>Class</span> nextSiblingClass;

    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>demangledName;
}

<span style=color:#66d9ef>struct</span> class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
<span style=color:#75715e>#ifdef __LP64__
</span><span style=color:#75715e></span>    uint32_t reserved;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>const</span> uint8_t <span style=color:#f92672>*</span> ivarLayout;
    
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> name;
    method_list_t <span style=color:#f92672>*</span> baseMethodList;
    protocol_list_t <span style=color:#f92672>*</span> baseProtocols;
    <span style=color:#66d9ef>const</span> ivar_list_t <span style=color:#f92672>*</span> ivars;

    <span style=color:#66d9ef>const</span> uint8_t <span style=color:#f92672>*</span> weakIvarLayout;
    property_list_t <span style=color:#f92672>*</span>baseProperties;

    method_list_t <span style=color:#f92672>*</span><span style=color:#a6e22e>baseMethods</span>() <span style=color:#66d9ef>const</span> {
        <span style=color:#66d9ef>return</span> baseMethodList;
    }
};

</code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_13.png alt></p><p>在 objc_class结构体中的注释写到 class_data_bits_t相当于 class_rw_t指针加上 rr/alloc 的标志。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
class_data_bits_t bits; <span style=color:#75715e>// class_rw_t * plus custom rr/alloc flags
</span><span style=color:#75715e></span>
</code></pre></div><p>它为我们提供了便捷方法用于返回其中的 class_rw_t *指针：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
class_rw_t <span style=color:#f92672>*</span><span style=color:#a6e22e>data</span>() {
    <span style=color:#66d9ef>return</span> bits.data();
}

</code></pre></div><p>Objc的类的属性、方法、以及遵循的协议在obj 2.0的版本之后都放在class_rw_t中。class_ro_t是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。rw-readwrite，ro-readonly</p><p>在编译期类的结构中的 class_data_bits_t *data指向的是一个 class_ro_t *指针：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_14.png alt></p><p>在运行时调用 realizeClass方法，会做以下3件事情：</p><ol><li>从 class_data_bits_t调用 data方法，将结果从 class_rw_t强制转换为 class_ro_t指针</li><li>初始化一个 class_rw_t结构体</li><li>设置结构体 ro的值以及 flag</li></ol><p>最后调用methodizeClass方法，把类里面的属性，协议，方法都加载进来。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>struct</span> method_t {
    <span style=color:#66d9ef>SEL</span> name;
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>types;
    <span style=color:#66d9ef>IMP</span> imp;

    <span style=color:#66d9ef>struct</span> SortBySELAddress :
        public std<span style=color:#f92672>::</span>binary_function<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> method_t<span style=color:#f92672>&amp;</span>,
                                    <span style=color:#66d9ef>const</span> method_t<span style=color:#f92672>&amp;</span>, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>
    {
        <span style=color:#66d9ef>bool</span> operator() (<span style=color:#66d9ef>const</span> method_t<span style=color:#f92672>&amp;</span> lhs,
                         <span style=color:#66d9ef>const</span> method_t<span style=color:#f92672>&amp;</span> rhs)
        { <span style=color:#66d9ef>return</span> lhs.name <span style=color:#f92672>&lt;</span> rhs.name; }
    };
};
</code></pre></div><p>方法method的定义如上。里面包含3个成员变量。SEL是方法的名字name。types是Type Encoding类型编码，类型可参考<a href=https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html>Type Encoding</a>，在此不细说。</p><p>IMP是一个函数指针，指向的是函数的具体实现。在runtime中消息传递和转发的目的就是为了找到IMP，并执行函数。</p><p>整个运行时过程可以描述如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_15.png alt></p><p>更加详细的分析，请看<a href=https://github.com/Draveness>@Draveness</a> 的这篇文章<a href=https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md#%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-objc-%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84>深入解析 ObjC 中方法的结构</a></p><p>到此，总结一下objc_class 1.0和2.0的差别。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_16.png alt></p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_17.png alt></p><h4 id=三-入院考试>三. 入院考试</h4><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_18.png alt></p><h4 id=一self-class-与-super-class>（一）[self class] 与 [super class]</h4><blockquote><p>下面代码输出什么?</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>    <span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>Son</span> : <span style=color:#a6e22e>Father</span>
    <span style=color:#f92672>-</span> (<span style=color:#66d9ef>id</span>)init
    {
        self <span style=color:#f92672>=</span> [super init];
        <span style=color:#66d9ef>if</span> (self)
        {
            NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>, NSStringFromClass([self <span style=color:#66d9ef>class</span>]));
            NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>, NSStringFromClass([super <span style=color:#66d9ef>class</span>]));
        }
    <span style=color:#66d9ef>return</span> self;
    }
    <span style=color:#66d9ef>@end</span>
</code></pre></div><p>self和super的区别：</p><p>self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。</p><p>super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用方法时，去调用父类的方法，而不是本类中的方法。</p><p>在调用[super class]的时候，runtime会去调用objc_msgSendSuper方法，而不是objc_msgSend</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
OBJC_EXPORT <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>objc_msgSendSuper</span>(<span style=color:#66d9ef>void</span> <span style=color:#75715e>/* struct objc_super *super, SEL op, ... */</span> )


<span style=color:#75715e>/// Specifies the superclass of an instance. 
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> objc_super {
    <span style=color:#75715e>/// Specifies an instance of a class.
</span><span style=color:#75715e></span>    __unsafe_unretained <span style=color:#66d9ef>id</span> receiver;

    <span style=color:#75715e>/// Specifies the particular superclass of the instance to message. 
</span><span style=color:#75715e></span><span style=color:#75715e>#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__
</span><span style=color:#75715e></span>    <span style=color:#75715e>/* For compatibility with old objc-runtime.h header */</span>
    __unsafe_unretained <span style=color:#66d9ef>Class</span> <span style=color:#66d9ef>class</span>;
<span style=color:#75715e>#else
</span><span style=color:#75715e></span>    __unsafe_unretained <span style=color:#66d9ef>Class</span> super_class;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    <span style=color:#75715e>/* super_class is the first class to search */</span>
};

</code></pre></div><p>在objc_msgSendSuper方法中，第一个参数是一个objc_super的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是
当前类的父类super_class。</p><p>入院考试第一题错误的原因就在这里，误认为[super class]是调用的[super_class class]。</p><p>objc_msgSendSuper的工作原理应该是这样的:
从objc_super结构体指向的superClass父类的方法列表开始查找selector，找到后以objc->receiver去调用父类的这个selector。注意，最后的调用者是objc->receiver，而不是super_class！</p><p>那么objc_msgSendSuper最后就转变成</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>// 注意这里是从父类开始msgSend，而不是从本类开始，谢谢@Josscii 和他同事共同指点出此处描述的不妥。
</span><span style=color:#75715e></span>objc_msgSend(objc_super<span style=color:#f92672>-&gt;</span>receiver, <span style=color:#66d9ef>@selector</span>(<span style=color:#66d9ef>class</span>))

<span style=color:#75715e>/// Specifies an instance of a class.  这是类的一个实例
</span><span style=color:#75715e></span>    __unsafe_unretained <span style=color:#66d9ef>id</span> receiver;   


<span style=color:#75715e>// 由于是实例调用，所以是减号方法
</span><span style=color:#75715e></span>- (<span style=color:#66d9ef>Class</span>)<span style=color:#a6e22e>class</span> {
    <span style=color:#66d9ef>return</span> object_getClass(self);
}

</code></pre></div><p>由于找到了父类NSObject里面的class方法的IMP，又因为传入的入参objc_super->receiver = self。self就是son，调用class，所以父类的方法class执行IMP之后，输出还是son，最后输出两个都一样，都是输出son。</p><h4 id=二iskindofclass-与-ismemberofclass>（二）isKindOfClass 与 isMemberOfClass</h4><blockquote><p>下面代码输出什么？</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
     <span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>Sark</span> : <span style=color:#a6e22e>NSObject</span>
     <span style=color:#66d9ef>@end</span>

     <span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>Sark</span>
     <span style=color:#66d9ef>@end</span>

  <span style=color:#66d9ef>int</span> main(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> argv[]) {
    <span style=color:#66d9ef>@autoreleasepool</span> {
        <span style=color:#66d9ef>BOOL</span> res1 <span style=color:#f92672>=</span> [(<span style=color:#66d9ef>id</span>)[NSObject <span style=color:#66d9ef>class</span>] isKindOfClass:[NSObject <span style=color:#66d9ef>class</span>]];
        <span style=color:#66d9ef>BOOL</span> res2 <span style=color:#f92672>=</span> [(<span style=color:#66d9ef>id</span>)[NSObject <span style=color:#66d9ef>class</span>] isMemberOfClass:[NSObject <span style=color:#66d9ef>class</span>]];
        <span style=color:#66d9ef>BOOL</span> res3 <span style=color:#f92672>=</span> [(<span style=color:#66d9ef>id</span>)[Sark <span style=color:#66d9ef>class</span>] isKindOfClass:[Sark <span style=color:#66d9ef>class</span>]];
        <span style=color:#66d9ef>BOOL</span> res4 <span style=color:#f92672>=</span> [(<span style=color:#66d9ef>id</span>)[Sark <span style=color:#66d9ef>class</span>] isMemberOfClass:[Sark <span style=color:#66d9ef>class</span>]];

        NSLog(<span style=color:#e6db74>@&#34;%d %d %d %d&#34;</span>, res1, res2, res3, res4);
    }
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
  }
</code></pre></div><p>先来分析一下源码这两个函数的对象实现</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

+ (<span style=color:#66d9ef>Class</span>)<span style=color:#a6e22e>class</span> {
    <span style=color:#66d9ef>return</span> self;
}

- (<span style=color:#66d9ef>Class</span>)<span style=color:#a6e22e>class</span> {
    <span style=color:#66d9ef>return</span> object_getClass(self);
}

<span style=color:#66d9ef>Class</span> <span style=color:#a6e22e>object_getClass</span>(<span style=color:#66d9ef>id</span> obj)
{
    <span style=color:#66d9ef>if</span> (obj) <span style=color:#66d9ef>return</span> obj<span style=color:#f92672>-&gt;</span>getIsa();
    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> Nil;
}

<span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>Class</span> 
objc_object<span style=color:#f92672>::</span>getIsa() 
{
    <span style=color:#66d9ef>if</span> (isTaggedPointer()) {
        uintptr_t slot <span style=color:#f92672>=</span> ((uintptr_t)this <span style=color:#f92672>&gt;&gt;</span> TAG_SLOT_SHIFT) <span style=color:#f92672>&amp;</span> TAG_SLOT_MASK;
        <span style=color:#66d9ef>return</span> objc_tag_classes[slot];
    }
    <span style=color:#66d9ef>return</span> ISA();
}

<span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>Class</span> 
objc_object<span style=color:#f92672>::</span>ISA() 
{
    assert(<span style=color:#f92672>!</span>isTaggedPointer()); 
    <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>Class</span>)(isa.bits <span style=color:#f92672>&amp;</span> ISA_MASK);
}

<span style=color:#f92672>+</span> (<span style=color:#66d9ef>BOOL</span>)isKindOfClass:(<span style=color:#66d9ef>Class</span>)cls {
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>Class</span> tcls <span style=color:#f92672>=</span> object_getClass((<span style=color:#66d9ef>id</span>)self); tcls; tcls <span style=color:#f92672>=</span> tcls<span style=color:#f92672>-&gt;</span>superclass) {
        <span style=color:#66d9ef>if</span> (tcls <span style=color:#f92672>==</span> cls) <span style=color:#66d9ef>return</span> YES;
    }
    <span style=color:#66d9ef>return</span> NO;
}

<span style=color:#f92672>-</span> (<span style=color:#66d9ef>BOOL</span>)isKindOfClass:(<span style=color:#66d9ef>Class</span>)cls {
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>Class</span> tcls <span style=color:#f92672>=</span> [self <span style=color:#66d9ef>class</span>]; tcls; tcls <span style=color:#f92672>=</span> tcls<span style=color:#f92672>-&gt;</span>superclass) {
        <span style=color:#66d9ef>if</span> (tcls <span style=color:#f92672>==</span> cls) <span style=color:#66d9ef>return</span> YES;
    }
    <span style=color:#66d9ef>return</span> NO;
}

<span style=color:#f92672>+</span> (<span style=color:#66d9ef>BOOL</span>)isMemberOfClass:(<span style=color:#66d9ef>Class</span>)cls {
    <span style=color:#66d9ef>return</span> object_getClass((<span style=color:#66d9ef>id</span>)self) <span style=color:#f92672>==</span> cls;
}

<span style=color:#f92672>-</span> (<span style=color:#66d9ef>BOOL</span>)isMemberOfClass:(<span style=color:#66d9ef>Class</span>)cls {
    <span style=color:#66d9ef>return</span> [self <span style=color:#66d9ef>class</span>] <span style=color:#f92672>==</span> cls;
}

</code></pre></div><p>首先题目中NSObject 和 Sark分别调用了class方法。</p><p>+ (BOOL)isKindOfClass:(Class)cls方法内部，会先去获得object_getClass的类，而object_getClass的源码实现是去调用当前类的obj->getIsa()，最后在ISA()方法中获得meta class的指针。</p><p>接着在isKindOfClass中有一个循环，先判断class是否等于meta class，不等就继续循环判断是否等于super class，不等再继续取super class，如此循环下去。</p><p>[NSObject class]执行完之后调用isKindOfClass，第一次判断先判断NSObject 和 NSObject的meta class是否相等，之前讲到meta class的时候放了一张很详细的图，从图上我们也可以看出，NSObject的meta class与本身不等。接着第二次循环判断NSObject与meta class的superclass是否相等。还是从那张图上面我们可以看到：Root class(meta) 的superclass 就是 Root class(class)，也就是NSObject本身。所以第二次循环相等，于是第一行res1输出应该为YES。</p><p>同理，[Sark class]执行完之后调用isKindOfClass，第一次for循环，Sark的Meta Class与[Sark class]不等，第二次for循环，Sark Meta Class的super class 指向的是 NSObject Meta Class， 和 Sark Class不相等。第三次for循环，NSObject Meta Class的super class指向的是NSObject Class，和 Sark Class 不相等。第四次循环，NSObject Class 的super class 指向 nil， 和 Sark Class不相等。第四次循环之后，退出循环，所以第三行的res3输出为NO。</p><p>如果把这里的Sark改成它的实例对象，[sark isKindOfClass:[Sark class]，那么此时就应该输出YES了。因为在isKindOfClass函数中，判断sark的isa指向是否是自己的类Sark，第一次for循环就能输出YES了。</p><p>isMemberOfClass的源码实现是拿到自己的isa指针和自己比较，是否相等。
第二行isa 指向 NSObject 的 Meta Class，所以和 NSObject Class不相等。第四行，isa指向Sark的Meta Class，和Sark Class也不等，所以第二行res2和第四行res4都输出NO。</p><h4 id=三class与内存地址>（三）Class与内存地址</h4><blockquote><p>下面的代码会？Compile Error / Runtime Crash / NSLog…?</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>Sark</span> : <span style=color:#a6e22e>NSObject</span>
    <span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>copy</span>) NSString <span style=color:#f92672>*</span>name;
    <span style=color:#f92672>-</span> (<span style=color:#66d9ef>void</span>)speak;
    <span style=color:#66d9ef>@end</span>
    <span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>Sark</span>
    <span style=color:#f92672>-</span> (<span style=color:#66d9ef>void</span>)speak {                            
       NSLog(<span style=color:#e6db74>@&#34;my name&#39;s %@&#34;</span>, self.name);
    }
    <span style=color:#66d9ef>@end</span>
    <span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>ViewController</span>
    <span style=color:#f92672>-</span> (<span style=color:#66d9ef>void</span>)viewDidLoad {  
       [super viewDidLoad];
       <span style=color:#66d9ef>id</span> cls <span style=color:#f92672>=</span> [Sark <span style=color:#66d9ef>class</span>];
       <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>obj <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>cls;
       [(<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>id</span>)obj speak];
    }
    <span style=color:#66d9ef>@end</span>
</code></pre></div><p>这道题有两个难点。难点一，obj调用speak方法，到底会不会崩溃。难点二，如果speak方法不崩溃，应该输出什么？</p><p>首先需要谈谈隐藏参数self和_cmd的问题。
当[receiver message]调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数self和_cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。self在上面已经讲解明白了，接下来就来说说_cmd。_cmd表示当前调用方法，其实它就是一个方法选择器SEL。</p><p>难点一，能不能调用speak方法？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>id</span> cls <span style=color:#f92672>=</span> [Sark <span style=color:#66d9ef>class</span>]; 
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>obj <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>cls;

</code></pre></div><p>答案是可以的。obj被转换成了一个指向Sark Class的指针，然后使用id转换成了objc_object类型。obj现在已经是一个Sark类型的实例对象了。当然接下来可以调用speak的方法。</p><p>难点二，如果能调用speak，会输出什么呢？</p><p>很多人可能会认为会输出sark相关的信息。这样答案就错误了。</p><p>正确的答案会输出</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>my</span> <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>is</span> &lt;<span style=color:#a6e22e>ViewController</span>: <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>ff<span style=color:#ae81ff>6</span>d<span style=color:#ae81ff>9</span>f<span style=color:#ae81ff>31</span>c<span style=color:#ae81ff>50</span>&gt;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>内存地址每次运行都不同，但是前面一定是ViewController。why？</p><p>我们把代码改变一下，打印更多的信息出来。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>viewDidLoad</span> {
    [super viewDidLoad];
    
    NSLog(<span style=color:#e6db74>@&#34;ViewController = %@ , 地址 = %p&#34;</span>, self, <span style=color:#f92672>&amp;</span>self);
    
    <span style=color:#66d9ef>id</span> cls <span style=color:#f92672>=</span> [Sark <span style=color:#66d9ef>class</span>];
    NSLog(<span style=color:#e6db74>@&#34;Sark class = %@ 地址 = %p&#34;</span>, cls, <span style=color:#f92672>&amp;</span>cls);
    
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>obj <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>cls;
    NSLog(<span style=color:#e6db74>@&#34;Void *obj = %@ 地址 = %p&#34;</span>, obj,<span style=color:#f92672>&amp;</span>obj);
    
    [(<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>id</span>)obj speak];
    
    Sark <span style=color:#f92672>*</span>sark <span style=color:#f92672>=</span> [[Sark alloc]init];
    NSLog(<span style=color:#e6db74>@&#34;Sark instance = %@ 地址 = %p&#34;</span>,sark,<span style=color:#f92672>&amp;</span>sark);
    
    [sark speak];
    
}

</code></pre></div><p>我们把对象的指针地址都打印出来。输出结果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>ViewController</span> = &lt;<span style=color:#a6e22e>ViewController</span>: <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fb<span style=color:#ae81ff>570</span>e<span style=color:#ae81ff>2</span>ad<span style=color:#ae81ff>00</span>&gt; , <span style=color:#a6e22e>地址</span> = <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>543</span>f<span style=color:#ae81ff>5</span>aa<span style=color:#ae81ff>8</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>Sark</span> <span style=color:#a6e22e>class</span> = <span style=color:#a6e22e>Sark</span> <span style=color:#a6e22e>地址</span> = <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>543</span>f<span style=color:#ae81ff>5</span>a<span style=color:#ae81ff>88</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>Void</span> *<span style=color:#a6e22e>obj</span> = &lt;<span style=color:#a6e22e>Sark</span>: <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>543</span>f<span style=color:#ae81ff>5</span>a<span style=color:#ae81ff>88</span>&gt; <span style=color:#a6e22e>地址</span> = <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>543</span>f<span style=color:#ae81ff>5</span>a<span style=color:#ae81ff>80</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>my</span> <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>is</span> &lt;<span style=color:#a6e22e>ViewController</span>: <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fb<span style=color:#ae81ff>570</span>e<span style=color:#ae81ff>2</span>ad<span style=color:#ae81ff>00</span>&gt;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>Sark</span> <span style=color:#a6e22e>instance</span> = &lt;<span style=color:#a6e22e>Sark</span>: <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fb<span style=color:#ae81ff>570</span>d<span style=color:#ae81ff>20</span>b<span style=color:#ae81ff>10</span>&gt; <span style=color:#a6e22e>地址</span> = <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>543</span>f<span style=color:#ae81ff>5</span>a<span style=color:#ae81ff>78</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>my</span> <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>is</span> (<span style=color:#a6e22e>null</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_19_.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>// objc_msgSendSuper2() takes the current search class, not its superclass.
</span><span style=color:#75715e></span>OBJC_EXPORT <span style=color:#66d9ef>id</span> <span style=color:#a6e22e>objc_msgSendSuper2</span>(<span style=color:#66d9ef>struct</span> objc_super <span style=color:#f92672>*</span>super, <span style=color:#66d9ef>SEL</span> op, ...)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_2_0);


</code></pre></div><p>objc_msgSendSuper2方法入参是一个objc_super *super。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>/// Specifies the superclass of an instance. 
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> objc_super {
    <span style=color:#75715e>/// Specifies an instance of a class.
</span><span style=color:#75715e></span>    __unsafe_unretained <span style=color:#66d9ef>id</span> receiver;

    <span style=color:#75715e>/// Specifies the particular superclass of the instance to message. 
</span><span style=color:#75715e></span><span style=color:#75715e>#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__
</span><span style=color:#75715e></span>    <span style=color:#75715e>/* For compatibility with old objc-runtime.h header */</span>
    __unsafe_unretained <span style=color:#66d9ef>Class</span> <span style=color:#66d9ef>class</span>;
<span style=color:#75715e>#else
</span><span style=color:#75715e></span>    __unsafe_unretained <span style=color:#66d9ef>Class</span> super_class;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    <span style=color:#75715e>/* super_class is the first class to search */</span>
};
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>

</code></pre></div><p>所以按viewDidLoad执行时各个变量入栈顺序从高到底为self, _cmd, super_class(等同于self.class), receiver(等同于self), obj。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_20.png alt></p><p>第一个self和第二个_cmd是隐藏参数。第三个self.class和第四个self是[super viewDidLoad]方法执行时候的参数。</p><p>在调用self.name的时候，本质上是self指针在内存向高位地址偏移一个指针。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_21.png alt></p><p>从打印结果我们可以看到，obj就是cls的地址。在obj向上偏移一个指针就到了0x7fff543f5a90，这正好是ViewController的地址。</p><p>所以输出为my name is &lt;ViewController: 0x7fb570e2ad00>。</p><p>至此，Objc中的对象到底是什么呢？</p><p>实质：<strong>Objc中的对象是一个指向ClassObject地址的变量，即 id obj = &ClassObject ， 而对象的实例变量 void *ivar = &obj + offset(N)</strong></p><p>加深一下对上面这句话的理解，下面这段代码会输出什么？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>viewDidLoad</span> {
    [super viewDidLoad];
    
    NSLog(<span style=color:#e6db74>@&#34;ViewController = %@ , 地址 = %p&#34;</span>, self, <span style=color:#f92672>&amp;</span>self);
    
    NSString <span style=color:#f92672>*</span>myName <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;halfrost&#34;</span>;
    
    <span style=color:#66d9ef>id</span> cls <span style=color:#f92672>=</span> [Sark <span style=color:#66d9ef>class</span>];
    NSLog(<span style=color:#e6db74>@&#34;Sark class = %@ 地址 = %p&#34;</span>, cls, <span style=color:#f92672>&amp;</span>cls);
    
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>obj <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>cls;
    NSLog(<span style=color:#e6db74>@&#34;Void *obj = %@ 地址 = %p&#34;</span>, obj,<span style=color:#f92672>&amp;</span>obj);
    
    [(<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>id</span>)obj speak];
    
    Sark <span style=color:#f92672>*</span>sark <span style=color:#f92672>=</span> [[Sark alloc]init];
    NSLog(<span style=color:#e6db74>@&#34;Sark instance = %@ 地址 = %p&#34;</span>,sark,<span style=color:#f92672>&amp;</span>sark);
    
    [sark speak];
    
}

</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>ViewController</span> = &lt;<span style=color:#a6e22e>ViewController</span>: <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>44404</span>ab<span style=color:#ae81ff>0</span>&gt; ,  <span style=color:#a6e22e>地址</span>  = <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>56</span>a<span style=color:#ae81ff>48</span>a<span style=color:#ae81ff>78</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>Sark</span> <span style=color:#a6e22e>class</span> = <span style=color:#a6e22e>Sark</span>  <span style=color:#a6e22e>地址</span>  = <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>56</span>a<span style=color:#ae81ff>48</span>a<span style=color:#ae81ff>50</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>Void</span> *<span style=color:#a6e22e>obj</span> = &lt;<span style=color:#a6e22e>Sark</span>: <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>56</span>a<span style=color:#ae81ff>48</span>a<span style=color:#ae81ff>50</span>&gt;  <span style=color:#a6e22e>地址</span> = <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>56</span>a<span style=color:#ae81ff>48</span>a<span style=color:#ae81ff>48</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>my</span> <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>is</span> <span style=color:#a6e22e>halfrost</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>Sark</span> <span style=color:#a6e22e>instance</span> = &lt;<span style=color:#a6e22e>Sark</span>: <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>6080000233</span>e<span style=color:#ae81ff>0</span>&gt;  <span style=color:#a6e22e>地址</span> = <span style=color:#ae81ff>0</span>x<span style=color:#ae81ff>7</span>fff<span style=color:#ae81ff>56</span>a<span style=color:#ae81ff>48</span>a<span style=color:#ae81ff>40</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>my</span> <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>is</span> (<span style=color:#a6e22e>null</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>由于加了一个字符串，结果输出就完全变了，[(__bridge id)obj speak];这句话会输出“my name is halfrost”</p><p>原因还是和上面的类似。按viewDidLoad执行时各个变量入栈顺序从高到底为self，_cmd，self.class( super_class )，self ( receiver )，myName，obj。obj往上偏移一个指针，就是myName字符串，所以输出变成了输出myName了。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_22.png alt></p><p>这里有一点需要额外说明的是，栈里面有两个 self，可能有些人认为是指针偏移到了第一个 self 了，于是打印出了 ViewController：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

my name is <span style=color:#f92672>&lt;</span>ViewController: <span style=color:#ae81ff>0x7fb570e2ad00</span><span style=color:#f92672>&gt;</span>

</code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_23.png alt></p><p>其实这种想法是不对的，从 obj 往上找 name 属性，完全是指针偏移了一个 offset 导致的，也就是说指针只往下偏移了一个。那么怎么证明指针只偏移了一个，而不是偏移了4个到最下面的 self 呢？</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_24.png alt></p><p>obj 的地址是 0x7fff5c7b9a08，self 的地址是 0x7fff5c7b9a28。每个指针占8个字节，所以从 obj 到 self 中间确实有4个指针大小的间隔。如果从 obj 偏移一个指针，就到了 0x7fff5c7b9a10。我们需要把这个内存地址里面的内容打印出来。</p><blockquote><p>LLDB 调试中，可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：
x/</p></blockquote><blockquote><p>n、f、u是可选的参数。
n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</p></blockquote><blockquote><p>f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是 i。</p></blockquote><blockquote><p>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</p></blockquote><p><img src=https://img.halfrost.com/Blog/ArticleImage/23_25.png alt></p><p>我们用 x 命令分别打印出 0x7fff5c7b9a10 和 0x7fff5c7b9a28 内存地址里面的内容，我们会发现两个打印出来的值是一样的，都是 0x7fbf0d606aa0。</p><p>这两个 self 的地址不同，里面存储的内容是相同的。</p><p>所以 obj 是偏移了一个指针，而不是偏移到最下面的 self 。</p><h4 id=最后>最后</h4><p>入院考试由于还有一题没有解答出来，所以医院决定让我住院一天观察。</p><p>未完待续，请大家多多指教。</p><p>推荐阅读：<br><a href=http://chun.tips/2014/11/05/objc-runtime-1/>刨根问底 Objective－C Runtime（1）－ Self & Super</a></p><img src=https://img.halfrost.com/wechat-qr-code.png></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div id=toc-footer style=display:none><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#一-runtime简介>一. Runtime简介</a></li><li><a href=#二-nsobject起源>二. NSObject起源</a></li><li><a href=#三-入院考试>三. 入院考试</a></li><li><a href=#一self-class-与-super-class>（一）[self class] 与 [super class]</a></li><li><a href=#二iskindofclass-与-ismemberofclass>（二）isKindOfClass 与 isMemberOfClass</a></li><li><a href=#三class与内存地址>（三）Class与内存地址</a></li><li><a href=#最后>最后</a></li></ul></li></ul></li></ul></nav></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f"><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&text=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&title=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&is_video=false&description=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f"><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&title=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&title=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&title=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-stumbleupon fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&title=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-digg fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&name=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class&description=%e5%89%8d%e8%a8%80%20%e6%88%91%e7%ac%ac%e4%b8%80%e6%ac%a1%e5%bc%80%e5%a7%8b%e9%87%8d%e8%a7%86Objective-C%20Runtime%e6%98%af%e4%bb%8e2014%e5%b9%b411%e6%9c%881%e6%97%a5%ef%bc%8c%40%e5%94%90%e5%b7%a7%e8%80%81%e5%b8%88%e5%9c%a8%e5%be%ae%e5%8d%9a%e4%b8%8a%e5%8f%91%e7%9a%84%e4%b8%80%e6%9d%a1%e5%be%ae%e5%8d%9a%e5%bc%80%e5%a7%8b%e3%80%82%0a%e8%bf%99%e6%98%afsunnyxx%e5%9c%a8%e7%ba%bf%e4%b8%8b%e7%9a%84%e4%b8%80%e6%ac%a1%e5%88%86%e4%ba%ab%e4%bc%9a%e3%80%82%e4%bc%9a%e4%b8%8a%e8%bf%98%e7%bb%99%e4%ba%864%e9%81%93%e9%a2%98%e7%9b%ae%e3%80%82%0a%e8%bf%994%e9%81%93%e9%a2%98%e4%bb%a5%e6%88%91%e5%bd%93%e6%97%b6%e7%9a%84%e7%9f%a5%e8%af%86%ef%bc%8c%e5%be%88%e5%a4%9a%e5%b0%b1%e4%b8%8d%e7%a1%ae%e5%ae%9a%ef%bc%8c%e6%8b%bf%e4%b8%8d%e5%87%86%e3%80%82%e4%bb%8e%e8%bf%99%e6%ac%a1%e5%85%a5%e9%99%a2%e8%80%83%e8%af%95%e5%bc%80%e5%a7%8b%ef%bc%8c%e5%b0%b1%e6%88%90%e5%8a%9f%e5%85%a5%e9%99%a2%e4%ba%86%e3%80%82%e5%90%8e%e6%9d%a5%e8%bf%99%e4%b8%a4%e5%b9%b4%e5%af%b9Runtime%e7%9a%84%e7%90%86%e8%a7%a3%e6%85%a2%e6%85%a2%e5%a2%9e%e5%8a%a0%e4%ba%86%ef%bc%8c%e6%89%93%e7%ae%97%e4%bb%8a%e5%a4%a9%e8%87%aa%e5%b7%b1%e6%80%bb%e7%bb%93%e6%80%bb%e7%bb%93%e5%b9%b3%e6%97%b6%e4%b8%80%e7%9b%b4%e8%ba%ba%e5%9c%a8%e6%88%91%e5%8d%b0%e8%b1%a1%e7%ac%94%e8%ae%b0%e9%87%8c%e9%9d%a2%e7%9a%84%e7%ac%94%e8%ae%b0%e3%80%82%e6%9c%89%e4%ba%9b%e4%ba%ba%e5%8f%af%e8%83%bd%e6%9c%89%e7%96%91%e6%83%91%ef%bc%8c%e5%ad%a6%e4%b9%a0Runtime%e5%88%b0%e5%ba%95%e6%9c%89%e5%95%a5%e7%94%a8%ef%bc%8c%e5%b9%b3%e6%97%b6%e5%a5%bd%e5%83%8f%e5%b9%b6%e4%b8%8d%e4%bc%9a%e7%94%a8%e5%88%b0%e3%80%82%e5%b8%8c%e6%9c%9b%e7%9c%8b%e5%ae%8c%e6%88%91%e8%bf%99%e6%ac%a1%e7%9a%84%e6%80%bb%e7%bb%93%ef%bc%8c%e5%bf%83%e4%b8%ad%e8%83%bd%e8%a7%a3%e5%bc%80%e4%b8%80%e4%ba%9b%e7%96%91%e6%83%91%e3%80%82%0a%23%23%23%23%e7%9b%ae%e5%bd%95%0a%201.Runtime%e7%ae%80%e4%bb%8b%202.NSObject%e8%b5%b7%e6%ba%90%20%20%281%29%20isa_t%e7%bb%93%e6%9e%84%e4%bd%93%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%20%282%29%20cache_t%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%20%283%29%20class_data_bits_t%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%20%20%203.%e5%85%a5%e9%99%a2%e8%80%83%e8%af%95%20%20%e4%b8%80.%20Runtime%e7%ae%80%e4%bb%8b%20Runtime%20%e5%8f%88%e5%8f%ab%e8%bf%90%e8%a1%8c%e6%97%b6%ef%bc%8c%e6%98%af%e4%b8%80%e5%a5%97%e5%ba%95%e5%b1%82%e7%9a%84%20C%20%e8%af%ad%e8%a8%80%20API%ef%bc%8c%e6%98%af%20iOS%20%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%a0%b8%e5%bf%83%e4%b9%8b%e4%b8%80%e3%80%82%e5%bc%80%e5%8f%91%e8%80%85%e5%9c%a8%e7%bc%96%e7%a0%81%e8%bf%87%e7%a8%8b%e4%b8%ad%ef%bc%8c%e5%8f%af%e4%bb%a5%e7%bb%99%e4%bb%bb%e6%84%8f%e4%b8%80%e4%b8%aa%e5%af%b9%e8%b1%a1%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af%ef%bc%8c%e5%9c%a8%e7%bc%96%e8%af%91%e9%98%b6%e6%ae%b5%e5%8f%aa%e6%98%af%e7%a1%ae%e5%ae%9a%e4%ba%86%e8%a6%81%e5%90%91%e6%8e%a5%e6%94%b6%e8%80%85%e5%8f%91%e9%80%81%e8%bf%99%e6%9d%a1%e6%b6%88%e6%81%af%ef%bc%8c%e8%80%8c%e6%8e%a5%e5%8f%97%e8%80%85%e5%b0%86%e8%a6%81%e5%a6%82%e4%bd%95%e5%93%8d%e5%ba%94%e5%92%8c%e5%a4%84%e7%90%86%e8%bf%99%e6%9d%a1%e6%b6%88%e6%81%af%ef%bc%8c%e9%82%a3%e5%b0%b1%e8%a6%81%e7%9c%8b%e8%bf%90%e8%a1%8c%e6%97%b6%e6%9d%a5%e5%86%b3%e5%ae%9a%e4%ba%86%e3%80%82%0aC%e8%af%ad%e8%a8%80%e4%b8%ad%ef%bc%8c%e5%9c%a8%e7%bc%96%e8%af%91%e6%9c%9f%ef%bc%8c%e5%87%bd%e6%95%b0%e7%9a%84%e8%b0%83%e7%94%a8%e5%b0%b1%e4%bc%9a%e5%86%b3%e5%ae%9a%e8%b0%83%e7%94%a8%e5%93%aa%e4%b8%aa%e5%87%bd%e6%95%b0%e3%80%82%20%e8%80%8cOC%e7%9a%84%e5%87%bd%e6%95%b0%ef%bc%8c%e5%b1%9e%e4%ba%8e%e5%8a%a8%e6%80%81%e8%b0%83%e7%94%a8%e8%bf%87%e7%a8%8b%ef%bc%8c%e5%9c%a8%e7%bc%96%e8%af%91%e6%9c%9f%e5%b9%b6%e4%b8%8d%e8%83%bd%e5%86%b3%e5%ae%9a%e7%9c%9f%e6%ad%a3%e8%b0%83%e7%94%a8%e5%93%aa%e4%b8%aa%e5%87%bd%e6%95%b0%ef%bc%8c%e5%8f%aa%e6%9c%89%e5%9c%a8%e7%9c%9f%e6%ad%a3%e8%bf%90%e8%a1%8c%e6%97%b6%e6%89%8d%e4%bc%9a%e6%a0%b9%e6%8d%ae%e5%87%bd%e6%95%b0%e7%9a%84%e5%90%8d%e7%a7%b0%e6%89%be%e5%88%b0%e5%af%b9%e5%ba%94%e7%9a%84%e5%87%bd%e6%95%b0%e6%9d%a5%e8%b0%83%e7%94%a8%e3%80%82%0aObjective-C%20%e6%98%af%e4%b8%80%e4%b8%aa%e5%8a%a8%e6%80%81%e8%af%ad%e8%a8%80%ef%bc%8c%e8%bf%99%e6%84%8f%e5%91%b3%e7%9d%80%e5%ae%83%e4%b8%8d%e4%bb%85%e9%9c%80%e8%a6%81%e4%b8%80%e4%b8%aa%e7%bc%96%e8%af%91%e5%99%a8%ef%bc%8c%e4%b9%9f%e9%9c%80%e8%a6%81%e4%b8%80%e4%b8%aa%e8%bf%90%e8%a1%8c%e6%97%b6%e7%b3%bb%e7%bb%9f%e6%9d%a5%e5%8a%a8%e6%80%81%e5%be%97%e5%88%9b%e5%bb%ba%e7%b1%bb%e5%92%8c%e5%af%b9%e8%b1%a1%e3%80%81%e8%bf%9b%e8%a1%8c%e6%b6%88%e6%81%af%e4%bc%a0%e9%80%92%e5%92%8c%e8%bd%ac%e5%8f%91%e3%80%82%0aObjc%20%e5%9c%a8%e4%b8%89%e7%a7%8d%e5%b1%82%e9%9d%a2%e4%b8%8a%e4%b8%8e%20Runtime%20%e7%b3%bb%e7%bb%9f%e8%bf%9b%e8%a1%8c%e4%ba%a4%e4%ba%92%ef%bc%9a%0a1.%20%e9%80%9a%e8%bf%87%20Objective-C%20%e6%ba%90%e4%bb%a3%e7%a0%81%20%e4%b8%80%e8%88%ac%e6%83%85%e5%86%b5%e5%bc%80%e5%8f%91%e8%80%85%e5%8f%aa%e9%9c%80%e8%a6%81%e7%bc%96%e5%86%99%20OC%20%e4%bb%a3%e7%a0%81%e5%8d%b3%e5%8f%af%ef%bc%8cRuntime%20%e7%b3%bb%e7%bb%9f%e8%87%aa%e5%8a%a8%e5%9c%a8%e5%b9%95%e5%90%8e%e6%8a%8a%e6%88%91%e4%bb%ac%e5%86%99%e7%9a%84%e6%ba%90%e4%bb%a3%e7%a0%81%e5%9c%a8%e7%bc%96%e8%af%91%e9%98%b6%e6%ae%b5%e8%bd%ac%e6%8d%a2%e6%88%90%e8%bf%90%e8%a1%8c%e6%97%b6%e4%bb%a3%e7%a0%81%ef%bc%8c%e5%9c%a8%e8%bf%90%e8%a1%8c%e6%97%b6%e7%a1%ae%e5%ae%9a%e5%af%b9%e5%ba%94%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%92%8c%e8%b0%83%e7%94%a8%e5%85%b7%e4%bd%93%e5%93%aa%e4%b8%aa%e6%96%b9%e6%b3%95%e3%80%82%0a2.%20%e9%80%9a%e8%bf%87%20Foundation%20%e6%a1%86%e6%9e%b6%e7%9a%84%20NSObject%20%e7%b1%bb%e5%ae%9a%e4%b9%89%e7%9a%84%e6%96%b9%e6%b3%95%20%e5%9c%a8OC%e7%9a%84%e4%b8%96%e7%95%8c%e4%b8%ad%ef%bc%8c%e9%99%a4%e4%ba%86NSProxy%e7%b1%bb%e4%bb%a5%e5%a4%96%ef%bc%8c%e6%89%80%e6%9c%89%e7%9a%84%e7%b1%bb%e9%83%bd%e6%98%afNSObject%e7%9a%84%e5%ad%90%e7%b1%bb%e3%80%82%e5%9c%a8Foundation%e6%a1%86%e6%9e%b6%e4%b8%8b%ef%bc%8cNSObject%e5%92%8cNSProxy%e4%b8%a4%e4%b8%aa%e5%9f%ba%e7%b1%bb%ef%bc%8c%e5%ae%9a%e4%b9%89%e4%ba%86%e7%b1%bb%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e4%b8%ad%e8%af%a5%e7%b1%bb%e4%b8%8b%e6%96%b9%e6%89%80%e6%9c%89%e7%b1%bb%e7%9a%84%e5%85%ac%e5%85%b1%e6%8e%a5%e5%8f%a3%e5%92%8c%e8%a1%8c%e4%b8%ba%e3%80%82NSProxy%e6%98%af%e4%b8%93%e9%97%a8%e7%94%a8%e4%ba%8e%e5%ae%9e%e7%8e%b0%e4%bb%a3%e7%90%86%e5%af%b9%e8%b1%a1%e7%9a%84%e7%b1%bb%ef%bc%8c%e8%bf%99%e4%b8%aa%e7%b1%bb%e6%9a%82%e6%97%b6%e6%9c%ac%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%8d%e6%8f%90%e3%80%82%e8%bf%99%e4%b8%a4%e4%b8%aa%e7%b1%bb%e9%83%bd%e9%81%b5%e5%be%aa%e4%ba%86NSObject%e5%8d%8f%e8%ae%ae%e3%80%82%e5%9c%a8NSObject%e5%8d%8f%e8%ae%ae%e4%b8%ad%ef%bc%8c%e5%a3%b0%e6%98%8e%e4%ba%86%e6%89%80%e6%9c%89OC%e5%af%b9%e8%b1%a1%e7%9a%84%e5%85%ac%e5%85%b1%e6%96%b9%e6%b3%95%e3%80%82%0a%e5%9c%a8NSObject%e5%8d%8f%e8%ae%ae%e4%b8%ad%ef%bc%8c%e6%9c%89%e4%bb%a5%e4%b8%8b5%e4%b8%aa%e6%96%b9%e6%b3%95%ef%bc%8c%e6%98%af%e5%8f%af%e4%bb%a5%e4%bb%8eRuntime%e4%b8%ad%e8%8e%b7%e5%8f%96%e4%bf%a1%e6%81%af%ef%bc%8c%e8%ae%a9%e5%af%b9%e8%b1%a1%e8%bf%9b%e8%a1%8c%e8%87%aa%e6%88%91%e6%a3%80%e6%9f%a5%e3%80%82%0a-%20%28Class%29class%20OBJC_SWIFT_UNAVAILABLE%28%26%2334%3buse%20%26%2339%3banObject.dynamicType%26%2339%3b%20instead%26%2334%3b%29%3b%20-%20%28BOOL%29isKindOfClass%3a%28Class%29aClass%3b%20-%20%28BOOL%29isMemberOfClass%3a%28Class%29aClass%3b%20-%20%28BOOL%29conformsToProtocol%3a%28Protocol%20%2a%29aProtocol%3b%20-%20%28BOOL%29respondsToSelector%3a%28SEL%29aSelector%3b%20-class%e6%96%b9%e6%b3%95%e8%bf%94%e5%9b%9e%e5%af%b9%e8%b1%a1%e7%9a%84%e7%b1%bb%ef%bc%9b%20-isKindOfClass%3a%20%e5%92%8c%20-isMemberOfClass%3a%20%e6%96%b9%e6%b3%95%e6%a3%80%e6%9f%a5%e5%af%b9%e8%b1%a1%e6%98%af%e5%90%a6%e5%ad%98%e5%9c%a8%e4%ba%8e%e6%8c%87%e5%ae%9a%e7%9a%84%e7%b1%bb%e7%9a%84%e7%bb%a7%e6%89%bf%e4%bd%93%e7%b3%bb%e4%b8%ad%ef%bc%9b%20-respondsToSelector%3a%20%e6%a3%80%e6%9f%a5%e5%af%b9%e8%b1%a1%e8%83%bd%e5%90%a6%e5%93%8d%e5%ba%94%e6%8c%87%e5%ae%9a%e7%9a%84%e6%b6%88%e6%81%af%ef%bc%9b%20-conformsToProtocol%3a%e6%a3%80%e6%9f%a5%e5%af%b9%e8%b1%a1%e6%98%af%e5%90%a6%e5%ae%9e%e7%8e%b0%e4%ba%86%e6%8c%87%e5%ae%9a%e5%8d%8f%e8%ae%ae%e7%b1%bb%e7%9a%84%e6%96%b9%e6%b3%95%ef%bc%9b"><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fobjc_runtime_isa_class%2f&t=%e7%a5%9e%e7%bb%8f%e7%97%85%e9%99%a2%20Objective-C%20Runtime%20%e5%85%a5%e9%99%a2%e7%ac%ac%e4%b8%80%e5%a4%a9%e2%80%94%e2%80%94%20isa%20%e5%92%8c%20Class"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu class=icon href=# onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden=true></i>Menu</a>
<a id=toc class=icon href=# onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden=true></i>TOC</a>
<a id=share class=icon href=# onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden=true></i>share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i>Top</a></div></div></div><footer id=footer><div class=footer-left><p class=copyright style=float:left;margin-bottom:0><a href=https://github.com/halfrost/Halfrost-Field class=github-repo style=height:18px><span class=gadget-github></span>Star</a>
Copyright &copy;halfrost 2016 - 2021
<a href=http://www.miit.gov.cn/>鄂ICP备16014744号</a></p><br><p class="copyright statistics" style=margin-bottom:20px><span id=busuanzi_container_site_pv>Cumulative Page Views <span id=busuanzi_value_site_pv></span>| Unique Visitors <span id=busuanzi_value_site_uv></span></span></p></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/main.min.f870a4d110314b9e50e65f8ac982dc1c9c376c8f1a5083d39c62cfc49073f011.js></script><script async src=/prism.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>
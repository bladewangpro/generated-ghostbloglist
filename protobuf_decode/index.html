<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=theme-color content="#FFFFFF"><meta http-equiv=x-ua-compatible content="IE=edge"><title>高效的序列化/反序列化数据方式 Protobuf | prometheus</title><meta name=description content="Explore in every moment of the hard thinking"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="高效的序列化/反序列化数据方式 Protobuf"><meta property="og:description" content="一. protocol buffers 序列化 上篇文章中其实已经讲过了 encode 的过程，这篇文章以 golang 为例，从代码实现的层面讲讲序列化和反序列化的过程。
举个 go 使用 protobuf 进行数据序列化和反序列化的例子，本篇文章从这个例子开始。
先新建一个 example 的 message：
syntax = &#34;proto2&#34;;	package example;	enum FOO { X = 17; };	message Test {	required string label = 1;	optional int32 type = 2 [default=77];	repeated int64 reps = 3;	optional group OptionalGroup = 4 {	required string RequiredField = 5;	}	}利用 protoc-gen-go 生成对应的 get/ set 方法。代码中就可以用生成的代码进行序列化和反序列化了。
package main import ( &#34;log&#34; &#34;github."><meta property="og:type" content="article"><meta property="og:url" content="https://new.halfrost.com/protobuf_decode/"><meta property="article:published_time" content="2018-05-27T16:44:00+00:00"><meta property="article:modified_time" content="2018-05-27T16:44:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="高效的序列化/反序列化数据方式 Protobuf"><meta name=twitter:description content="一. protocol buffers 序列化 上篇文章中其实已经讲过了 encode 的过程，这篇文章以 golang 为例，从代码实现的层面讲讲序列化和反序列化的过程。
举个 go 使用 protobuf 进行数据序列化和反序列化的例子，本篇文章从这个例子开始。
先新建一个 example 的 message：
syntax = &#34;proto2&#34;;	package example;	enum FOO { X = 17; };	message Test {	required string label = 1;	optional int32 type = 2 [default=77];	repeated int64 reps = 3;	optional group OptionalGroup = 4 {	required string RequiredField = 5;	}	}利用 protoc-gen-go 生成对应的 get/ set 方法。代码中就可以用生成的代码进行序列化和反序列化了。
package main import ( &#34;log&#34; &#34;github."><link rel=stylesheet href=/css/style-white.min.css><link rel=manifest href=/manifest.json><link rel=stylesheet href=/prism.css><link href=/images/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=/images/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=/images/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=/images/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=/images/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=/images/apple-touch-icon-512x512.png rel=apple-touch-icon sizes=512x512><link href=/images/apple-touch-icon-1024x1024.png rel=apple-touch-icon sizes=1024x1024><script async>if('serviceWorker'in navigator){navigator.serviceWorker.register("\/serviceworker-v1.min.a64912b78d282eab1ad3715a0943da21616e5f326f8afea27034784ad445043b.js").then(function(){if(navigator.serviceWorker.controller){console.log('Assets cached by the controlling service worker.');}else{console.log('Please reload this page to allow the service worker to handle network operations.');}}).catch(function(error){console.log('ERROR: '+error);});}else{console.log('Service workers are not supported in the current browser.');}</script><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://new.halfrost.com/images/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-82753806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="single-max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a><a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a><a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast');" style=display:none><i class="fas fa-chevron-up fa-lg"></i></a><span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://new.halfrost.com/protobuf_encode/><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li><li><a class=icon href=https://new.halfrost.com/flatbuffers_schema/><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li><li><a class=icon href=#><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f"><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&text=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&title=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&is_video=false&description=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f"><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&title=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&title=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&title=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-stumbleupon" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&title=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-digg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&name=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf&description=%e4%b8%80.%20protocol%20buffers%20%e5%ba%8f%e5%88%97%e5%8c%96%20%e4%b8%8a%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%ad%e5%85%b6%e5%ae%9e%e5%b7%b2%e7%bb%8f%e8%ae%b2%e8%bf%87%e4%ba%86%20encode%20%e7%9a%84%e8%bf%87%e7%a8%8b%ef%bc%8c%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%bb%a5%20golang%20%e4%b8%ba%e4%be%8b%ef%bc%8c%e4%bb%8e%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0%e7%9a%84%e5%b1%82%e9%9d%a2%e8%ae%b2%e8%ae%b2%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e7%9a%84%e8%bf%87%e7%a8%8b%e3%80%82%0a%e4%b8%be%e4%b8%aa%20go%20%e4%bd%bf%e7%94%a8%20protobuf%20%e8%bf%9b%e8%a1%8c%e6%95%b0%e6%8d%ae%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e7%9a%84%e4%be%8b%e5%ad%90%ef%bc%8c%e6%9c%ac%e7%af%87%e6%96%87%e7%ab%a0%e4%bb%8e%e8%bf%99%e4%b8%aa%e4%be%8b%e5%ad%90%e5%bc%80%e5%a7%8b%e3%80%82%0a%e5%85%88%e6%96%b0%e5%bb%ba%e4%b8%80%e4%b8%aa%20example%20%e7%9a%84%20message%ef%bc%9a%0asyntax%20%3d%20%26%2334%3bproto2%26%2334%3b%3b%09package%20example%3b%09enum%20FOO%20%7b%20X%20%3d%2017%3b%20%7d%3b%09message%20Test%20%7b%09required%20string%20label%20%3d%201%3b%09optional%20int32%20type%20%3d%202%20%5bdefault%3d77%5d%3b%09repeated%20int64%20reps%20%3d%203%3b%09optional%20group%20OptionalGroup%20%3d%204%20%7b%09required%20string%20RequiredField%20%3d%205%3b%09%7d%09%7d%e5%88%a9%e7%94%a8%20protoc-gen-go%20%e7%94%9f%e6%88%90%e5%af%b9%e5%ba%94%e7%9a%84%20get%2f%20set%20%e6%96%b9%e6%b3%95%e3%80%82%e4%bb%a3%e7%a0%81%e4%b8%ad%e5%b0%b1%e5%8f%af%e4%bb%a5%e7%94%a8%e7%94%9f%e6%88%90%e7%9a%84%e4%bb%a3%e7%a0%81%e8%bf%9b%e8%a1%8c%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e4%ba%86%e3%80%82%0apackage%20main%20import%20%28%20%26%2334%3blog%26%2334%3b%20%26%2334%3bgithub."><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&t=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div><div id=toc><nav id=TableOfContents><ul><li><a href=#一-protocol-buffers-序列化>一. protocol buffers 序列化</a><ul><li><a href=#1-int32>1. Int32</a></li><li><a href=#2-string>2. String</a></li><li><a href=#3-map>3. Map</a></li><li><a href=#4-slice>4. slice</a></li><li><a href=#序列化小结>序列化小结：</a></li></ul></li><li><a href=#二-protocol-buffers-反序列化>二. protocol buffers 反序列化</a><ul><li><a href=#1-int32-1>1. Int32</a></li><li><a href=#2-string-1>2. String</a></li><li><a href=#3-map-1>3. Map</a></li><li><a href=#4-slice-1>4. slice</a></li><li><a href=#反序列化小结>反序列化小结：</a></li></ul></li><li><a href=#三-序列化--反序列化性能>三. 序列化 / 反序列化性能</a></li><li><a href=#三-最后>三. 最后</a></li></ul></nav></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">高效的序列化/反序列化数据方式 Protobuf</h1><div class=meta><div class=postdate><time datetime="2018-05-27 16:44:00 +0000 UTC" itemprop=datePublished>May 27</time></div><div class=article-category><i class="fas fa-archive"></i><a class=category-link href=/categories/protocol-buffers>Protocol buffers</a>
,
<a class=category-link href=/categories/protocol>Protocol</a></div><div class=article-tag><i class="fas fa-tag"></i><a class=tag-link href=/tags/protocol-buffers rel=tag>Protocol buffers</a>
,
<a class=tag-link href=/tags/protocol rel=tag>Protocol</a></div></div></header><div class=content itemprop=articleBody><h2 id=一-protocol-buffers-序列化>一. protocol buffers 序列化</h2><p>上篇文章中其实已经讲过了 encode 的过程，这篇文章以 golang 为例，从代码实现的层面讲讲序列化和反序列化的过程。</p><p>举个 go 使用 protobuf 进行数据序列化和反序列化的例子，本篇文章从这个例子开始。</p><p>先新建一个 example 的 message：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto>	syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto2&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>	<span style=color:#f92672>package</span> example;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>	<span style=color:#66d9ef>enum</span> FOO { X <span style=color:#f92672>=</span> <span style=color:#ae81ff>17</span>; };<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>	<span style=color:#66d9ef>message</span> <span style=color:#a6e22e>Test</span> {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>	  <span style=color:#66d9ef>required</span> <span style=color:#66d9ef>string</span> label <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>	  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>int32</span> type <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> [<span style=color:#66d9ef>default</span><span style=color:#f92672>=</span><span style=color:#ae81ff>77</span>];<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>	  <span style=color:#66d9ef>repeated</span> <span style=color:#66d9ef>int64</span> reps <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>	  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>group</span> OptionalGroup <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span> {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>	    <span style=color:#66d9ef>required</span> <span style=color:#66d9ef>string</span> RequiredField <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>	  }<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>	}<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>利用 protoc-gen-go 生成对应的 get/ set 方法。代码中就可以用生成的代码进行序列化和反序列化了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

	<span style=color:#f92672>import</span> (
		<span style=color:#e6db74>&#34;log&#34;</span>

		<span style=color:#e6db74>&#34;github.com/golang/protobuf/proto&#34;</span>
		<span style=color:#e6db74>&#34;path/to/example&#34;</span>
	)

	<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
		<span style=color:#a6e22e>test</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>Test</span> {
			<span style=color:#a6e22e>Label</span>: <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;hello&#34;</span>),
			<span style=color:#a6e22e>Type</span>:  <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Int32</span>(<span style=color:#ae81ff>17</span>),
			<span style=color:#a6e22e>Reps</span>:  []<span style=color:#66d9ef>int64</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>},
			<span style=color:#a6e22e>Optionalgroup</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>Test_OptionalGroup</span> {
				<span style=color:#a6e22e>RequiredField</span>: <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;good bye&#34;</span>),
			},
		}
		<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>test</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;marshaling error: &#34;</span>, <span style=color:#a6e22e>err</span>)
		}
		<span style=color:#a6e22e>newTest</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>Test</span>{}
		<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>newTest</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;unmarshaling error: &#34;</span>, <span style=color:#a6e22e>err</span>)
		}
		<span style=color:#75715e>// Now test and newTest contain the same data.
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>test</span>.<span style=color:#a6e22e>GetLabel</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>newTest</span>.<span style=color:#a6e22e>GetLabel</span>() {
			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;data mismatch %q != %q&#34;</span>, <span style=color:#a6e22e>test</span>.<span style=color:#a6e22e>GetLabel</span>(), <span style=color:#a6e22e>newTest</span>.<span style=color:#a6e22e>GetLabel</span>())
		}
		<span style=color:#75715e>// etc.
</span><span style=color:#75715e></span>	}
</code></pre></div><p>上面代码中 proto.Marshal() 是序列化过程。proto.Unmarshal() 是反序列化过程。这一章节先看看序列化过程的实现，下一章节再分析反序列化过程的实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Marshal takes the protocol buffer
</span><span style=color:#75715e>// and encodes it into the wire format, returning the data.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>pb</span> <span style=color:#a6e22e>Message</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#75715e>// Can the object marshal itself?
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pb</span>.(<span style=color:#a6e22e>Marshaler</span>); <span style=color:#a6e22e>ok</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Marshal</span>()
	}
	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewBuffer</span>(<span style=color:#66d9ef>nil</span>)
	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>pb</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#75715e>// Return a non-nil slice on success.
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> []<span style=color:#66d9ef>byte</span>{}, <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>err</span>
}
</code></pre></div><p>序列化函数一进来，会先调用 message 对象自身的实现的序列化方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Marshaler is the interface representing objects that can marshal themselves.
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Marshaler</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Marshal</span>() ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>)
}
</code></pre></div><p>Marshaler 是一个 interface ，这个接口是专门留给对象自定义序列化的。如果有实现，就 return 自己实现的方法。如果没有，接下来就进行默认序列化方式。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewBuffer</span>(<span style=color:#66d9ef>nil</span>)
	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>pb</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#75715e>// Return a non-nil slice on success.
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> []<span style=color:#66d9ef>byte</span>{}, <span style=color:#66d9ef>nil</span>
	}
</code></pre></div><p>新建一个 Buffer，调用 Buffer 的 Marshal() 方法。message 经过序列化以后，数据流会放到 Buffer 的 buf 字节流中。序列化最终返回 buf 字节流即可。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Buffer</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>buf</span>   []<span style=color:#66d9ef>byte</span> <span style=color:#75715e>// encode/decode byte stream
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>index</span> <span style=color:#66d9ef>int</span>    <span style=color:#75715e>// read point
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// pools of basic types to amortize allocation.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>bools</span>   []<span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>uint32s</span> []<span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>uint64s</span> []<span style=color:#66d9ef>uint64</span>

	<span style=color:#75715e>// extra pools, only used with pointer_reflect.go
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>int32s</span>   []<span style=color:#66d9ef>int32</span>
	<span style=color:#a6e22e>int64s</span>   []<span style=color:#66d9ef>int64</span>
	<span style=color:#a6e22e>float32s</span> []<span style=color:#66d9ef>float32</span>
	<span style=color:#a6e22e>float64s</span> []<span style=color:#66d9ef>float64</span>
}
</code></pre></div><p>Buffer 的数据结构如上，Buffer 是用于序列化和反序列化 protocol buffers 的缓冲区管理器。它可以在调用的时候重用以减少内存使用量。内部维护了 7 个 pool，3 个基础数据类型的 pool，4 个只能被 pointer_reflect 使用的 pool。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>pb</span> <span style=color:#a6e22e>Message</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#75715e>// Can the object marshal itself?
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pb</span>.(<span style=color:#a6e22e>Marshaler</span>); <span style=color:#a6e22e>ok</span> {
		<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Marshal</span>()
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>data</span><span style=color:#f92672>...</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}

	<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getbase</span>(<span style=color:#a6e22e>pb</span>)
	<span style=color:#75715e>// 异常处理
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>structPointer_IsNil</span>(<span style=color:#a6e22e>base</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrNil</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc_struct</span>(<span style=color:#a6e22e>GetProperties</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Elem</span>()), <span style=color:#a6e22e>base</span>)
	}

	<span style=color:#75715e>// 用来统计 Encode 次数的
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>collectStats</span> {
		(<span style=color:#a6e22e>stats</span>).<span style=color:#a6e22e>Encode</span><span style=color:#f92672>++</span> <span style=color:#75715e>// Parens are to work around a goimports bug.
</span><span style=color:#75715e></span>	}
	<span style=color:#75715e>// maxMarshalSize = 1&lt;&lt;31 - 1，这个值是 protobuf 可以 encoded 的最大值。
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>) &gt; <span style=color:#a6e22e>maxMarshalSize</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrTooLarge</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}
</code></pre></div><p>Buffer 的 Marshal() 方法依旧先调用一下对象是否实现了 Marshal() 接口，如果实现了，还是让它自己序列化，序列化之后的二进制数据流加入到 buf 数据流中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getbase</span>(<span style=color:#a6e22e>pb</span> <span style=color:#a6e22e>Message</span>) (<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>structPointer</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pb</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>ErrNil</span>
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#75715e>// get the reflect type of the pointer to the struct.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>t</span> = <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>pb</span>)
	<span style=color:#75715e>// get the address of the struct.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>pb</span>)
	<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>toStructPointer</span>(<span style=color:#a6e22e>value</span>)
	<span style=color:#66d9ef>return</span>
}
</code></pre></div><p>getbase 方法通过 reflect 方法拿到了 message 的类型和对应 value 的结构体指针。拿到结构体指针先做异常处理。</p><p>所以序列化最核心的代码其实就一句，p.enc_struct(GetProperties(t.Elem()), base)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Encode a struct.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>enc_struct</span>(<span style=color:#a6e22e>prop</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>StructProperties</span>, <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>structPointer</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>state</span> <span style=color:#a6e22e>errorState</span>
	<span style=color:#75715e>// Encode fields in tag order so that decoders may use optimizations
</span><span style=color:#75715e></span>	<span style=color:#75715e>// that depend on the ordering.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// https://developers.google.com/protocol-buffers/docs/encoding#order
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>prop</span>.<span style=color:#a6e22e>order</span> {
		<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>prop</span>.<span style=color:#a6e22e>Prop</span>[<span style=color:#a6e22e>i</span>]
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span>(<span style=color:#a6e22e>o</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>base</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>ErrNil</span> {
					<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Required</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
						<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>err</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>RequiredNotSetError</span>{<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span>}
					}
				} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>errRepeatedHasNil</span> {
					<span style=color:#75715e>// Give more context to nil values in repeated fields.
</span><span style=color:#75715e></span>					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;repeated field &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>OrigName</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; has nil element&#34;</span>)
				} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>shouldContinue</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>p</span>) {
					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
				}
			}
			<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>) &gt; <span style=color:#a6e22e>maxMarshalSize</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrTooLarge</span>
			}
		}
	}

	<span style=color:#75715e>// Do oneof fields.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>prop</span>.<span style=color:#a6e22e>oneofMarshaler</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>structPointer_Interface</span>(<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>prop</span>.<span style=color:#a6e22e>stype</span>).(<span style=color:#a6e22e>Message</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>prop</span>.<span style=color:#a6e22e>oneofMarshaler</span>(<span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>o</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>ErrNil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errOneofHasNil</span>
		} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
	}

	<span style=color:#75715e>// Add unrecognized fields at the end.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>prop</span>.<span style=color:#a6e22e>unrecField</span>.<span style=color:#a6e22e>IsValid</span>() {
		<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>structPointer_Bytes</span>(<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>prop</span>.<span style=color:#a6e22e>unrecField</span>)
		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>)<span style=color:#f92672>+</span>len(<span style=color:#a6e22e>v</span>) &gt; <span style=color:#a6e22e>maxMarshalSize</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrTooLarge</span>
		}
		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>v</span>) &gt; <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>v</span><span style=color:#f92672>...</span>)
		}
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>err</span>
}

</code></pre></div><p>上面代码中可以看到，除去 oneof fields 和 unrecognized fields 是单独最后处理的，其他类型都是调用的 p.enc(o, p, base) 进行序列化的。</p><p>Properties 的数据结构定义如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Properties</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Name</span>     <span style=color:#66d9ef>string</span> <span style=color:#75715e>// name of the field, for error messages
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>OrigName</span> <span style=color:#66d9ef>string</span> <span style=color:#75715e>// original name before protocol compiler (always set)
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>JSONName</span> <span style=color:#66d9ef>string</span> <span style=color:#75715e>// name to use for JSON; determined by protoc
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Wire</span>     <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>WireType</span> <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>Tag</span>      <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>Required</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>Optional</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>Repeated</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>Packed</span>   <span style=color:#66d9ef>bool</span>   <span style=color:#75715e>// relevant for repeated primitives only
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Enum</span>     <span style=color:#66d9ef>string</span> <span style=color:#75715e>// set for enum types only
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>proto3</span>   <span style=color:#66d9ef>bool</span>   <span style=color:#75715e>// whether this is known to be a proto3 field; set for []byte only
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>oneof</span>    <span style=color:#66d9ef>bool</span>   <span style=color:#75715e>// whether this is a oneof field
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>Default</span>     <span style=color:#66d9ef>string</span> <span style=color:#75715e>// default value
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>HasDefault</span>  <span style=color:#66d9ef>bool</span>   <span style=color:#75715e>// whether an explicit default was provided
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>CustomType</span>  <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>StdTime</span>     <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>StdDuration</span> <span style=color:#66d9ef>bool</span>

	<span style=color:#a6e22e>enc</span>           <span style=color:#a6e22e>encoder</span>
	<span style=color:#a6e22e>valEnc</span>        <span style=color:#a6e22e>valueEncoder</span> <span style=color:#75715e>// set for bool and numeric types only
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>field</span>         <span style=color:#a6e22e>field</span>
	<span style=color:#a6e22e>tagcode</span>       []<span style=color:#66d9ef>byte</span> <span style=color:#75715e>// encoding of EncodeVarint((Tag&lt;&lt;3)|WireType)
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>tagbuf</span>        [<span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>byte</span>
	<span style=color:#a6e22e>stype</span>         <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>      <span style=color:#75715e>// set for struct types only
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sstype</span>        <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>      <span style=color:#75715e>// set for slices of structs types only
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ctype</span>         <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>      <span style=color:#75715e>// set for custom types only
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sprop</span>         <span style=color:#f92672>*</span><span style=color:#a6e22e>StructProperties</span> <span style=color:#75715e>// set for struct types only
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>isMarshaler</span>   <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>isUnmarshaler</span> <span style=color:#66d9ef>bool</span>

	<span style=color:#a6e22e>mtype</span>    <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span> <span style=color:#75715e>// set for map types only
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>mkeyprop</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>  <span style=color:#75715e>// set for map types only
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>mvalprop</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>  <span style=color:#75715e>// set for map types only
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>size</span>    <span style=color:#a6e22e>sizer</span>
	<span style=color:#a6e22e>valSize</span> <span style=color:#a6e22e>valueSizer</span> <span style=color:#75715e>// set for bool and numeric types only
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>dec</span>    <span style=color:#a6e22e>decoder</span>
	<span style=color:#a6e22e>valDec</span> <span style=color:#a6e22e>valueDecoder</span> <span style=color:#75715e>// set for bool and numeric types only
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// If this is a packable field, this will be the decoder for the packed version of the field.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>packedDec</span> <span style=color:#a6e22e>decoder</span>
}

</code></pre></div><p>在 Properties 这个结构体中，定义了名为 enc 的 encoder 和名为 dec 的 decoder。</p><p>encoder 和 decoder 函数定义是完全一样的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>encoder</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>, <span style=color:#a6e22e>prop</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>, <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>structPointer</span>) <span style=color:#66d9ef>error</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>decoder</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>, <span style=color:#a6e22e>prop</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>, <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>structPointer</span>) <span style=color:#66d9ef>error</span>

</code></pre></div><p>encoder 和 decoder 函数初始化是在 Properties 中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Initialize the fields for encoding and decoding.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>) <span style=color:#a6e22e>setEncAndDec</span>(<span style=color:#a6e22e>typ</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>f</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>StructField</span>, <span style=color:#a6e22e>lockGetProp</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#75715e>// 下面代码有删减，类似的部分省略了
</span><span style=color:#75715e></span>	<span style=color:#75715e>// proto3 scalar types
</span><span style=color:#75715e></span>	
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int32</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>proto3</span> {
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>enc_proto3_int32</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>dec</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>dec_proto3_int32</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>size_proto3_int32</span>
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>enc_ref_int32</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>dec</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>dec_proto3_int32</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>size_ref_int32</span>
		}
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uint32</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>proto3</span> {
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>enc_proto3_uint32</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>dec</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>dec_proto3_int32</span> <span style=color:#75715e>// can reuse
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>size_proto3_uint32</span>
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>enc_ref_uint32</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>dec</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>dec_proto3_int32</span> <span style=color:#75715e>// can reuse
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>size_ref_uint32</span>
		}
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Float32</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>proto3</span> {
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>enc_proto3_uint32</span> <span style=color:#75715e>// can just treat them as bits
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>dec</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>dec_proto3_int32</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>size_proto3_uint32</span>
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>enc_ref_uint32</span> <span style=color:#75715e>// can just treat them as bits
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>dec</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>dec_proto3_int32</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>size_ref_uint32</span>
		}
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>String</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>proto3</span> {
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>enc_proto3_string</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>dec</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>dec_proto3_string</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>size_proto3_string</span>
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>enc_ref_string</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>dec</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>dec_proto3_string</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>size_ref_string</span>
		}

	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Slice</span>:
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>t2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t1</span>.<span style=color:#a6e22e>Elem</span>(); <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Kind</span>() {
		<span style=color:#66d9ef>default</span>:
			<span style=color:#a6e22e>logNoSliceEnc</span>(<span style=color:#a6e22e>t1</span>, <span style=color:#a6e22e>t2</span>)
			<span style=color:#66d9ef>break</span>

		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int32</span>:
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Packed</span> {
				<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>enc_slice_packed_int32</span>
				<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>size_slice_packed_int32</span>
			} <span style=color:#66d9ef>else</span> {
				<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>enc_slice_int32</span>
				<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>size_slice_int32</span>
			}
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>dec</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>dec_slice_int32</span>
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>packedDec</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>dec_slice_packed_int32</span>
		
			<span style=color:#66d9ef>default</span>:
				<span style=color:#a6e22e>logNoSliceEnc</span>(<span style=color:#a6e22e>t1</span>, <span style=color:#a6e22e>t2</span>)
				<span style=color:#66d9ef>break</span>
			}
		}

	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Map</span>:
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>enc</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>enc_new_map</span>
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>dec</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>).<span style=color:#a6e22e>dec_new_map</span>
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>size</span> = <span style=color:#a6e22e>size_new_map</span>

		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mtype</span> = <span style=color:#a6e22e>t1</span>
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mkeyprop</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Properties</span>{}
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mkeyprop</span>.<span style=color:#a6e22e>init</span>(<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>PtrTo</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mtype</span>.<span style=color:#a6e22e>Key</span>()), <span style=color:#e6db74>&#34;Key&#34;</span>, <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Tag</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;protobuf_key&#34;</span>), <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>lockGetProp</span>)
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mvalprop</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Properties</span>{}
		<span style=color:#a6e22e>vtype</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mtype</span>.<span style=color:#a6e22e>Elem</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>vtype</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Ptr</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>vtype</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Slice</span> {
			<span style=color:#75715e>// The value type is not a message (*T) or bytes ([]byte),
</span><span style=color:#75715e></span>			<span style=color:#75715e>// so we need encoders for the pointer to this type.
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>vtype</span> = <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>PtrTo</span>(<span style=color:#a6e22e>vtype</span>)
		}

		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mvalprop</span>.<span style=color:#a6e22e>CustomType</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>CustomType</span>
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mvalprop</span>.<span style=color:#a6e22e>StdDuration</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>StdDuration</span>
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mvalprop</span>.<span style=color:#a6e22e>StdTime</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>StdTime</span>
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mvalprop</span>.<span style=color:#a6e22e>init</span>(<span style=color:#a6e22e>vtype</span>, <span style=color:#e6db74>&#34;Value&#34;</span>, <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Tag</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;protobuf_val&#34;</span>), <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>lockGetProp</span>)
	}
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>setTag</span>(<span style=color:#a6e22e>lockGetProp</span>)
}

</code></pre></div><p>上面代码中，分别把各个类型都进行 switch - case 枚举，每种情况都设置对应的 encode 编码器，decode 解码器，size 大小。proto2 和 proto3 有区别的地方也分成2种不同的情况进行处理。</p><p>有以下几种类型，reflect.Bool、reflect.Int32、reflect.Uint32、reflect.Int64、reflect.Uint64、reflect.Float32、reflect.Float64、reflect.String、reflect.Struct、reflect.Ptr、reflect.Slice、reflect.Map 共 12 种大的分类。</p><p>下面主要挑 3 类，Int32、String、Map 代码实现进行分析。</p><h3 id=1-int32>1. Int32</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>enc_proto3_int32</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>, <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>structPointer</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>structPointer_Word32Val</span>(<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>field</span>)
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> int32(<span style=color:#a6e22e>word32Val_Get</span>(<span style=color:#a6e22e>v</span>)) <span style=color:#75715e>// permit sign extension to use full 64-bit range
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrNil</span>
	}
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>tagcode</span><span style=color:#f92672>...</span>)
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>valEnc</span>(<span style=color:#a6e22e>o</span>, uint64(<span style=color:#a6e22e>x</span>))
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>处理 Int32 代码比较简单，先把 tagcode 放进 buf 二进制数据流缓冲区，接着序列化 Int32 ，序列化以后紧接着 tagcode 后面放进缓冲区。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// EncodeVarint writes a varint-encoded integer to the Buffer.
</span><span style=color:#75715e>// This is the format for the
</span><span style=color:#75715e>// int32, int64, uint32, uint64, bool, and enum
</span><span style=color:#75715e>// protocol buffer types.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>EncodeVarint</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>uint64</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>7</span> {
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>, uint8(<span style=color:#a6e22e>x</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x7f</span>|<span style=color:#ae81ff>0x80</span>))
		<span style=color:#a6e22e>x</span> <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>7</span>
	}
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>, uint8(<span style=color:#a6e22e>x</span>))
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>Int32 的编码处理方法在<a href=https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/Protocol-buffers-encode.md>上篇</a>里面讲过，用的 Varint 处理方法。上面这个函数同样适用于处理 int32, int64, uint32, uint64, bool, enum。</p><p>顺道也可以看看 sint32、Fixed32 的具体代码实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// EncodeZigzag32 writes a zigzag-encoded 32-bit integer
</span><span style=color:#75715e>// to the Buffer.
</span><span style=color:#75715e>// This is the format used for the sint32 protocol buffer type.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>EncodeZigzag32</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>uint64</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#75715e>// use signed number to get arithmetic right shift.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>EncodeVarint</span>(uint64((uint32(<span style=color:#a6e22e>x</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>) ^ uint32((int32(<span style=color:#a6e22e>x</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>31</span>))))
}
</code></pre></div><p>针对有符号的 sint32 ，采取的是先 Zigzag，然后在 Varint 的处理方式。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// EncodeFixed32 writes a 32-bit integer to the Buffer.
</span><span style=color:#75715e>// This is the format for the
</span><span style=color:#75715e>// fixed32, sfixed32, and float protocol buffer types.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>EncodeFixed32</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>uint64</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>,
		uint8(<span style=color:#a6e22e>x</span>),
		uint8(<span style=color:#a6e22e>x</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>8</span>),
		uint8(<span style=color:#a6e22e>x</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>16</span>),
		uint8(<span style=color:#a6e22e>x</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>24</span>))
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>对于 Fixed32 的处理，仅仅只是位移操作，并没有做什么压缩操作。</p><h3 id=2-string>2. String</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>enc_proto3_string</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>, <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>structPointer</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>structPointer_StringVal</span>(<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>field</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrNil</span>
	}
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>tagcode</span><span style=color:#f92672>...</span>)
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>EncodeStringBytes</span>(<span style=color:#a6e22e>v</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>序列化字符串也分2步，先把 tagcode 放进去，然后再序列化数据。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// EncodeStringBytes writes an encoded string to the Buffer.
</span><span style=color:#75715e>// This is the format used for the proto2 string type.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>EncodeStringBytes</span>(<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>EncodeVarint</span>(uint64(len(<span style=color:#a6e22e>s</span>)))
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>s</span><span style=color:#f92672>...</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>序列化字符串的时候，会先把字符串的长度通过编码 Varint 的方式，写到 buf 中。长度后面再紧跟着 string。这也就是 tag - length - value 的实现。</p><h3 id=3-map>3. Map</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Encode a map field.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>enc_new_map</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>, <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>structPointer</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>state</span> <span style=color:#a6e22e>errorState</span> <span style=color:#75715e>// XXX: or do we need to plumb this through?
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>structPointer_NewAt</span>(<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>field</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mtype</span>).<span style=color:#a6e22e>Elem</span>() <span style=color:#75715e>// map[K]V
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Len</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}

	<span style=color:#a6e22e>keycopy</span>, <span style=color:#a6e22e>valcopy</span>, <span style=color:#a6e22e>keybase</span>, <span style=color:#a6e22e>valbase</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mapEncodeScratch</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mtype</span>)

	<span style=color:#a6e22e>enc</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mkeyprop</span>.<span style=color:#a6e22e>enc</span>(<span style=color:#a6e22e>o</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mkeyprop</span>, <span style=color:#a6e22e>keybase</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mvalprop</span>.<span style=color:#a6e22e>enc</span>(<span style=color:#a6e22e>o</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mvalprop</span>, <span style=color:#a6e22e>valbase</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>ErrNil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}

	<span style=color:#75715e>// Don&#39;t sort map keys. It is not required by the spec, and C++ doesn&#39;t do it.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>MapKeys</span>() {
		<span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>MapIndex</span>(<span style=color:#a6e22e>key</span>)

		<span style=color:#a6e22e>keycopy</span>.<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>key</span>)
		<span style=color:#a6e22e>valcopy</span>.<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>val</span>)

		<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>tagcode</span><span style=color:#f92672>...</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>enc_len_thing</span>(<span style=color:#a6e22e>enc</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>state</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>上述代码也可以序列化字典数组，例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>map</span>&lt;<span style=color:#a6e22e>key_type</span>, <span style=color:#a6e22e>value_type</span>&gt; <span style=color:#a6e22e>map_field</span> = <span style=color:#a6e22e>N</span>;
</code></pre></div><p>转换成对应的 repeated message 形式再进行序列化。</p><pre><code>message MapFieldEntry {
		key_type key = 1;
		value_type value = 2;
}
repeated MapFieldEntry map_field = N;
</code></pre><p>map 序列化是针对每个 k-v ，都先放入 tagcode ，然后再序列化 k-v。这里需要化未知长度的结构体的时候需要调用 enc_len_thing() 方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Encode something, preceded by its encoded length (as a varint).
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>enc_len_thing</span>(<span style=color:#a6e22e>enc</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span>, <span style=color:#a6e22e>state</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>errorState</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>iLen</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>)
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// reserve four bytes for length
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>iMsg</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>)
	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>enc</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>shouldContinue</span>(<span style=color:#a6e22e>err</span>, <span style=color:#66d9ef>nil</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}
	<span style=color:#a6e22e>lMsg</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>) <span style=color:#f92672>-</span> <span style=color:#a6e22e>iMsg</span>
	<span style=color:#a6e22e>lLen</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sizeVarint</span>(uint64(<span style=color:#a6e22e>lMsg</span>))
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lLen</span> <span style=color:#f92672>-</span> (<span style=color:#a6e22e>iMsg</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>iLen</span>); {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>x</span> &gt; <span style=color:#ae81ff>0</span>: <span style=color:#75715e>// actual length is x bytes larger than the space we reserved
</span><span style=color:#75715e></span>		<span style=color:#75715e>// Move msg x bytes right.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>zeroes</span>[:<span style=color:#a6e22e>x</span>]<span style=color:#f92672>...</span>)
		copy(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>iMsg</span><span style=color:#f92672>+</span><span style=color:#a6e22e>x</span>:], <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>iMsg</span>:<span style=color:#a6e22e>iMsg</span><span style=color:#f92672>+</span><span style=color:#a6e22e>lMsg</span>])
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>x</span> &lt; <span style=color:#ae81ff>0</span>: <span style=color:#75715e>// actual length is x bytes smaller than the space we reserved
</span><span style=color:#75715e></span>		<span style=color:#75715e>// Move msg x bytes left.
</span><span style=color:#75715e></span>		copy(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>iMsg</span><span style=color:#f92672>+</span><span style=color:#a6e22e>x</span>:], <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>iMsg</span>:<span style=color:#a6e22e>iMsg</span><span style=color:#f92672>+</span><span style=color:#a6e22e>lMsg</span>])
		<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>[:len(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>x</span>] <span style=color:#75715e>// x is negative
</span><span style=color:#75715e></span>	}
	<span style=color:#75715e>// Encode the length in the reserved space.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>[:<span style=color:#a6e22e>iLen</span>]
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>EncodeVarint</span>(uint64(<span style=color:#a6e22e>lMsg</span>))
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>[:len(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>lMsg</span>]
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>err</span>
}
</code></pre></div><p>enc_len_thing() 方法会先预存 4 个字节的长度空位。序列化以后算出长度。如果长度比 4 个字节还要长，则右移序列化的二进制数据，把长度填到 tagcode 和数据之间。如果长度小于 4 个字节，相应的要左移。</p><h3 id=4-slice>4. slice</h3><p>最后再举一个数组的例子。以 []int32 为例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Encode a slice of int32s ([]int32) in packed format.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>enc_slice_packed_int32</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>, <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>structPointer</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>structPointer_Word32Slice</span>(<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>field</span>)
	<span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Len</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>l</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrNil</span>
	}
	<span style=color:#75715e>// TODO: Reuse a Buffer.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewBuffer</span>(<span style=color:#66d9ef>nil</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>l</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> int32(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Index</span>(<span style=color:#a6e22e>i</span>)) <span style=color:#75715e>// permit sign extension to use full 64-bit range
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>valEnc</span>(<span style=color:#a6e22e>buf</span>, uint64(<span style=color:#a6e22e>x</span>))
	}

	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>tagcode</span><span style=color:#f92672>...</span>)
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>EncodeVarint</span>(uint64(len(<span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>buf</span>)))
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span> = append(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>buf</span><span style=color:#f92672>...</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>序列化这个数组，分3步，先把 tagcode 放进去，然后再序列化整个数组的长度，最后把数组的每个数据都序列化放在后面。最后形成 tag - length - value - value - value 的形式。</p><p>上述就是 Protocol Buffer 序列化的过程。</p><h3 id=序列化小结>序列化小结：</h3><p>Protocol Buffer 序列化采用 Varint、Zigzag 方法，压缩 int 型整数和带符号的整数。对浮点型数字不做压缩(这里可以进一步的压缩，Protocol Buffer 还有提升空间)。编码 <code>.proto</code> 文件，会对 option 和 repeated 字段进行检查，若 optional 或 repeated 字段没有被设置字段值，那么该字段在序列化时的数据中是完全不存在的，即不进行序列化（少编码一个字段）。</p><p>上面这两点做到了压缩数据，序列化工作量减少。</p><p>序列化的过程都是二进制的位移，速度非常快。数据都以 tag - length - value (或者 tag - value)的形式存在二进制数据流中。采用了 TLV 结构存储数据以后，也摆脱了 JSON 中的 {、}、; 、这些分隔符，没有这些分隔符也算是再一次减少了一部分数据。</p><p>这一点做到了序列化速度非常快。</p><h2 id=二-protocol-buffers-反序列化>二. protocol buffers 反序列化</h2><p>反序列化的实现完全是序列化实现的逆过程。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>buf</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>pb</span> <span style=color:#a6e22e>Message</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>pb</span>.<span style=color:#a6e22e>Reset</span>()
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>UnmarshalMerge</span>(<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>pb</span>)
}
</code></pre></div><p>在反序列化开始之前，先重置一下缓冲区。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>Reset</span>() {
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#ae81ff>0</span>:<span style=color:#ae81ff>0</span>] <span style=color:#75715e>// for reading/writing
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span> = <span style=color:#ae81ff>0</span>        <span style=color:#75715e>// for reading
</span><span style=color:#75715e></span>}
</code></pre></div><p>清空 buf 中的所有数据，并且重置 index。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>UnmarshalMerge</span>(<span style=color:#a6e22e>buf</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>pb</span> <span style=color:#a6e22e>Message</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#75715e>// If the object can unmarshal itself, let it.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pb</span>.(<span style=color:#a6e22e>Unmarshaler</span>); <span style=color:#a6e22e>ok</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>buf</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>NewBuffer</span>(<span style=color:#a6e22e>buf</span>).<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>pb</span>)
}
</code></pre></div><p>反序列化数据的开始从上面这个函数开始，如果传进来的 message 的结果和 buf 结果不匹配，最终得到的结果是不可预知的。反序列化之前，同样会先调用一下对应自己身自定义的 Unmarshal() 方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Unmarshaler</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Unmarshal</span>([]<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span>
}
</code></pre></div><p>Unmarshal() 是一个可以自己实现的接口。</p><p>UnmarshalMerge 中会调用 Unmarshal(pb Message) 方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>pb</span> <span style=color:#a6e22e>Message</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#75715e>// If the object can unmarshal itself, let it.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pb</span>.(<span style=color:#a6e22e>Unmarshaler</span>); <span style=color:#a6e22e>ok</span> {
		<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span>:])
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span> = len(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}

	<span style=color:#a6e22e>typ</span>, <span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getbase</span>(<span style=color:#a6e22e>pb</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}

	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>unmarshalType</span>(<span style=color:#a6e22e>typ</span>.<span style=color:#a6e22e>Elem</span>(), <span style=color:#a6e22e>GetProperties</span>(<span style=color:#a6e22e>typ</span>.<span style=color:#a6e22e>Elem</span>()), <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>base</span>)

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>collectStats</span> {
		<span style=color:#a6e22e>stats</span>.<span style=color:#a6e22e>Decode</span><span style=color:#f92672>++</span>
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}
</code></pre></div><p>Unmarshal(pb Message) 这个函数只有一个入参，和 proto.Unmarshal() 方法函数签名不同(前面的函数只有 1 个入参，后面的有 2 个入参)。两者的区别在于，1 个入参的函数实现里面并不会重置 buf 缓冲区，二个入参的会先重置 buf 缓冲区。</p><p>这两个函数最终都会调用 unmarshalType() 方法，这个函数是最终支持反序列化的函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>unmarshalType</span>(<span style=color:#a6e22e>st</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>prop</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>StructProperties</span>, <span style=color:#a6e22e>is_group</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>structPointer</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>state</span> <span style=color:#a6e22e>errorState</span>
	<span style=color:#a6e22e>required</span>, <span style=color:#a6e22e>reqFields</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>prop</span>.<span style=color:#a6e22e>reqCount</span>, uint64(<span style=color:#ae81ff>0</span>)

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>index</span> &lt; len(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>) {
		<span style=color:#a6e22e>oi</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>index</span>
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>u</span> <span style=color:#66d9ef>uint64</span>
		<span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>DecodeVarint</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>break</span>
		}
		<span style=color:#a6e22e>wire</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>u</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x7</span>)
		
		<span style=color:#75715e>// 下面代码有省略
</span><span style=color:#75715e></span>		
		<span style=color:#a6e22e>dec</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>dec</span>
		
		<span style=color:#75715e>// 中间代码有省略
</span><span style=color:#75715e></span>		
		<span style=color:#a6e22e>decErr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>dec</span>(<span style=color:#a6e22e>o</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>base</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>decErr</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>shouldContinue</span>(<span style=color:#a6e22e>decErr</span>, <span style=color:#a6e22e>p</span>) {
			<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>decErr</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Required</span> {
			<span style=color:#75715e>// Successfully decoded a required field.
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tag</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>64</span> {
				<span style=color:#75715e>// use bitmap for fields 1-64 to catch field reuse.
</span><span style=color:#75715e></span>				<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mask</span> <span style=color:#66d9ef>uint64</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> uint64(<span style=color:#a6e22e>tag</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>reqFields</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mask</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
					<span style=color:#75715e>// new required field
</span><span style=color:#75715e></span>					<span style=color:#a6e22e>reqFields</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>mask</span>
					<span style=color:#a6e22e>required</span><span style=color:#f92672>--</span>
				}
			} <span style=color:#66d9ef>else</span> {
				<span style=color:#75715e>// This is imprecise. It can be fooled by a required field
</span><span style=color:#75715e></span>				<span style=color:#75715e>// with a tag &gt; 64 that is encoded twice; that&#39;s very rare.
</span><span style=color:#75715e></span>				<span style=color:#75715e>// A fully correct implementation would require allocating
</span><span style=color:#75715e></span>				<span style=color:#75715e>// a data structure, which we would like to avoid.
</span><span style=color:#75715e></span>				<span style=color:#a6e22e>required</span><span style=color:#f92672>--</span>
			}
		}
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>is_group</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ErrUnexpectedEOF</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>err</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>required</span> &gt; <span style=color:#ae81ff>0</span> {
			<span style=color:#75715e>// Not enough information to determine the exact field. If we use extra
</span><span style=color:#75715e></span>			<span style=color:#75715e>// CPU, we could determine the field only if the missing required field
</span><span style=color:#75715e></span>			<span style=color:#75715e>// has a tag &lt;= 64 and we check reqFields.
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>RequiredNotSetError</span>{<span style=color:#e6db74>&#34;{Unknown}&#34;</span>}
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}
</code></pre></div><p>unmarshalType() 函数比较长，里面处理的情况比较多，有 oneof，WireEndGroup 。真正处理反序列化的函数在 <code>decErr := dec(o, p, base)</code> 这一行。</p><p>dec 函数在 Properties 的 setEncAndDec() 函数中进行了初始化。上面序列化的时候谈到过那个函数了，这里就不再赘述了。dec() 函数针对每个不同类型都有对应的反序列化函数。</p><p>同样的，接下来也举 4 个例子，看看反序列化的实际代码实现。</p><h3 id=1-int32-1>1. Int32</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>dec_proto3_int32</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>, <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>structPointer</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>valDec</span>(<span style=color:#a6e22e>o</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}
	<span style=color:#a6e22e>word32Val_Set</span>(<span style=color:#a6e22e>structPointer_Word32Val</span>(<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>field</span>), uint32(<span style=color:#a6e22e>u</span>))
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>反序列化 Int32 代码比较简单，原理是按照 encode 的逆过程，还原原来的数据。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>DecodeVarint</span>() (<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>uint64</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span>
	<span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> len(<span style=color:#a6e22e>buf</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ErrUnexpectedEOF</span>
	} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>] &lt; <span style=color:#ae81ff>0x80</span> {
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span><span style=color:#f92672>++</span>
		<span style=color:#66d9ef>return</span> uint64(<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>]), <span style=color:#66d9ef>nil</span>
	} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>buf</span>)<span style=color:#f92672>-</span><span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>decodeVarintSlow</span>()
	}

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>uint64</span>
	<span style=color:#75715e>// we already checked the first byte
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>x</span> = uint64(<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>]) <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x80</span>
	<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>

	<span style=color:#a6e22e>b</span> = uint64(<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>])
	<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x80</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
	}
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>

	<span style=color:#a6e22e>b</span> = uint64(<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>])
	<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>14</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x80</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
	}
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>14</span>

	<span style=color:#a6e22e>b</span> = uint64(<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>])
	<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>21</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x80</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
	}
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>21</span>

	<span style=color:#a6e22e>b</span> = uint64(<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>])
	<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>28</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x80</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
	}
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>28</span>

	<span style=color:#a6e22e>b</span> = uint64(<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>])
	<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>35</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x80</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
	}
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>35</span>

	<span style=color:#a6e22e>b</span> = uint64(<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>])
	<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>42</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x80</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
	}
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>42</span>

	<span style=color:#a6e22e>b</span> = uint64(<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>])
	<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>49</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x80</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
	}
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>49</span>

	<span style=color:#a6e22e>b</span> = uint64(<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>])
	<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>56</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x80</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
	}
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>56</span>

	<span style=color:#a6e22e>b</span> = uint64(<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span>])
	<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>63</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x80</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
	}
	<span style=color:#75715e>// x -= 0x80 &lt;&lt; 63 // Always zero.
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>errOverflow</span>

<span style=color:#a6e22e>done</span>:
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span> = <span style=color:#a6e22e>i</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>Int32 序列化之后，第一个字节一定是 0x80，那么除去这个字节以后，后面的每个二进制字节都是数据，剩下的步骤就是通过位移操作把每个数字都加起来。上面这个反序列化的函数同样适用于 int32, int64, uint32, uint64, bool, and enum。</p><p>顺道也可以看看 sint32、Fixed32 的反序列化具体代码实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>DecodeZigzag32</span>() (<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>uint64</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>DecodeVarint</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>x</span> = uint64((uint32(<span style=color:#a6e22e>x</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>) ^ uint32((int32(<span style=color:#a6e22e>x</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>31</span>)<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>31</span>))
	<span style=color:#66d9ef>return</span>
}
</code></pre></div><p>针对有符号的 sint32 ，反序列化的过程就是先反序列 Varint，再反序列化 Zigzag。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>DecodeFixed32</span>() (<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>uint64</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#75715e>// x, err already 0
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>i</span> &gt; len(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>) {
		<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ErrUnexpectedEOF</span>
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span> = <span style=color:#a6e22e>i</span>

	<span style=color:#a6e22e>x</span> = uint64(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>])
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>|=</span> uint64(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>]) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>|=</span> uint64(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>|=</span> uint64(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>24</span>
	<span style=color:#66d9ef>return</span>
}
</code></pre></div><p>Fixed32 反序列化的过程也是通过位移，每个字节的内容都累加，就可以还原出原先的数据。注意这里也要先跳过 tag 的位置。</p><h3 id=2-string-1>2. String</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>DecodeRawBytes</span>(<span style=color:#a6e22e>alloc</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#a6e22e>buf</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>DecodeVarint</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
	}

	<span style=color:#a6e22e>nb</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>n</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nb</span> &lt; <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;proto: bad byte length %d&#34;</span>, <span style=color:#a6e22e>nb</span>)
	}
	<span style=color:#a6e22e>end</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>nb</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>end</span> &lt; <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>end</span> &gt; len(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ErrUnexpectedEOF</span>
	}

	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>alloc</span> {
		<span style=color:#75715e>// todo: check if can get more uses of alloc=false
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span>:<span style=color:#a6e22e>end</span>]
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>nb</span>
		<span style=color:#66d9ef>return</span>
	}

	<span style=color:#a6e22e>buf</span> = make([]<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>nb</span>)
	copy(<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span>:])
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>nb</span>
	<span style=color:#66d9ef>return</span>
}
</code></pre></div><p>反序列化 string 先把 length 序列化出来，通过 DecodeVarint 的方式。拿到 length 以后，剩下的就是直接拷贝的过程。在上篇 encode 中，我们知道字符串是不做处理，直接放到二进制流里面的，所以反序列化直接取出即可。</p><h3 id=3-map-1>3. Map</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>dec_new_map</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>, <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>structPointer</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>raw</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>DecodeRawBytes</span>(<span style=color:#66d9ef>false</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}
	<span style=color:#a6e22e>oi</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>index</span>       <span style=color:#75715e>// index at the end of this map entry
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>-=</span> len(<span style=color:#a6e22e>raw</span>) <span style=color:#75715e>// move buffer back to start of map entry
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>mptr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>structPointer_NewAt</span>(<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>field</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mtype</span>) <span style=color:#75715e>// *map[K]V
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mptr</span>.<span style=color:#a6e22e>Elem</span>().<span style=color:#a6e22e>IsNil</span>() {
		<span style=color:#a6e22e>mptr</span>.<span style=color:#a6e22e>Elem</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>MakeMap</span>(<span style=color:#a6e22e>mptr</span>.<span style=color:#a6e22e>Type</span>().<span style=color:#a6e22e>Elem</span>()))
	}
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mptr</span>.<span style=color:#a6e22e>Elem</span>() <span style=color:#75715e>// map[K]V
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// 这里省略一些代码，主要是为了 key - value 准备的一些可以双重间接寻址的占位符，具体原因可以见序列化代码里面的 enc_new_map 函数
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// Decode.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// This parses a restricted wire format, namely the encoding of a message
</span><span style=color:#75715e></span>	<span style=color:#75715e>// with two fields. See enc_new_map for the format.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>index</span> &lt; <span style=color:#a6e22e>oi</span> {
		<span style=color:#75715e>// tagcode for key and value properties are always a single byte
</span><span style=color:#75715e></span>		<span style=color:#75715e>// because they have tags 1 and 2.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>tagcode</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>index</span>]
		<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>index</span><span style=color:#f92672>++</span>
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>tagcode</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mkeyprop</span>.<span style=color:#a6e22e>tagcode</span>[<span style=color:#ae81ff>0</span>]:
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mkeyprop</span>.<span style=color:#a6e22e>dec</span>(<span style=color:#a6e22e>o</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mkeyprop</span>, <span style=color:#a6e22e>keybase</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
			}
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mvalprop</span>.<span style=color:#a6e22e>tagcode</span>[<span style=color:#ae81ff>0</span>]:
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mvalprop</span>.<span style=color:#a6e22e>dec</span>(<span style=color:#a6e22e>o</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mvalprop</span>, <span style=color:#a6e22e>valbase</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
			}
		<span style=color:#66d9ef>default</span>:
			<span style=color:#75715e>// TODO: Should we silently skip this instead?
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;proto: bad map data tag %d&#34;</span>, <span style=color:#a6e22e>raw</span>[<span style=color:#ae81ff>0</span>])
		}
	}
	<span style=color:#a6e22e>keyelem</span>, <span style=color:#a6e22e>valelem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>keyptr</span>.<span style=color:#a6e22e>Elem</span>(), <span style=color:#a6e22e>valptr</span>.<span style=color:#a6e22e>Elem</span>()
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>keyelem</span>.<span style=color:#a6e22e>IsValid</span>() {
		<span style=color:#a6e22e>keyelem</span> = <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Zero</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mtype</span>.<span style=color:#a6e22e>Key</span>())
	}
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>valelem</span>.<span style=color:#a6e22e>IsValid</span>() {
		<span style=color:#a6e22e>valelem</span> = <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Zero</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mtype</span>.<span style=color:#a6e22e>Elem</span>())
	}

	<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>SetMapIndex</span>(<span style=color:#a6e22e>keyelem</span>, <span style=color:#a6e22e>valelem</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>反序列化 map 需要把每个 tag 取出来，然后紧接着反序列化每个 key - value。最后会判断 keyelem 和 valelem 是否为零值，如果是零值要分别调用 reflect.Zero 处理零值的情况。</p><h3 id=4-slice-1>4. slice</h3><p>最后还是举一个数组的例子。以 []int32 为例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>dec_slice_packed_int32</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Properties</span>, <span style=color:#a6e22e>base</span> <span style=color:#a6e22e>structPointer</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>structPointer_Word32Slice</span>(<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>field</span>)

	<span style=color:#a6e22e>nn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>DecodeVarint</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}
	<span style=color:#a6e22e>nb</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>nn</span>) <span style=color:#75715e>// number of bytes of encoded int32s
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>fin</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>nb</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fin</span> &lt; <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>index</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errOverflow</span>
	}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>index</span> &lt; <span style=color:#a6e22e>fin</span> {
		<span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>valDec</span>(<span style=color:#a6e22e>o</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
		<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Append</span>(uint32(<span style=color:#a6e22e>u</span>))
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>反序列化这个数组，分2步，跳过 tagcode 拿到 length，反序列化 length。在 length 这个长度中依次反序列化各个 value。</p><p>上述就是 Protocol Buffer 反序列化的过程。</p><h3 id=反序列化小结>反序列化小结：</h3><p>Protocol Buffer 反序列化直接读取二进制字节数据流，反序列化就是 encode 的反过程，同样是一些二进制操作。反序列化的时候，通常只需要用到 length。tag 值只是用来标识类型的，Properties 的 setEncAndDec() 方法里面已经把每个类型对应的 decode 解码器初始化好了，所以反序列化的时候，tag 值可以直接跳过，从 length 开始处理。</p><p>XML 的解析过程就复杂一些。XML 需要从文件中读取出字符串，再转换为 XML 文档对象结构模型。之后，再从 XML 文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将 XML 文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗 CPU 的复杂计算。</p><h2 id=三-序列化--反序列化性能>三. 序列化 / 反序列化性能</h2><p>Protocol Buffer 一直被人们认为是高性能的存在。也有很多人做过实现，验证了这一说法。例如这个链接里面的实验 <a href=https://github.com/eishay/jvm-serializers/wiki>jvm-serializers</a>。</p><p>在看数据之前，我们可以先理性的分析一下 Protocol Buffer 和 JSON、XML 这些比有哪些优势：</p><ol><li>Protobuf 采用了 Varint、Zigzag 大幅的压缩了整数类型，也没有 JSON 里面的 {、}、;、这些数据分隔符，有 option 字段标识的，没有数据的时候不会进行反序列化。这几个措施导致 pb 的数据量整体的就比 JSON 少很多。</li><li>Protobuf 采取的是 TLV 的形式，JSON 这些都是字符串的形式。字符串比对应该比基于数字的字段 tag 更耗时。Protobuf 在正文前有一个大小或者长度的标记，而 JSON 必须全文扫描无法跳过不需要的字段。</li></ol><p>下面这张图来自参考链接里面的 《Protobuf有没有比JSON快5倍？用代码来击破pb性能神话》：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/85_1.png alt></p><p>从这个实验来看，确实 Protobuf 在序列化数字这方面性能是非常强悍的。</p><p>序列化 / 反序列化数字确实是 Protobuf 针对 JSON 和 XML 的优势，但是它也存在一些没有优势的地方。比如字符串。字符串在 Protobuf 中基本没有处理，除了前面加了 tag - length 。在序列化 / 反序列化字符串的过程中，字符串拷贝的速度反而决定的真正的速度。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/85_2.png alt></p><p>从上图可以看到 encode 字符串的时候，速度基本和 JSON 相差无几。</p><h2 id=三-最后>三. 最后</h2><p>至此，关于 protocol buffers 的所有，读者应该了然于胸了。</p><p>protocol buffers 诞生之初也并不是为了传输数据存在的，只是为了解决服务器多版本协议兼容的问题。实质其实是发明了一个新的跨语言无歧义的 IDL (Interface description language)。只不过人们后来发现用它来传输数据也不错，才开始用 protocol buffers 。</p><p>想用 protocol buffers 替换 JSON，可能是考虑到：</p><ol><li>protocol buffers 相同数据，传输的数据量比 JSON 小，gzip 或者 7zip 压缩以后，网络传输消耗较少。</li><li>protocol buffers 不是自我描述的，在缺少 <code>.proto</code> 文件以后，有一定的加密性，数据传输过程中都是二进制流，并不是明文。</li><li>protocol buffers 提供了一套工具，自动化生成代码也非常方便。</li><li>protocol buffers 具有向后兼容性，改变了数据结构以后，对老的版本没有影响。</li><li>protocol buffers 原生完美兼容 RPC 调用。</li></ol><p>如果很少用到整型数字，浮点型数字，全部都是字符串数据，那么 JSON 和 protocol buffers 性能不会差太多。纯前端之间交互的话，选择 JSON 或者 protocol buffers 差别不是很大。</p><p>与后端交互过程中，用到 protocol buffers 比较多，笔者认为选择 protocol buffers 除了性能强以外，完美兼容 RPC 调用也是一个重要因素。</p><hr><p>Reference：</p><p><a href=https://developers.google.com/protocol-buffers/docs/overview>google 官方文档</a><br><a href=https://code.google.com/archive/p/thrift-protobuf-compare/wikis/Benchmarking.wiki>thrift-protobuf-compare - Benchmarking.wiki</a><br><a href=https://github.com/eishay/jvm-serializers/wiki>jvm-serializers</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA3NDcyMTQyNQ==&mid=2649257430&idx=1&sn=975b6123d8256221f6bac3b99e52af9a&chksm=8767a428b0102d3e6ab7abdf797c481da570cb29e274aa4ff6ecd931f535166b776e6548941d&scene=0&key=399a205ce674169cbedcc1c459650908e22d6a2b81674195c3b251114acdf821dbde7bb49102c6b47f61b26a7a404d74e0e8440cea3675a7ea8f49eafd8639bfb733183a1bfb4603232d6cb8ecd230e5&ascene=0&uin=NTkxMDk2NjU=&devicetype=iMac+MacBookPro12,1+OSX+OSX+10.12.4+build(16E195)&version=12020510&nettype=WIFI&fontScale=100&pass_ticket=wHPj0w18CV8zHl6HCfd9t9LQfs3I0ZULhUILuOHgL0E=">Protobuf有没有比JSON快5倍？用代码来击破pb性能神话</a></p><blockquote><p>GitHub Repo：<a href=https://github.com/halfrost/Halfrost-Field>Halfrost-Field</a></p><p>Follow: <a href=https://github.com/halfrost>halfrost · GitHub</a></p><p>Source: <a href=https://halfrost.com/protobuf_decode/>https://halfrost.com/protobuf_decode/</a></p></blockquote><img src=https://img.halfrost.com/wechat-qr-code.png></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div id=toc-footer style=display:none><nav id=TableOfContents><ul><li><a href=#一-protocol-buffers-序列化>一. protocol buffers 序列化</a><ul><li><a href=#1-int32>1. Int32</a></li><li><a href=#2-string>2. String</a></li><li><a href=#3-map>3. Map</a></li><li><a href=#4-slice>4. slice</a></li><li><a href=#序列化小结>序列化小结：</a></li></ul></li><li><a href=#二-protocol-buffers-反序列化>二. protocol buffers 反序列化</a><ul><li><a href=#1-int32-1>1. Int32</a></li><li><a href=#2-string-1>2. String</a></li><li><a href=#3-map-1>3. Map</a></li><li><a href=#4-slice-1>4. slice</a></li><li><a href=#反序列化小结>反序列化小结：</a></li></ul></li><li><a href=#三-序列化--反序列化性能>三. 序列化 / 反序列化性能</a></li><li><a href=#三-最后>三. 最后</a></li></ul></nav></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f"><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&text=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&title=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&is_video=false&description=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f"><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&title=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&title=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&title=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-stumbleupon fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&title=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-digg fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&name=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf&description=%e4%b8%80.%20protocol%20buffers%20%e5%ba%8f%e5%88%97%e5%8c%96%20%e4%b8%8a%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%ad%e5%85%b6%e5%ae%9e%e5%b7%b2%e7%bb%8f%e8%ae%b2%e8%bf%87%e4%ba%86%20encode%20%e7%9a%84%e8%bf%87%e7%a8%8b%ef%bc%8c%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%bb%a5%20golang%20%e4%b8%ba%e4%be%8b%ef%bc%8c%e4%bb%8e%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0%e7%9a%84%e5%b1%82%e9%9d%a2%e8%ae%b2%e8%ae%b2%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e7%9a%84%e8%bf%87%e7%a8%8b%e3%80%82%0a%e4%b8%be%e4%b8%aa%20go%20%e4%bd%bf%e7%94%a8%20protobuf%20%e8%bf%9b%e8%a1%8c%e6%95%b0%e6%8d%ae%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e7%9a%84%e4%be%8b%e5%ad%90%ef%bc%8c%e6%9c%ac%e7%af%87%e6%96%87%e7%ab%a0%e4%bb%8e%e8%bf%99%e4%b8%aa%e4%be%8b%e5%ad%90%e5%bc%80%e5%a7%8b%e3%80%82%0a%e5%85%88%e6%96%b0%e5%bb%ba%e4%b8%80%e4%b8%aa%20example%20%e7%9a%84%20message%ef%bc%9a%0asyntax%20%3d%20%26%2334%3bproto2%26%2334%3b%3b%09package%20example%3b%09enum%20FOO%20%7b%20X%20%3d%2017%3b%20%7d%3b%09message%20Test%20%7b%09required%20string%20label%20%3d%201%3b%09optional%20int32%20type%20%3d%202%20%5bdefault%3d77%5d%3b%09repeated%20int64%20reps%20%3d%203%3b%09optional%20group%20OptionalGroup%20%3d%204%20%7b%09required%20string%20RequiredField%20%3d%205%3b%09%7d%09%7d%e5%88%a9%e7%94%a8%20protoc-gen-go%20%e7%94%9f%e6%88%90%e5%af%b9%e5%ba%94%e7%9a%84%20get%2f%20set%20%e6%96%b9%e6%b3%95%e3%80%82%e4%bb%a3%e7%a0%81%e4%b8%ad%e5%b0%b1%e5%8f%af%e4%bb%a5%e7%94%a8%e7%94%9f%e6%88%90%e7%9a%84%e4%bb%a3%e7%a0%81%e8%bf%9b%e8%a1%8c%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e4%ba%86%e3%80%82%0apackage%20main%20import%20%28%20%26%2334%3blog%26%2334%3b%20%26%2334%3bgithub."><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fprotobuf_decode%2f&t=%e9%ab%98%e6%95%88%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%2f%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%95%b0%e6%8d%ae%e6%96%b9%e5%bc%8f%20Protobuf"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu class=icon href=# onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden=true></i>Menu</a>
<a id=toc class=icon href=# onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden=true></i>TOC</a>
<a id=share class=icon href=# onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden=true></i>share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i>Top</a></div></div></div><footer id=footer><div class=footer-left><p class=copyright style=float:left;margin-bottom:0><a href=https://github.com/halfrost/Halfrost-Field class=github-repo style=height:18px><span class=gadget-github></span>Star</a>
Copyright &copy;halfrost 2016 - 2021
<a href=http://www.miit.gov.cn/>鄂ICP备16014744号</a></p><br><p class="copyright statistics" style=margin-bottom:20px><span id=busuanzi_container_site_pv>Cumulative Page Views <span id=busuanzi_value_site_pv></span>| Unique Visitors <span id=busuanzi_value_site_uv></span></span></p></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/main.min.f870a4d110314b9e50e65f8ac982dc1c9c376c8f1a5083d39c62cfc49073f011.js></script><script async src=/prism.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>
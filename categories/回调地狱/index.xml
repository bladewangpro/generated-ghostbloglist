<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>回调地狱 on prometheus</title><link>https://new.halfrost.com/categories/%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1/</link><description>Recent content in 回调地狱 on prometheus</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>halfrost</copyright><lastBuildDate>Wed, 22 Jun 2016 06:45:00 +0000</lastBuildDate><atom:link href="https://new.halfrost.com/categories/%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1/index.xml" rel="self" type="application/rss+xml"/><item><title>iOS 如何优雅的处理“回调地狱 Callback hell ”(二) —— 使用 Swift</title><link>https://new.halfrost.com/ios_callback_hell_swift/</link><pubDate>Wed, 22 Jun 2016 06:45:00 +0000</pubDate><guid>https://new.halfrost.com/ios_callback_hell_swift/</guid><description>####前言 在上篇中，我谈到了可以用promise来解决Callback hell的问题，这篇我们换一种方式一样可以解决这个问题。
我们先分析一下为何promise能解决多层回调嵌套的问题，经过上篇的分析，我总结也一下几点：
1.promise封装了所有异步操作，把异步操作封装成了一个“盒子”。 2.promise提供了Monad，then相当于flatMap。 3.promise的函数返回对象本身，于是就可形成链式调用
好了，既然这些能优雅的解决callback hell，那么我们只要能做到这些，也一样可以完成任务。到这里大家可能就已经恍然大悟了，Swift就是完成这个任务的最佳语言！Swift支持函数式编程，分分钟就可以完成promise的基本功能。
####一.利用Swift特性处理回调Callback hell
我们还是以上篇的例子来举例，先来描述一下场景： 假设有这样一个提交按钮，当你点击之后，就会提交一次任务。当你点下按钮的那一刻，首先要先判断是否有权限提交，没有权限就弹出错误。有权限提交之后，还要请求一次，判断当前任务是否已经存在，如果存在，弹出错误。如果不存在，这个时候就可以安心提交任务了。
那么代码如下：
func requestAsyncOperation(request : String , success : String -&amp;gt; Void , failure : NSError -&amp;gt; Void) { WebRequestAPI.fetchDataAPI(request, success : { result in WebOtherRequestAPI.fetchOtherDataAPI ( result , success : {OtherResult in [self fulfillData:OtherResult]; let finallyTheParams = self.transformResult(OtherResult) TaskAPI.fetchOtherDataAPI ( finallyTheParams , success : { TaskResult in let finallyTaskResult = self.transformTaskResult(TaskResult) success(finallyTaskResult) }, failure:{ TaskError in failure(TaskError) } ) },failure : { ExistError in failure(ExistError) } ) } , failure : { AuthorityError in failure(AuthorityError) } ) } 接下来我们就来优雅的解决上述看上去不好维护的Callback hell。</description></item><item><title>iOS 如何优雅的处理“回调地狱 Callback hell ”(一) —— 使用 PromiseKit</title><link>https://new.halfrost.com/ios_callback_hell_promisekit/</link><pubDate>Fri, 10 Jun 2016 03:51:00 +0000</pubDate><guid>https://new.halfrost.com/ios_callback_hell_promisekit/</guid><description>####前言 最近看了一些Swift关于封装异步操作过程的文章，比如RxSwift，RAC等等，因为回调地狱我自己也写过，很有感触，于是就翻出了Promise来研究学习一下。现将自己的一些收获分享一下，有错误欢迎大家多多指教。
####目录
1.PromiseKit简介 2.PromiseKit安装和使用 3.PromiseKit主要函数的使用方法 4.PromiseKit的源码解析 5.使用PromiseKit优雅的处理回调地狱 ####一.PromiseKit简介 PromiseKit是iOS/OS X 中一个用来处理异步编程框架。这个框架是由Max Howell(Mac下Homebrew的作者，传说中因为&amp;quot;不会&amp;quot;写反转二叉树而没有拿到Google offer)大神级人物开发出来的。
在PromiseKit中，最重要的一个概念就是Promise的概念，Promise是异步操作后的future的一个值。
A promise represents the future value of an asynchronous task. A promise is an object that wraps an asynchronous task
Promise也是一个包装着异步操作的一个对象。使用PromiseKit，能够编写出整洁，有序的代码，逻辑简单的，将Promise作为参数，模块化的从一个异步任务到下一个异步任务中去。用PromiseKit写出的代码就是这样：
[self login].then(^{ // our login method wrapped an async task in a promise  return [API fetchData]; }).then(^(NSArray *fetchedData){ // our API class wraps our API and returns promises  // fetchedData returned a promise that resolves with an array of data  self.</description></item></channel></rss>
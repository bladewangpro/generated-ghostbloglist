<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on prometheus</title><link>https://new.halfrost.com/categories/algorithm/</link><description>Recent content in Algorithm on prometheus</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>halfrost</copyright><lastBuildDate>Sat, 21 Dec 2019 11:54:00 +0000</lastBuildDate><atom:link href="https://new.halfrost.com/categories/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Algorithm in LeetCode —— Segment Tree</title><link>https://new.halfrost.com/segment_tree/</link><pubDate>Sat, 21 Dec 2019 11:54:00 +0000</pubDate><guid>https://new.halfrost.com/segment_tree/</guid><description>Segment Tree 的 Tips: 线段数的经典数组实现写法。将合并两个节点 pushUp 逻辑抽象出来了，可以实现任意操作(常见的操作有：加法，取 max，min 等等)。第 218 题，第 303 题，第 307 题，第 699 题。 计数线段树的经典写法。第 315 题，第 327 题，第 493 题。 线段树的树的实现写法。第 715 题，第 732 题。 区间懒惰更新。第 218 题，第 699 题。 离散化。离散化需要注意一个特殊情况：假如三个区间为 [1,10] [1,4] [6,10]，离散化后 x[1]=1,x[2]=4,x[3]=6,x[4]=10。第一个区间为 [1,4]，第二个区间为 [1,2]，第三个区间为 [3,4]，这样一来，区间一 = 区间二 + 区间三，这和离散前的模型不符，离散前，很明显，区间一 &amp;gt; 区间二 + 区间三。正确的做法是：在相差大于 1 的数间加一个数，例如在上面 1 4 6 10 中间加 5，即可 x[1]=1,x[2]=4,x[3]=5,x[4]=6,x[5]=10。这样处理之后，区间一是 1-5 ，区间二是 1-2 ，区间三是 4-5 。 灵活构建线段树。线段树节点可以存储多条信息，合并两个节点的 pushUp 操作也可以是多样的。第 850 题，第 1157 题。 线段树题型从简单到困难:</description></item><item><title>Algorithm in LeetCode —— Sliding Window</title><link>https://new.halfrost.com/sliding_window/</link><pubDate>Sat, 14 Dec 2019 11:46:00 +0000</pubDate><guid>https://new.halfrost.com/sliding_window/</guid><description>Sliding Window 的 Tips: 双指针滑动窗口的经典写法。右指针不断往右移，移动到不能往右移动为止(具体条件根据题目而定)。当右指针到最右边以后，开始挪动左指针，释放窗口左边界。第 3 题，第 76 题，第 209 题，第 424 题，第 438 题，第 567 题，第 713 题，第 763 题，第 845 题，第 881 题，第 904 题，第 978 题，第 992 题，第 1004 题，第 1040 题，第 1052 题。 left, right := 0, -1 for left &amp;lt; len(s) { if right+1 &amp;lt; len(s) &amp;amp;&amp;amp; freq[s[right+1]-&amp;#39;a&amp;#39;] == 0 { freq[s[right+1]-&amp;#39;a&amp;#39;]++ right++ } else { freq[s[left]-&amp;#39;a&amp;#39;]-- left++ } result = max(result, right-left+1) } 滑动窗口经典题。第 239 题，第 480 题。 Title Solution Difficulty Time Space 收藏 3.</description></item><item><title>Algorithm in LeetCode —— Union Find</title><link>https://new.halfrost.com/union_find/</link><pubDate>Sat, 16 Nov 2019 08:31:00 +0000</pubDate><guid>https://new.halfrost.com/union_find/</guid><description>Union Find 的 Tips: 灵活使用并查集的思想，熟练掌握并查集的模板，模板中有两种并查集的实现方式，一种是路径压缩 + 秩优化的版本，另外一种是计算每个集合中元素的个数 + 最大集合元素个数的版本，这两种版本都有各自使用的地方。能使用第一类并查集模板的题目有：第 128 题，第 130 题，第 547 题，第 684 题，第 721 题，第 765 题，第 778 题，第 839 题，第 924 题，第 928 题，第 947 题，第 952 题，第 959 题，第 990 题。能使用第二类并查集模板的题目有：第 803 题，第 952 题。第 803 题秩优化和统计集合个数这些地方会卡时间，如果不优化，会 TLE。 并查集是一种思想，有些题需要灵活使用这种思想，而不是死套模板，如第 399 题，这一题是 stringUnionFind，利用并查集思想实现的。这里每个节点是基于字符串和 map 的，而不是单纯的用 int 节点编号实现的。 有些题死套模板反而做不出来，比如第 685 题，这一题不能路径压缩和秩优化，因为题目中涉及到有向图，需要知道节点的前驱节点，如果路径压缩了，这一题就没法做了。这一题不需要路径压缩和秩优化。 灵活的抽象题目给的信息，将给定的信息合理的编号，使用并查集解题，并用 map 降低时间复杂度，如第 721 题，第 959 题。 关于地图，砖块，网格的题目，可以新建一个特殊节点，将四周边缘的砖块或者网格都 union() 到这个特殊节点上。第 130 题，第 803 题。 能用并查集的题目，一般也可以用 DFS 和 BFS 解答，只不过时间复杂度会高一点。 Title Solution Difficulty Time Space 收藏 128.</description></item><item><title>Algorithm in LeetCode —— Bit Manipulation</title><link>https://new.halfrost.com/bit_manipulation/</link><pubDate>Sat, 09 Nov 2019 08:27:00 +0000</pubDate><guid>https://new.halfrost.com/bit_manipulation/</guid><description>Bit Manipulation 的 Tips: 异或的特性。第 136 题，第 268 题，第 389 题，第 421 题， x ^ 0 = x x ^ 11111……1111 = ~x x ^ (~x) = 11111……1111 x ^ x = 0 a ^ b = c =&amp;gt; a ^ c = b =&amp;gt; b ^ c = a (交换律) a ^ b ^ c = a ^ (b ^ c) = (a ^ b）^ c (结合律) 构造特殊 Mask，将特殊位置放 0 或 1。 1.</description></item><item><title>Algorithm in LeetCode —— Backtracking</title><link>https://new.halfrost.com/backtracking/</link><pubDate>Sat, 19 Oct 2019 08:20:00 +0000</pubDate><guid>https://new.halfrost.com/backtracking/</guid><description>Backtracking 的 Tips: 排列问题 Permutations。第 46 题，第 47 题。第 60 题，第 526 题，第 996 题。 组合问题 Combination。第 39 题，第 40 题，第 77 题，第 216 题。 排列和组合杂交问题。第 1079 题。 N 皇后终极解法(二进制解法)。第 51 题，第 52 题。 数独问题。第 37 题。 四个方向搜索。第 79 题，第 212 题，第 980 题。 子集合问题。第 78 题，第 90 题。 Trie。第 208 题，第 211 题。 BFS 优化。第 126 题，第 127 题。 DFS 模板。(只是一个例子，不对应任何题) func combinationSum2(candidates []int, target int) [][]int { if len(candidates) == 0 { return [][]int{} } c, res := []int{}, [][]int{} sort.</description></item><item><title>Algorithm in LeetCode —— Stack</title><link>https://new.halfrost.com/stack/</link><pubDate>Sat, 12 Oct 2019 08:15:00 +0000</pubDate><guid>https://new.halfrost.com/stack/</guid><description>Stack 的 Tips: 括号匹配问题及类似问题。第 20 题，第 921 题，第 1021 题。 栈的基本 pop 和 push 操作。第 71 题，第 150 题，第 155 题，第 224 题，第 225 题，第 232 题，第 946 题，第 1047 题。 利用栈进行编码问题。第 394 题，第 682 题，第 856 题，第 880 题。 单调栈。利用栈维护一个单调递增或者递减的下标数组。第 84 题，第 456 题，第 496 题，第 503 题，第 739 题，第 901 题，第 907 题，第 1019 题。 Title Solution Difficulty Time Space 收藏 20.</description></item><item><title>Algorithm in LeetCode —— Two Pointers</title><link>https://new.halfrost.com/two_pointers/</link><pubDate>Sat, 21 Sep 2019 10:07:00 +0000</pubDate><guid>https://new.halfrost.com/two_pointers/</guid><description>Two Pointers 的 Tips: 双指针滑动窗口的经典写法。右指针不断往右移，移动到不能往右移动为止(具体条件根据题目而定)。当右指针到最右边以后，开始挪动左指针，释放窗口左边界。第 3 题，第 76 题，第 209 题，第 424 题，第 438 题，第 567 题，第 713 题，第 763 题，第 845 题，第 881 题，第 904 题，第 978 题，第 992 题，第 1004 题，第 1040 题，第 1052 题。 left, right := 0, -1 for left &amp;lt; len(s) { if right+1 &amp;lt; len(s) &amp;amp;&amp;amp; freq[s[right+1]-&amp;#39;a&amp;#39;] == 0 { freq[s[right+1]-&amp;#39;a&amp;#39;]++ right++ } else { freq[s[left]-&amp;#39;a&amp;#39;]-- left++ } result = max(result, right-left+1) } 快慢指针可以查找重复数字，时间复杂度 O(n)，第 287 题。 替换字母以后，相同字母能出现连续最长的长度。第 424 题。 SUM 问题集。第 1 题，第 15 题，第 16 题，第 18 题，第 167 题，第 923 题，第 1074 题。 Title Solution Difficulty Time Space 收藏 3.</description></item><item><title>Algorithm in LeetCode —— Sort</title><link>https://new.halfrost.com/sort/</link><pubDate>Sat, 14 Sep 2019 10:00:00 +0000</pubDate><guid>https://new.halfrost.com/sort/</guid><description>Sort 的 Tips: 深刻的理解多路快排。第 75 题。 链表的排序，插入排序(第 147 题)和归并排序(第 148 题) 桶排序和基数排序。第 164 题。 &amp;ldquo;摆动排序&amp;rdquo;。第 324 题。 两两不相邻的排序。第 767 题，第 1054 题。 &amp;ldquo;饼子排序&amp;rdquo;。第 969 题。 Title Solution Difficulty Time Space 收藏 56. Merge Intervals Go Medium O(n log n) O(log n) 57. Insert Interval Go Hard O(n) O(1) 75. Sort Colors Go Medium O(n) O(1) ❤️ 147.</description></item><item><title>Algorithm in LeetCode —— Linked List</title><link>https://new.halfrost.com/linked_list/</link><pubDate>Sun, 18 Aug 2019 07:47:00 +0000</pubDate><guid>https://new.halfrost.com/linked_list/</guid><description>Linked List 的 Tips: 巧妙的构造虚拟头结点。可以使遍历处理逻辑更加统一。 灵活使用递归。构造递归条件，使用递归可以巧妙的解题。不过需要注意有些题目不能使用递归，因为递归深度太深会导致超时和栈溢出。 链表区间逆序。第 92 题。 链表寻找中间节点。第 876 题。链表寻找倒数第 n 个节点。第 19 题。只需要一次遍历就可以得到答案。 合并 K 个有序链表。第 21 题，第 23 题。 链表归类。第 86 题，第 328 题。 链表排序，时间复杂度要求 O(n * log n)，空间复杂度 O(1)。只有一种做法，归并排序，至顶向下归并。第 148 题。 判断链表是否存在环，如果有环，输出环的交叉点的下标；判断 2 个链表是否有交叉点，如果有交叉点，输出交叉点。第 141 题，第 142 题，第 160 题。 Title Solution Difficulty Time Space 收藏 2. Add Two Numbers Go Medium O(n) O(1) 19.</description></item></channel></rss>
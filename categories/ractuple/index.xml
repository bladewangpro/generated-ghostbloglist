<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RACTuple on prometheus</title><link>https://new.halfrost.com/categories/ractuple/</link><description>Recent content in RACTuple on prometheus</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>halfrost</copyright><lastBuildDate>Sun, 25 Dec 2016 07:54:00 +0000</lastBuildDate><atom:link href="https://new.halfrost.com/categories/ractuple/index.xml" rel="self" type="application/rss+xml"/><item><title>ReactiveCocoa 中 集合类 RACSequence 和 RACTuple 底层实现分析</title><link>https://new.halfrost.com/reactivecocoa_racsequence_ractuple/</link><pubDate>Sun, 25 Dec 2016 07:54:00 +0000</pubDate><guid>https://new.halfrost.com/reactivecocoa_racsequence_ractuple/</guid><description>前言 在OOP的世界里使用FRP的思想来编程，光有函数这种一等公民，还是无法满足我们一些需求的。因此还是需要引用变量来完成各式各样的类的操作行为。
在前几篇文章中详细的分析了RACStream中RACSignal的底层实现。RACStream还有另外一个子类，RACSequence，这个类是RAC专门为集合而设计的。这篇文章就专门分析一下RACSequence的底层实现。
目录 1.RACTuple底层实现分析 2.RACSequence底层实现分析 3.RACSequence操作实现分析 4.RACSequence的一些扩展 一. RACTuple底层实现分析 在分析RACSequence之前，先来看看RACTuple的实现。RACTuple是ReactiveCocoa的元组类。
1. RACTuple @interface RACTuple : NSObject &amp;lt;NSCoding, NSCopying, NSFastEnumeration&amp;gt; @property (nonatomic, readonly) NSUInteger count; @property (nonatomic, readonly) id first; @property (nonatomic, readonly) id second; @property (nonatomic, readonly) id third; @property (nonatomic, readonly) id fourth; @property (nonatomic, readonly) id fifth; @property (nonatomic, readonly) id last; @property (nonatomic, strong) NSArray *backingArray; @property (nonatomic, copy, readonly) RACSequence *rac_sequence; // 这个是专门为sequence提供的一个扩展 @end RACTuple的定义看上去很简单，底层实质就是一个NSArray，只不过封装了一些方法。RACTuple继承了NSCoding, NSCopying, NSFastEnumeration这三个协议。</description></item></channel></rss>
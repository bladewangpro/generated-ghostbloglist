<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=theme-color content="#FFFFFF"><meta http-equiv=x-ua-compatible content="IE=edge"><title>ReactiveCocoa 中 RACScheduler 是如何封装 GCD 的 | prometheus</title><meta name=description content="Explore in every moment of the hard thinking"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="ReactiveCocoa 中 RACScheduler 是如何封装 GCD 的"><meta property="og:description" content="前言 在使用ReactiveCocoa 过程中，Josh Abernathy和Justin Spahr-Summers 两位大神为了能让RAC的使用者更畅快的在沉浸在FRP的世界里，更好的进行并发编程，于是就对GCD进行了一次封装，并与RAC的各大组件进行了完美的整合。
自从有了RACScheduler以后，使整个RAC并发编程的代码里面更加和谐统一，更加顺手，更加“ReactiveCocoa”。
目录  1.RACScheduler是如何封装GCD的 2.RACScheduler的一些子类 3.RACScheduler是如何“取消”并发任务的 4.RACScheduler是如何和RAC其他组件进行完美整合的  一. RACScheduler是如何封装GCD的 RACScheduler在ReactiveCocoa中到底是干嘛的呢？处于什么地位呢？官方给出的定义如下：
Schedulers are used to control when and where work is performedRACScheduler在ReactiveCocoa中是用来控制一个任务，何时何地被执行。它主要是用来解决ReactiveCocoa中并发编程的问题的。
RACScheduler的实质是对GCD的封装，底层就是GCD实现的。
要分析RACScheduler，先来回顾一下GCD。
众所周知，在GCD中，Dispatch Queue主要分为2类，Serial Dispatch Queue 和 Concurrent Dispatch Queue 。其中Serial Dispatch Queue是等待现在执行中处理结束的队列，Concurrent Dispatch Queue是不等待现在执行中处理结束的队列。
生成Dispatch Queue的方法也有2种，第一种方式是通过GCD的API生成Dispatch Queue。
生成Serial Dispatch Queue
dispatch_queue_t serialDispatchQueue = dispatch_queue_create(&#34;com.gcd.SerialDispatchQueue&#34;, DISPATCH_QUEUE_SERIAL); 生成Concurrent Dispatch Queue
dispatch_queue_t concurrentDispatchQueue = dispatch_queue_create(&#34;com.gcd.ConcurrentDispatchQueue&#34;, DISPATCH_QUEUE_CONCURRENT); 第二种方法是直接获取系统提供的Dispatch Queue。系统提供的也分为2类，Main Dispatch Queue 和 Global Dispatch Queue。Main Dispatch Queue 对应着是Serial Dispatch Queue，Global Dispatch Queue 对应着是Concurrent Dispatch Queue。"><meta property="og:type" content="article"><meta property="og:url" content="https://new.halfrost.com/reactivecocoa_racscheduler/"><meta property="article:published_time" content="2016-12-31T01:09:00+00:00"><meta property="article:modified_time" content="2016-12-31T01:09:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="ReactiveCocoa 中 RACScheduler 是如何封装 GCD 的"><meta name=twitter:description content="前言 在使用ReactiveCocoa 过程中，Josh Abernathy和Justin Spahr-Summers 两位大神为了能让RAC的使用者更畅快的在沉浸在FRP的世界里，更好的进行并发编程，于是就对GCD进行了一次封装，并与RAC的各大组件进行了完美的整合。
自从有了RACScheduler以后，使整个RAC并发编程的代码里面更加和谐统一，更加顺手，更加“ReactiveCocoa”。
目录  1.RACScheduler是如何封装GCD的 2.RACScheduler的一些子类 3.RACScheduler是如何“取消”并发任务的 4.RACScheduler是如何和RAC其他组件进行完美整合的  一. RACScheduler是如何封装GCD的 RACScheduler在ReactiveCocoa中到底是干嘛的呢？处于什么地位呢？官方给出的定义如下：
Schedulers are used to control when and where work is performedRACScheduler在ReactiveCocoa中是用来控制一个任务，何时何地被执行。它主要是用来解决ReactiveCocoa中并发编程的问题的。
RACScheduler的实质是对GCD的封装，底层就是GCD实现的。
要分析RACScheduler，先来回顾一下GCD。
众所周知，在GCD中，Dispatch Queue主要分为2类，Serial Dispatch Queue 和 Concurrent Dispatch Queue 。其中Serial Dispatch Queue是等待现在执行中处理结束的队列，Concurrent Dispatch Queue是不等待现在执行中处理结束的队列。
生成Dispatch Queue的方法也有2种，第一种方式是通过GCD的API生成Dispatch Queue。
生成Serial Dispatch Queue
dispatch_queue_t serialDispatchQueue = dispatch_queue_create(&#34;com.gcd.SerialDispatchQueue&#34;, DISPATCH_QUEUE_SERIAL); 生成Concurrent Dispatch Queue
dispatch_queue_t concurrentDispatchQueue = dispatch_queue_create(&#34;com.gcd.ConcurrentDispatchQueue&#34;, DISPATCH_QUEUE_CONCURRENT); 第二种方法是直接获取系统提供的Dispatch Queue。系统提供的也分为2类，Main Dispatch Queue 和 Global Dispatch Queue。Main Dispatch Queue 对应着是Serial Dispatch Queue，Global Dispatch Queue 对应着是Concurrent Dispatch Queue。"><link rel=stylesheet href=/css/style-white.min.css><link rel=manifest href=/manifest.json><link rel=stylesheet href=/prism.css><link href=/images/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=/images/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=/images/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=/images/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=/images/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=/images/apple-touch-icon-512x512.png rel=apple-touch-icon sizes=512x512><link href=/images/apple-touch-icon-1024x1024.png rel=apple-touch-icon sizes=1024x1024><script async>if('serviceWorker'in navigator){navigator.serviceWorker.register("\/serviceworker-v1.min.a64912b78d282eab1ad3715a0943da21616e5f326f8afea27034784ad445043b.js").then(function(){if(navigator.serviceWorker.controller){console.log('Assets cached by the controlling service worker.');}else{console.log('Please reload this page to allow the service worker to handle network operations.');}}).catch(function(error){console.log('ERROR: '+error);});}else{console.log('Service workers are not supported in the current browser.');}</script><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://new.halfrost.com/images/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-82753806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="single-max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a><a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a><a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast');" style=display:none><i class="fas fa-chevron-up fa-lg"></i></a><span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://new.halfrost.com/reactivecocoa_racsequence_ractuple/><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li><li><a class=icon href=https://new.halfrost.com/reactivecocoa_raccommand/><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li><li><a class=icon href=#><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f"><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&text=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&title=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&is_video=false&description=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f"><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&title=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&title=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&title=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-stumbleupon" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&title=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-digg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&name=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84&description=%e5%89%8d%e8%a8%80%20%e5%9c%a8%e4%bd%bf%e7%94%a8ReactiveCocoa%20%e8%bf%87%e7%a8%8b%e4%b8%ad%ef%bc%8cJosh%20Abernathy%e5%92%8cJustin%20Spahr-Summers%20%e4%b8%a4%e4%bd%8d%e5%a4%a7%e7%a5%9e%e4%b8%ba%e4%ba%86%e8%83%bd%e8%ae%a9RAC%e7%9a%84%e4%bd%bf%e7%94%a8%e8%80%85%e6%9b%b4%e7%95%85%e5%bf%ab%e7%9a%84%e5%9c%a8%e6%b2%89%e6%b5%b8%e5%9c%a8FRP%e7%9a%84%e4%b8%96%e7%95%8c%e9%87%8c%ef%bc%8c%e6%9b%b4%e5%a5%bd%e7%9a%84%e8%bf%9b%e8%a1%8c%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%ef%bc%8c%e4%ba%8e%e6%98%af%e5%b0%b1%e5%af%b9GCD%e8%bf%9b%e8%a1%8c%e4%ba%86%e4%b8%80%e6%ac%a1%e5%b0%81%e8%a3%85%ef%bc%8c%e5%b9%b6%e4%b8%8eRAC%e7%9a%84%e5%90%84%e5%a4%a7%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e4%ba%86%e5%ae%8c%e7%be%8e%e7%9a%84%e6%95%b4%e5%90%88%e3%80%82%0a%e8%87%aa%e4%bb%8e%e6%9c%89%e4%ba%86RACScheduler%e4%bb%a5%e5%90%8e%ef%bc%8c%e4%bd%bf%e6%95%b4%e4%b8%aaRAC%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e7%9a%84%e4%bb%a3%e7%a0%81%e9%87%8c%e9%9d%a2%e6%9b%b4%e5%8a%a0%e5%92%8c%e8%b0%90%e7%bb%9f%e4%b8%80%ef%bc%8c%e6%9b%b4%e5%8a%a0%e9%a1%ba%e6%89%8b%ef%bc%8c%e6%9b%b4%e5%8a%a0%e2%80%9cReactiveCocoa%e2%80%9d%e3%80%82%0a%e7%9b%ae%e5%bd%95%20%201.RACScheduler%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85GCD%e7%9a%84%202.RACScheduler%e7%9a%84%e4%b8%80%e4%ba%9b%e5%ad%90%e7%b1%bb%203.RACScheduler%e6%98%af%e5%a6%82%e4%bd%95%e2%80%9c%e5%8f%96%e6%b6%88%e2%80%9d%e5%b9%b6%e5%8f%91%e4%bb%bb%e5%8a%a1%e7%9a%84%204.RACScheduler%e6%98%af%e5%a6%82%e4%bd%95%e5%92%8cRAC%e5%85%b6%e4%bb%96%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e5%ae%8c%e7%be%8e%e6%95%b4%e5%90%88%e7%9a%84%20%20%e4%b8%80.%20RACScheduler%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85GCD%e7%9a%84%20RACScheduler%e5%9c%a8ReactiveCocoa%e4%b8%ad%e5%88%b0%e5%ba%95%e6%98%af%e5%b9%b2%e5%98%9b%e7%9a%84%e5%91%a2%ef%bc%9f%e5%a4%84%e4%ba%8e%e4%bb%80%e4%b9%88%e5%9c%b0%e4%bd%8d%e5%91%a2%ef%bc%9f%e5%ae%98%e6%96%b9%e7%bb%99%e5%87%ba%e7%9a%84%e5%ae%9a%e4%b9%89%e5%a6%82%e4%b8%8b%ef%bc%9a%0aSchedulers%20are%20used%20to%20control%20when%20and%20where%20work%20is%20performedRACScheduler%e5%9c%a8ReactiveCocoa%e4%b8%ad%e6%98%af%e7%94%a8%e6%9d%a5%e6%8e%a7%e5%88%b6%e4%b8%80%e4%b8%aa%e4%bb%bb%e5%8a%a1%ef%bc%8c%e4%bd%95%e6%97%b6%e4%bd%95%e5%9c%b0%e8%a2%ab%e6%89%a7%e8%a1%8c%e3%80%82%e5%ae%83%e4%b8%bb%e8%a6%81%e6%98%af%e7%94%a8%e6%9d%a5%e8%a7%a3%e5%86%b3ReactiveCocoa%e4%b8%ad%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e7%9a%84%e9%97%ae%e9%a2%98%e7%9a%84%e3%80%82%0aRACScheduler%e7%9a%84%e5%ae%9e%e8%b4%a8%e6%98%af%e5%af%b9GCD%e7%9a%84%e5%b0%81%e8%a3%85%ef%bc%8c%e5%ba%95%e5%b1%82%e5%b0%b1%e6%98%afGCD%e5%ae%9e%e7%8e%b0%e7%9a%84%e3%80%82%0a%e8%a6%81%e5%88%86%e6%9e%90RACScheduler%ef%bc%8c%e5%85%88%e6%9d%a5%e5%9b%9e%e9%a1%be%e4%b8%80%e4%b8%8bGCD%e3%80%82%0a%e4%bc%97%e6%89%80%e5%91%a8%e7%9f%a5%ef%bc%8c%e5%9c%a8GCD%e4%b8%ad%ef%bc%8cDispatch%20Queue%e4%b8%bb%e8%a6%81%e5%88%86%e4%b8%ba2%e7%b1%bb%ef%bc%8cSerial%20Dispatch%20Queue%20%e5%92%8c%20Concurrent%20Dispatch%20Queue%20%e3%80%82%e5%85%b6%e4%b8%adSerial%20Dispatch%20Queue%e6%98%af%e7%ad%89%e5%be%85%e7%8e%b0%e5%9c%a8%e6%89%a7%e8%a1%8c%e4%b8%ad%e5%a4%84%e7%90%86%e7%bb%93%e6%9d%9f%e7%9a%84%e9%98%9f%e5%88%97%ef%bc%8cConcurrent%20Dispatch%20Queue%e6%98%af%e4%b8%8d%e7%ad%89%e5%be%85%e7%8e%b0%e5%9c%a8%e6%89%a7%e8%a1%8c%e4%b8%ad%e5%a4%84%e7%90%86%e7%bb%93%e6%9d%9f%e7%9a%84%e9%98%9f%e5%88%97%e3%80%82%0a%e7%94%9f%e6%88%90Dispatch%20Queue%e7%9a%84%e6%96%b9%e6%b3%95%e4%b9%9f%e6%9c%892%e7%a7%8d%ef%bc%8c%e7%ac%ac%e4%b8%80%e7%a7%8d%e6%96%b9%e5%bc%8f%e6%98%af%e9%80%9a%e8%bf%87GCD%e7%9a%84API%e7%94%9f%e6%88%90Dispatch%20Queue%e3%80%82%0a%e7%94%9f%e6%88%90Serial%20Dispatch%20Queue%0adispatch_queue_t%20serialDispatchQueue%20%3d%20dispatch_queue_create%28%26%2334%3bcom.gcd.SerialDispatchQueue%26%2334%3b%2c%20DISPATCH_QUEUE_SERIAL%29%3b%20%e7%94%9f%e6%88%90Concurrent%20Dispatch%20Queue%0adispatch_queue_t%20concurrentDispatchQueue%20%3d%20dispatch_queue_create%28%26%2334%3bcom.gcd.ConcurrentDispatchQueue%26%2334%3b%2c%20DISPATCH_QUEUE_CONCURRENT%29%3b%20%e7%ac%ac%e4%ba%8c%e7%a7%8d%e6%96%b9%e6%b3%95%e6%98%af%e7%9b%b4%e6%8e%a5%e8%8e%b7%e5%8f%96%e7%b3%bb%e7%bb%9f%e6%8f%90%e4%be%9b%e7%9a%84Dispatch%20Queue%e3%80%82%e7%b3%bb%e7%bb%9f%e6%8f%90%e4%be%9b%e7%9a%84%e4%b9%9f%e5%88%86%e4%b8%ba2%e7%b1%bb%ef%bc%8cMain%20Dispatch%20Queue%20%e5%92%8c%20Global%20Dispatch%20Queue%e3%80%82Main%20Dispatch%20Queue%20%e5%af%b9%e5%ba%94%e7%9d%80%e6%98%afSerial%20Dispatch%20Queue%ef%bc%8cGlobal%20Dispatch%20Queue%20%e5%af%b9%e5%ba%94%e7%9d%80%e6%98%afConcurrent%20Dispatch%20Queue%e3%80%82"><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&t=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div><div id=toc><nav id=TableOfContents><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#目录>目录</a><ul><li><a href=#一-racscheduler是如何封装gcd的>一. RACScheduler是如何封装GCD的</a></li><li><a href=#二-racscheduler的一些子类>二. RACScheduler的一些子类</a></li><li><a href=#三-racscheduler是如何取消并发任务的>三. RACScheduler是如何“取消”并发任务的</a></li><li><a href=#四-racscheduler是如何和rac其他组件进行完美整合的>四. RACScheduler是如何和RAC其他组件进行完美整合的</a></li></ul></li><li><a href=#最后>最后</a></li></ul></li></ul></nav></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">ReactiveCocoa 中 RACScheduler 是如何封装 GCD 的</h1><div class=meta><div class=postdate><time datetime="2016-12-31 01:09:00 +0000 UTC" itemprop=datePublished>Dec 31</time></div><div class=article-category><i class="fas fa-archive"></i><a class=category-link href=/categories/ios>iOS</a>
,
<a class=category-link href=/categories/reactivecocoa>ReactiveCocoa</a>
,
<a class=category-link href=/categories/rac>RAC</a>
,
<a class=category-link href=/categories/racscheduler>RACScheduler</a></div><div class=article-tag><i class="fas fa-tag"></i><a class=tag-link href=/tags/ios rel=tag>iOS</a>
,
<a class=tag-link href=/tags/reactivecocoa rel=tag>ReactiveCocoa</a>
,
<a class=tag-link href=/tags/rac rel=tag>RAC</a>
,
<a class=tag-link href=/tags/racscheduler rel=tag>RACScheduler</a></div></div></header><div class=content itemprop=articleBody><h3 id=前言>前言</h3><p>在使用ReactiveCocoa 过程中，<a href=https://github.com/joshaber>Josh Abernathy</a>和<a href=https://github.com/jspahrsummers>Justin Spahr-Summers</a> 两位大神为了能让RAC的使用者更畅快的在沉浸在FRP的世界里，更好的进行并发编程，于是就对GCD进行了一次封装，并与RAC的各大组件进行了完美的整合。</p><p>自从有了RACScheduler以后，使整个RAC并发编程的代码里面更加和谐统一，更加顺手，更加“ReactiveCocoa”。</p><h3 id=目录>目录</h3><ul><li>1.RACScheduler是如何封装GCD的</li><li>2.RACScheduler的一些子类</li><li>3.RACScheduler是如何“取消”并发任务的</li><li>4.RACScheduler是如何和RAC其他组件进行完美整合的</li></ul><h4 id=一-racscheduler是如何封装gcd的>一. RACScheduler是如何封装GCD的</h4><p>RACScheduler在ReactiveCocoa中到底是干嘛的呢？处于什么地位呢？官方给出的定义如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>Schedulers</span> <span style=color:#a6e22e>are</span> <span style=color:#a6e22e>used</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>control</span> <span style=color:#a6e22e>when</span> <span style=color:#a6e22e>and</span> <span style=color:#a6e22e>where</span> <span style=color:#a6e22e>work</span> <span style=color:#a6e22e>is</span> <span style=color:#a6e22e>performed</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>RACScheduler在ReactiveCocoa中是用来控制一个任务，何时何地被执行。它主要是用来解决ReactiveCocoa中并发编程的问题的。</p><p>RACScheduler的实质是对GCD的封装，底层就是GCD实现的。</p><p>要分析RACScheduler，先来回顾一下GCD。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_1.png alt></p><p>众所周知，在GCD中，Dispatch Queue主要分为2类，Serial Dispatch Queue 和 Concurrent Dispatch Queue 。其中Serial Dispatch Queue是等待现在执行中处理结束的队列，Concurrent Dispatch Queue是不等待现在执行中处理结束的队列。</p><p>生成Dispatch Queue的方法也有2种，第一种方式是通过GCD的API生成Dispatch Queue。</p><p>生成Serial Dispatch Queue</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
dispatch_queue_t serialDispatchQueue <span style=color:#f92672>=</span> dispatch_queue_create(<span style=color:#e6db74>&#34;com.gcd.SerialDispatchQueue&#34;</span>, DISPATCH_QUEUE_SERIAL);
    


</code></pre></div><p>生成Concurrent Dispatch Queue</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

dispatch_queue_t concurrentDispatchQueue <span style=color:#f92672>=</span> dispatch_queue_create(<span style=color:#e6db74>&#34;com.gcd.ConcurrentDispatchQueue&#34;</span>, DISPATCH_QUEUE_CONCURRENT);

</code></pre></div><p>第二种方法是直接获取系统提供的Dispatch Queue。系统提供的也分为2类，Main Dispatch Queue 和 Global Dispatch Queue。Main Dispatch Queue 对应着是Serial Dispatch Queue，Global Dispatch Queue 对应着是Concurrent Dispatch Queue。</p><p>Global Dispatch Queue主要分为8种。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_2.png alt></p><p>首先是以下4种，分别是优先级对应Qos的情况。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
  <span style=color:#f92672>-</span> DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED
  <span style=color:#f92672>-</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT
  <span style=color:#f92672>-</span> DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY
  <span style=color:#f92672>-</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND

</code></pre></div><p>其次是，是否支持 overcommit。加上上面4个优先级，所以一共8种Global Dispatch Queue。带有 overcommit 的队列表示每当有任务提交时，系统都会新开一个线程处理，这样就不会造成某个线程过载(overcommit)。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_3.png alt></p><p>回到RACScheduler中来，RACScheduler既然是对GCD的封装，那么上述说的这些类型也都有其一一对应的封装。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>long</span> {
     RACSchedulerPriorityHigh <span style=color:#f92672>=</span> DISPATCH_QUEUE_PRIORITY_HIGH,
     RACSchedulerPriorityDefault <span style=color:#f92672>=</span> DISPATCH_QUEUE_PRIORITY_DEFAULT,
     RACSchedulerPriorityLow <span style=color:#f92672>=</span> DISPATCH_QUEUE_PRIORITY_LOW,
     RACSchedulerPriorityBackground <span style=color:#f92672>=</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND,
} RACSchedulerPriority;


</code></pre></div><p>首先是RACScheduler中的优先级，这里只封装了4种，也是分别对应GCD中的DISPATCH_QUEUE_PRIORITY_HIGH，DISPATCH_QUEUE_PRIORITY_DEFAULT，DISPATCH_QUEUE_PRIORITY_LOW，DISPATCH_QUEUE_PRIORITY_BACKGROUND。</p><p>RACScheduler有6个类方法，都是用来生成一个queue的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (RACScheduler <span style=color:#f92672>*</span>)<span style=color:#a6e22e>immediateScheduler</span>;
+ (RACScheduler <span style=color:#f92672>*</span>)<span style=color:#a6e22e>mainThreadScheduler</span>;

+ (RACScheduler <span style=color:#f92672>*</span>)<span style=color:#a6e22e>schedulerWithPriority:</span>(RACSchedulerPriority)priority <span style=color:#a6e22e>name:</span>(NSString <span style=color:#f92672>*</span>)name;
+ (RACScheduler <span style=color:#f92672>*</span>)<span style=color:#a6e22e>schedulerWithPriority:</span>(RACSchedulerPriority)priority;
+ (RACScheduler <span style=color:#f92672>*</span>)<span style=color:#a6e22e>scheduler</span>;

+ (RACScheduler <span style=color:#f92672>*</span>)<span style=color:#a6e22e>currentScheduler</span>;



</code></pre></div><p>接下来依次分析一下它们的底层实现。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_4.png alt></p><h5 id=1-immediatescheduler>1. immediateScheduler</h5><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_5.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>immediateScheduler</span> {
    <span style=color:#66d9ef>static</span> dispatch_once_t onceToken;
    <span style=color:#66d9ef>static</span> RACScheduler <span style=color:#f92672>*</span>immediateScheduler;
    dispatch_once(<span style=color:#f92672>&amp;</span>onceToken, <span style=color:#f92672>^</span>{
        immediateScheduler <span style=color:#f92672>=</span> [[RACImmediateScheduler alloc] init];
    });
    
    <span style=color:#66d9ef>return</span> immediateScheduler;
}


</code></pre></div><p>immediateScheduler底层实现就是生成了一个RACImmediateScheduler的单例。</p><p>RACImmediateScheduler 是继承自RACScheduler。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>RACImmediateScheduler</span> : <span style=color:#a6e22e>RACScheduler</span>
<span style=color:#66d9ef>@end</span>

</code></pre></div><p>在RACScheduler中，每个种类的RACScheduler都会有一个name属性，名字也算是他们的标示。RACImmediateScheduler的name是@&ldquo;com.ReactiveCocoa.RACScheduler.immediateScheduler&rdquo;</p><p>RACImmediateScheduler的作用和它的名字一样，是立即执行闭包里面的任务。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCParameterAssert(block <span style=color:#f92672>!=</span> NULL);
    
    block();
    <span style=color:#66d9ef>return</span> nil;
}

- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>after:</span>(NSDate <span style=color:#f92672>*</span>)date <span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCParameterAssert(date <span style=color:#f92672>!=</span> nil);
    NSCParameterAssert(block <span style=color:#f92672>!=</span> NULL);
    
    [NSThread sleepUntilDate:date];
    block();
    
    <span style=color:#66d9ef>return</span> nil;
}


</code></pre></div><p>在schedule:方法中，直接调用执行入参block( )闭包。在after: schedule:方法中，线程先睡眠，直到date的时刻，再醒过来执行入参block( )闭包。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>after:</span>(NSDate <span style=color:#f92672>*</span>)date <span style=color:#a6e22e>repeatingEvery:</span>(NSTimeInterval)interval <span style=color:#a6e22e>withLeeway:</span>(NSTimeInterval)leeway <span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCAssert(NO, <span style=color:#e6db74>@&#34;+[RACScheduler immediateScheduler] does not support %@.&#34;</span>, NSStringFromSelector(_cmd));
    <span style=color:#66d9ef>return</span> nil;
}


</code></pre></div><p>当然RACImmediateScheduler是不可能支持after: repeatingEvery: withLeeway: schedule:方法的。因为它的定义就是立即执行的，不应该repeat。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>scheduleRecursiveBlock:</span>(RACSchedulerRecursiveBlock)recursiveBlock {
    
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>__block</span> NSUInteger remaining <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; remaining <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>; remaining<span style=color:#f92672>--</span>) {
        recursiveBlock(<span style=color:#f92672>^</span>{
            remaining<span style=color:#f92672>++</span>;
        });
    }
    <span style=color:#66d9ef>return</span> nil;
}

</code></pre></div><p>RACImmediateScheduler的scheduleRecursiveBlock:方法中只要recursiveBlock闭包存在，就会无限递归调用执行，除非recursiveBlock不存在了。</p><h5 id=2-mainthreadscheduler>2. mainThreadScheduler</h5><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_6.png alt></p><p>mainThreadScheduler也是一个类型是RACTargetQueueScheduler的单例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>mainThreadScheduler</span> {
    <span style=color:#66d9ef>static</span> dispatch_once_t onceToken;
    <span style=color:#66d9ef>static</span> RACScheduler <span style=color:#f92672>*</span>mainThreadScheduler;
    dispatch_once(<span style=color:#f92672>&amp;</span>onceToken, <span style=color:#f92672>^</span>{
        mainThreadScheduler <span style=color:#f92672>=</span> [[RACTargetQueueScheduler alloc] initWithName:<span style=color:#e6db74>@&#34;com.ReactiveCocoa.RACScheduler.mainThreadScheduler&#34;</span> targetQueue:dispatch_get_main_queue()];
    });
    
    <span style=color:#66d9ef>return</span> mainThreadScheduler;
}


</code></pre></div><p>mainThreadScheduler的名字是@&ldquo;com.ReactiveCocoa.RACScheduler.mainThreadScheduler&rdquo;。</p><p>RACTargetQueueScheduler继承自RACQueueScheduler</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>RACTargetQueueScheduler</span> : <span style=color:#a6e22e>RACQueueScheduler</span>
- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>initWithName:</span>(NSString <span style=color:#f92672>*</span>)name <span style=color:#a6e22e>targetQueue:</span>(dispatch_queue_t)targetQueue;
<span style=color:#66d9ef>@end</span>

</code></pre></div><p>在RACTargetQueueScheduler中，只有一个初始化方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>initWithName:</span>(NSString <span style=color:#f92672>*</span>)name <span style=color:#a6e22e>targetQueue:</span>(dispatch_queue_t)targetQueue {
    NSCParameterAssert(targetQueue <span style=color:#f92672>!=</span> NULL);
    
    <span style=color:#66d9ef>if</span> (name <span style=color:#f92672>==</span> nil) {
        name <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;com.ReactiveCocoa.RACTargetQueueScheduler(%s)&#34;</span>, dispatch_queue_get_label(targetQueue)];
    }
    
    dispatch_queue_t queue <span style=color:#f92672>=</span> dispatch_queue_create(name.UTF8String, DISPATCH_QUEUE_SERIAL);
    <span style=color:#66d9ef>if</span> (queue <span style=color:#f92672>==</span> NULL) <span style=color:#66d9ef>return</span> nil;
    
    dispatch_set_target_queue(queue, targetQueue);
    
    <span style=color:#66d9ef>return</span> [super initWithName:name queue:queue];
}

</code></pre></div><p>先新建了一个queue，name是@&ldquo;com.ReactiveCocoa.RACScheduler.mainThreadScheduler&rdquo;，类型是Serial Dispatch Queue 类型的，然后调用了dispatch_set_target_queue方法。</p><p>所以重点就在dispatch_set_target_queue方法里面了。</p><p>dispatch_set_target_queue方法主要有两个目的：一是设置dispatch_queue_create创建队列的优先级，二是建立队列的执行阶层。</p><ul><li>当使用dispatch_queue_create创建队列的时候，不管是串行还是并行，它们的优先级都是DISPATCH_QUEUE_PRIORITY_DEFAULT级别，而这个API就是可以设置队列的优先级。</li></ul><p>举个例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
dispatch_queue_t serialQueue <span style=color:#f92672>=</span> dispatch_queue_create(<span style=color:#e6db74>&#34;serialQueue&#34;</span>, DISPATCH_QUEUE_SERIAL);
dispatch_queue_t globalQueue <span style=color:#f92672>=</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span style=color:#ae81ff>0</span>);
<span style=color:#75715e>//注意：被设置优先级的队列是第一个参数。
</span><span style=color:#75715e></span>dispatch_set_target_queue(serialQueue, globalQueue);

</code></pre></div><p>通过上面的代码，就把将serailQueue设置成DISPATCH_QUEUE_PRIORITY_HIGH。</p><ul><li>使用这个dispatch_set_target_queue方法可以设置队列执行阶层，例如dispatch_set_target_queue(queue, targetQueue);
这样设置时，相当于将queue指派给targetQueue，如果targetQueue是串行队列，则queue是串行执行的；如果targetQueue是并行队列，那么queue是并行的。</li></ul><p>举个例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    dispatch_queue_t targetQueue <span style=color:#f92672>=</span> dispatch_queue_create(<span style=color:#e6db74>&#34;targetQueue&#34;</span>, DISPATCH_QUEUE_SERIAL);
    
    dispatch_queue_t queue1 <span style=color:#f92672>=</span> dispatch_queue_create(<span style=color:#e6db74>&#34;queue1&#34;</span>, DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue2 <span style=color:#f92672>=</span> dispatch_queue_create(<span style=color:#e6db74>&#34;queue2&#34;</span>, DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_set_target_queue(queue1, targetQueue);
    dispatch_set_target_queue(queue2, targetQueue);
    
    dispatch_async(queue1, <span style=color:#f92672>^</span>{
        NSLog(<span style=color:#e6db74>@&#34;queue1 1&#34;</span>);
    });
    dispatch_async(queue1, <span style=color:#f92672>^</span>{
        NSLog(<span style=color:#e6db74>@&#34;queue1 2&#34;</span>);
    });
    dispatch_async(queue2, <span style=color:#f92672>^</span>{
        NSLog(<span style=color:#e6db74>@&#34;queue2 1&#34;</span>);
    });
    dispatch_async(queue2, <span style=color:#f92672>^</span>{
        NSLog(<span style=color:#e6db74>@&#34;queue2 2&#34;</span>);
    });
    dispatch_async(targetQueue, <span style=color:#f92672>^</span>{
        NSLog(<span style=color:#e6db74>@&#34;target queue&#34;</span>);
    });



</code></pre></div><p>如果targetQueue为Serial Dispatch Queue，那么输出结果必定如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>queue1</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>queue1</span> <span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>queue2</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>queue2</span> <span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>target</span> <span style=color:#a6e22e>queue</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>如果targetQueue为Concurrent Dispatch Queue，那么输出结果可能如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>queue1</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>queue2</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>queue1</span> <span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>target</span> <span style=color:#a6e22e>queue</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>queue2</span> <span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>回到RACTargetQueueScheduler中来，在这里传进来的入参是dispatch_get_main_queue( )，这是一个Serial Dispatch Queue，这里再调用dispatch_set_target_queue方法，相当于把queue的优先级设置的和main_queue一致。</p><h5 id=3-scheduler>3. scheduler</h5><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_7.png alt></p><p>以下三个方法实质是同一个方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

+ (RACScheduler <span style=color:#f92672>*</span>)<span style=color:#a6e22e>schedulerWithPriority:</span>(RACSchedulerPriority)priority <span style=color:#a6e22e>name:</span>(NSString <span style=color:#f92672>*</span>)name;
+ (RACScheduler <span style=color:#f92672>*</span>)<span style=color:#a6e22e>schedulerWithPriority:</span>(RACSchedulerPriority)priority;
+ (RACScheduler <span style=color:#f92672>*</span>)<span style=color:#a6e22e>scheduler</span>;

</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>schedulerWithPriority:</span>(RACSchedulerPriority)priority <span style=color:#a6e22e>name:</span>(NSString <span style=color:#f92672>*</span>)name {
    <span style=color:#66d9ef>return</span> [[RACTargetQueueScheduler alloc] initWithName:name targetQueue:dispatch_get_global_queue(priority, <span style=color:#ae81ff>0</span>)];
}

+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>schedulerWithPriority:</span>(RACSchedulerPriority)priority {
    <span style=color:#66d9ef>return</span> [self schedulerWithPriority:priority name:<span style=color:#e6db74>@&#34;com.ReactiveCocoa.RACScheduler.backgroundScheduler&#34;</span>];
}

+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>scheduler</span> {
    <span style=color:#66d9ef>return</span> [self schedulerWithPriority:RACSchedulerPriorityDefault];
}


</code></pre></div><p>通过源码我们能知道，scheduler这一系列的三个方法，是创建了一个 Global Dispatch Queue，对应的属于Concurrent Dispatch Queue。</p><p>schedulerWithPriority: name:方法可以指定线程的优先级和名字。</p><p>schedulerWithPriority:方法只能执行优先级，名字为默认的@&ldquo;com.ReactiveCocoa.RACScheduler.backgroundScheduler&rdquo;。</p><p>scheduler方法创建出来的queue的优先级是默认的，名字也是默认的@&ldquo;com.ReactiveCocoa.RACScheduler.backgroundScheduler&rdquo;。</p><p><strong>注意</strong>，scheduler和mainThreadScheduler，immediateScheduler这两个单例不同的是，scheduler每次都会创建一个新的Concurrent Dispatch Queue。</p><h5 id=4-currentscheduler>4. currentScheduler</h5><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_8.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>currentScheduler</span> {
    RACScheduler <span style=color:#f92672>*</span>scheduler <span style=color:#f92672>=</span> NSThread.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey];
    <span style=color:#66d9ef>if</span> (scheduler <span style=color:#f92672>!=</span> nil) <span style=color:#66d9ef>return</span> scheduler;
    <span style=color:#66d9ef>if</span> ([self.<span style=color:#66d9ef>class</span> isOnMainThread]) <span style=color:#66d9ef>return</span> RACScheduler.mainThreadScheduler;
    <span style=color:#66d9ef>return</span> nil;
}


</code></pre></div><p>首先，在ReactiveCocoa 中定义了这么一个key，@&ldquo;RACSchedulerCurrentSchedulerKey&rdquo;，这个用来从线程字典里面存取出对应的RACScheduler。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
NSString <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> RACSchedulerCurrentSchedulerKey <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;RACSchedulerCurrentSchedulerKey&#34;</span>;

</code></pre></div><p>在currentScheduler这个方法里面看到的是从线程字典里面取出一个RACScheduler。至于什么时候存的，下面会解释到。</p><p>如果能从线程字典里面取出一个RACScheduler，就返回取出的RACScheduler。如果字典里面没有，再判断当前的scheduler是否是在主线程上。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>isOnMainThread</span> {
    <span style=color:#66d9ef>return</span> [NSOperationQueue.currentQueue isEqual:NSOperationQueue.mainQueue] <span style=color:#f92672>||</span> [NSThread isMainThread];
}


</code></pre></div><p>判断方法如上，只要是NSOperationQueue在mainQueue上，或者NSThread是主线程，都算是在主线程上。</p><p>如果是在主线程上，就返回mainThreadScheduler。
如果既不在主线程上，线程字典里面也找不到对应key值对应的value，那么就返回nil。</p><p>RACScheduler除了有6个类方法，还有4个实例方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block;
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>after:</span>(NSDate <span style=color:#f92672>*</span>)date <span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block;
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>afterDelay:</span>(NSTimeInterval)delay <span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block;
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>after:</span>(NSDate <span style=color:#f92672>*</span>)date <span style=color:#a6e22e>repeatingEvery:</span>(NSTimeInterval)interval <span style=color:#a6e22e>withLeeway:</span>(NSTimeInterval)leeway <span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block;


</code></pre></div><p>这4个方法其实从名字上就知道是用来干嘛的。</p><p>schedule:是为RACScheduler添加一个任务，入参是一个闭包。</p><p>after: schedule:是为RACScheduler添加一个定时任务，在date时间之后才执行任务。</p><p>afterDelay: schedule:是为RACScheduler添加一个延时执行的任务，延时delay时间之后才执行任务。</p><p>after: repeatingEvery: withLeeway: schedule:是为RACScheduler添加一个定时任务，在date时间之后才开始执行，然后每隔interval秒执行一次任务。</p><p>这四个方法会分别在RACScheduler的各个子类里面进行重写。</p><p>比如之前提到的immediateScheduler，schedule:方法中会直接立即执行闭包。after: schedule:方法中添加一个定时任务，在date时间之后才执行任务。after: repeatingEvery: withLeeway: schedule:这个方法在RACImmediateScheduler中就直接返回nil。</p><p>还有其他子类在下面会分析这4个方法的实现。</p><p>另外还有最后3个方法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>scheduleRecursiveBlock:</span>(RACSchedulerRecursiveBlock)recursiveBlock;
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>scheduleRecursiveBlock:</span>(RACSchedulerRecursiveBlock)recursiveBlock <span style=color:#a6e22e>addingToDisposable:</span>(RACCompoundDisposable <span style=color:#f92672>*</span>)disposable
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>performAsCurrentScheduler:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block;


</code></pre></div><p>前两个方法是实现RACSequence中signalWithScheduler:方法的，具体分析见<a href=http://www.jianshu.com/p/5c2119b3f2eb>这篇文章</a></p><p>performAsCurrentScheduler:方法是在RACQueueScheduler中使用到了，在下面子类分析里面详细分析。</p><h4 id=二-racscheduler的一些子类>二. RACScheduler的一些子类</h4><p>RACScheduler总共有以下5个子类。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_9.png alt></p><h5 id=1-ractestscheduler>1. RACTestScheduler</h5><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_10.png alt></p><p>这个类主要是一个测试类，主要用在单元测试中，它是用来验证异步调用没有花费大量的时间等待。RACTestScheduler也可以用在多线程当中，当时一次只能在排队的方法队列中选择一个方法执行。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>RACTestSchedulerAction</span> : <span style=color:#a6e22e>NSObject</span>
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>copy</span>, <span style=color:#66d9ef>readonly</span>) NSDate <span style=color:#f92672>*</span>date;
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>copy</span>, <span style=color:#66d9ef>readonly</span>) <span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>block)(<span style=color:#66d9ef>void</span>);
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>, <span style=color:#66d9ef>readonly</span>) RACDisposable <span style=color:#f92672>*</span>disposable;

- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>initWithDate:</span>(NSDate <span style=color:#f92672>*</span>)date <span style=color:#a6e22e>block:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block;
<span style=color:#66d9ef>@end</span>

</code></pre></div><p>在单元测试中，ReactiveCocoa为了方便比较每个方法的调用，新建了一个RACTestSchedulerAction对象，用来更加方便的比较和描述测试的全过程。RACTestSchedulerAction的定义如上。现在再来解释一下参数。</p><p>date是一个时间，时间主要是用来比较和决定下一次该轮到哪个闭包要开始执行了。</p><p>void (^block)(void)闭包是RACScheduler中的一个任务。</p><p>disposable是控制一个action是否可以执行的。一旦disposed了，那么这个action就不会被执行。</p><p>initWithDate: block: 方法是初始化一个新的action。</p><p>在单元测试过程中，需要调用step方法来进行查看每次调用闭包的情况。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>step</span> {
    [self step:<span style=color:#ae81ff>1</span>];
}

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>stepAll</span> {
    [self step:NSUIntegerMax];
}

</code></pre></div><p>step和stepAll方法都是调用step:方法。step只是执行一次RACScheduler中的任务，stepAll是执行所有的RACScheduler中的任务。既然都是调用step:，那接下来分析一下step:的具体实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>step:</span>(NSUInteger)ticks {
    <span style=color:#66d9ef>@synchronized</span> (self) {
        <span style=color:#66d9ef>for</span> (NSUInteger i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ticks; i<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>actionPtr <span style=color:#f92672>=</span> NULL;
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>CFBinaryHeapGetMinimumIfPresent(self.scheduledActions, <span style=color:#f92672>&amp;</span>actionPtr)) <span style=color:#66d9ef>break</span>;
            
            RACTestSchedulerAction <span style=color:#f92672>*</span>action <span style=color:#f92672>=</span> (<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>id</span>)actionPtr;
            CFBinaryHeapRemoveMinimumValue(self.scheduledActions);
            
            <span style=color:#66d9ef>if</span> (action.disposable.disposed) <span style=color:#66d9ef>continue</span>;
            
            RACScheduler <span style=color:#f92672>*</span>previousScheduler <span style=color:#f92672>=</span> RACScheduler.currentScheduler;
            NSThread.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey] <span style=color:#f92672>=</span> self;
            
            action.block();
            
            <span style=color:#66d9ef>if</span> (previousScheduler <span style=color:#f92672>!=</span> nil) {
                NSThread.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey] <span style=color:#f92672>=</span> previousScheduler;
            } <span style=color:#66d9ef>else</span> {
                [NSThread.currentThread.threadDictionary removeObjectForKey:RACSchedulerCurrentSchedulerKey];
            }
        }
    }
}


</code></pre></div><p>step:的实现主要就是一个for循环。循环的次数就是入参ticks决定的。首先const void *actionPtr是一个指向函数的指针。在上述实现中有一个很重要的函数——CFBinaryHeapGetMinimumIfPresent。该函数的原型如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>Boolean</span> CFBinaryHeapGetMinimumIfPresent(CFBinaryHeapRef heap, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>**</span>value)

</code></pre></div><p>这个函数的主要作用的是在二分堆heap中查找一个最小值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> CFComparisonResult <span style=color:#a6e22e>RACCompareScheduledActions</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr1, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr2, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>info) {
    RACTestSchedulerAction <span style=color:#f92672>*</span>action1 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>id</span>)ptr1;
    RACTestSchedulerAction <span style=color:#f92672>*</span>action2 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>id</span>)ptr2;
    <span style=color:#66d9ef>return</span> CFDateCompare((<span style=color:#66d9ef>__bridge</span> CFDateRef)action1.date, (<span style=color:#66d9ef>__bridge</span> CFDateRef)action2.date, NULL);
}

</code></pre></div><p>比较规则如上，就是比较两者的date的值。从二分堆中找出这样一个最小值，对应的就是scheduler中的任务。如果最小值有几个相等最小值，就随机返回一个最小值。返回的函数放在actionPtr中。整个函数的返回值是一个BOOL值，如果二分堆不为空，能找到最小值就返回YES，如果二分堆为空，就找不到最小值了，就返回NO。</p><p>stepAll方法里面传入了NSUIntegerMax，这个for循环也不会死循环，因为到堆中所有的任务都执行完成之后，CFBinaryHeapGetMinimumIfPresent返回NO，就会执行break，跳出循环。</p><p>这里会把currentScheduler保存到线程字典里面。接着会执行action.block，执行任务。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCParameterAssert(block <span style=color:#f92672>!=</span> nil);
    
    <span style=color:#66d9ef>@synchronized</span> (self) {
        NSDate <span style=color:#f92672>*</span>uniqueDate <span style=color:#f92672>=</span> [NSDate dateWithTimeIntervalSinceReferenceDate:self.numberOfDirectlyScheduledBlocks];
        self.numberOfDirectlyScheduledBlocks<span style=color:#f92672>++</span>;
        
        RACTestSchedulerAction <span style=color:#f92672>*</span>action <span style=color:#f92672>=</span> [[RACTestSchedulerAction alloc] initWithDate:uniqueDate block:block];
        CFBinaryHeapAddValue(self.scheduledActions, (<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)action);
        
        <span style=color:#66d9ef>return</span> action.disposable;
    }
}

- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>after:</span>(NSDate <span style=color:#f92672>*</span>)date <span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCParameterAssert(date <span style=color:#f92672>!=</span> nil);
    NSCParameterAssert(block <span style=color:#f92672>!=</span> nil);
    
    <span style=color:#66d9ef>@synchronized</span> (self) {
        RACTestSchedulerAction <span style=color:#f92672>*</span>action <span style=color:#f92672>=</span> [[RACTestSchedulerAction alloc] initWithDate:date block:block];
        CFBinaryHeapAddValue(self.scheduledActions, (<span style=color:#66d9ef>__bridge</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)action);
        
        <span style=color:#66d9ef>return</span> action.disposable;
    }
}


</code></pre></div><p>schedule:方法里面会累加numberOfDirectlyScheduledBlocks值，这个值也会初始化成时间，以便比较各个方法该调度的时间。numberOfDirectlyScheduledBlocks最终会代表总共有多少个block任务产生了。然后用CFBinaryHeapAddValue加入到堆中。</p><p>after:schedule:就是直接新建RACTestSchedulerAction对象，然后再用CFBinaryHeapAddValue把block闭包加入到堆中。</p><p>after: repeatingEvery: withLeeway: schedule:同样也是新建RACTestSchedulerAction对象，然后再用CFBinaryHeapAddValue把block闭包加入到堆中。</p><h5 id=2-racsubscriptionscheduler>2. RACSubscriptionScheduler</h5><p>RACSubscriptionScheduler是RACScheduler最后一个单例。RACScheduler中唯一的三个单例现在就齐全了：RACImmediateScheduler，RACTargetQueueScheduler ，RACSubscriptionScheduler。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

+ (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>subscriptionScheduler</span> {
    <span style=color:#66d9ef>static</span> dispatch_once_t onceToken;
    <span style=color:#66d9ef>static</span> RACScheduler <span style=color:#f92672>*</span>subscriptionScheduler;
    dispatch_once(<span style=color:#f92672>&amp;</span>onceToken, <span style=color:#f92672>^</span>{
        subscriptionScheduler <span style=color:#f92672>=</span> [[RACSubscriptionScheduler alloc] init];
    });
    
    <span style=color:#66d9ef>return</span> subscriptionScheduler;
}

</code></pre></div><p>RACSubscriptionScheduler 的名字是@&ldquo;com.ReactiveCocoa.RACScheduler.subscriptionScheduler&rdquo;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>init</span> {
    self <span style=color:#f92672>=</span> [super initWithName:<span style=color:#e6db74>@&#34;com.ReactiveCocoa.RACScheduler.subscriptionScheduler&#34;</span>];
    <span style=color:#66d9ef>if</span> (self <span style=color:#f92672>==</span> nil) <span style=color:#66d9ef>return</span> nil;
    _backgroundScheduler <span style=color:#f92672>=</span> [RACScheduler scheduler];  
    <span style=color:#66d9ef>return</span> self;
}

</code></pre></div><p>RACSubscriptionScheduler初始化的时候会新建一个Global Dispatch Queue。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCParameterAssert(block <span style=color:#f92672>!=</span> NULL);
    <span style=color:#66d9ef>if</span> (RACScheduler.currentScheduler <span style=color:#f92672>==</span> nil) <span style=color:#66d9ef>return</span> [self.backgroundScheduler schedule:block];
    block();
    <span style=color:#66d9ef>return</span> nil;
}

</code></pre></div><p>如果RACScheduler.currentScheduler为nil就用backgroundScheduler去调用block闭包，否则就执行block闭包。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>after:</span>(NSDate <span style=color:#f92672>*</span>)date <span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    RACScheduler <span style=color:#f92672>*</span>scheduler <span style=color:#f92672>=</span> RACScheduler.currentScheduler <span style=color:#f92672>?:</span> self.backgroundScheduler;
    <span style=color:#66d9ef>return</span> [scheduler after:date schedule:block];
}

</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>after:</span>(NSDate <span style=color:#f92672>*</span>)date <span style=color:#a6e22e>repeatingEvery:</span>(NSTimeInterval)interval <span style=color:#a6e22e>withLeeway:</span>(NSTimeInterval)leeway <span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    RACScheduler <span style=color:#f92672>*</span>scheduler <span style=color:#f92672>=</span> RACScheduler.currentScheduler <span style=color:#f92672>?:</span> self.backgroundScheduler;
    <span style=color:#66d9ef>return</span> [scheduler after:date repeatingEvery:interval withLeeway:leeway schedule:block];
}



</code></pre></div><p>两个after方法都有取出RACScheduler.currentScheduler，如果为空就用self.backgroundScheduler去调用各自的after的方法。</p><p>RACSubscriptionScheduler中的backgroundScheduler的意义就在此，当RACScheduler.currentScheduler不存在的时候就会替换成self.backgroundScheduler。</p><h5 id=3-racimmediatescheduler>3. RACImmediateScheduler</h5><p>这个子类在分析immediateScheduler方法的时候，详细分析过了，这里不再赘述。</p><h5 id=4-racqueuescheduler>4. RACQueueScheduler</h5><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_11.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCParameterAssert(block <span style=color:#f92672>!=</span> NULL);
    
    RACDisposable <span style=color:#f92672>*</span>disposable <span style=color:#f92672>=</span> [[RACDisposable alloc] init];
    
    dispatch_async(self.queue, <span style=color:#f92672>^</span>{
        <span style=color:#66d9ef>if</span> (disposable.disposed) <span style=color:#66d9ef>return</span>;
        [self performAsCurrentScheduler:block];
    });
    
    <span style=color:#66d9ef>return</span> disposable;
}

</code></pre></div><p>schedule:会调用performAsCurrentScheduler:方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>performAsCurrentScheduler:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCParameterAssert(block <span style=color:#f92672>!=</span> NULL);
    
    RACScheduler <span style=color:#f92672>*</span>previousScheduler <span style=color:#f92672>=</span> RACScheduler.currentScheduler;
    NSThread.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey] <span style=color:#f92672>=</span> self;
    
    <span style=color:#66d9ef>@autoreleasepool</span> {
        block();
    }
    
    <span style=color:#66d9ef>if</span> (previousScheduler <span style=color:#f92672>!=</span> nil) {
        NSThread.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey] <span style=color:#f92672>=</span> previousScheduler;
    } <span style=color:#66d9ef>else</span> {
        [NSThread.currentThread.threadDictionary removeObjectForKey:RACSchedulerCurrentSchedulerKey];
    }
}



</code></pre></div><p>performAsCurrentScheduler:方法会先在调用block( )之前，把当前的scheduler存入线程字典中。</p><p>试想，如果现在在一个Concurrent Dispatch Queue中，在执行block( )之前需要先切换线程，切换到当前scheduler中。当执行完block闭包之后，previousScheduler如果不为nil，那么就还原现场，线程字典里面再存回原来的scheduler，反之previousScheduler为nil，那么就移除掉线程字典里面的key。</p><p>这里需要值得<strong>注意</strong>的是：</p><p>scheduler本质其实是一个quene，并不是一个线程。它只能保证里面的线程都是串行执行的，但是它不能保证每个线程不一定都是在同一个线程里面执行。</p><p>如上面这段performAsCurrentScheduler:的实现所表现的那样。所以
在scheduler使用Core Data很容易崩溃，很可能跑到子线程上面去了。一旦写数据的时候到了子线程上，很容易就Crash了。一定要记得回到main queue上。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>after:</span>(NSDate <span style=color:#f92672>*</span>)date <span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCParameterAssert(date <span style=color:#f92672>!=</span> nil);
    NSCParameterAssert(block <span style=color:#f92672>!=</span> NULL);
    
    RACDisposable <span style=color:#f92672>*</span>disposable <span style=color:#f92672>=</span> [[RACDisposable alloc] init];
    
    dispatch_after([self.<span style=color:#66d9ef>class</span> wallTimeWithDate:date], self.queue, <span style=color:#f92672>^</span>{
        <span style=color:#66d9ef>if</span> (disposable.disposed) <span style=color:#66d9ef>return</span>;
        [self performAsCurrentScheduler:block];
    });
    
    <span style=color:#66d9ef>return</span> disposable;
}

</code></pre></div><p>在after中调用dispatch_after方法，经过date时间之后再调用performAsCurrentScheduler:。</p><p>wallTimeWithDate:的实现如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (dispatch_time_t)<span style=color:#a6e22e>wallTimeWithDate:</span>(NSDate <span style=color:#f92672>*</span>)date {
    NSCParameterAssert(date <span style=color:#f92672>!=</span> nil);
    
    <span style=color:#66d9ef>double</span> seconds <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>double</span> frac <span style=color:#f92672>=</span> modf(date.timeIntervalSince1970, <span style=color:#f92672>&amp;</span>seconds);
    
    <span style=color:#66d9ef>struct</span> timespec walltime <span style=color:#f92672>=</span> {
        .tv_sec <span style=color:#f92672>=</span> (time_t)fmin(fmax(seconds, LONG_MIN), LONG_MAX),
        .tv_nsec <span style=color:#f92672>=</span> (<span style=color:#66d9ef>long</span>)fmin(fmax(frac <span style=color:#f92672>*</span> NSEC_PER_SEC, LONG_MIN), LONG_MAX)
    };
    
    <span style=color:#66d9ef>return</span> dispatch_walltime(<span style=color:#f92672>&amp;</span>walltime, <span style=color:#ae81ff>0</span>);
}

</code></pre></div><p>dispatch_walltime函数是由POSIX中使用的struct timespec类型的时间得到dispatch_time_t类型的值。dispatch_time函数通常用于计算相对时间，而dispatch_walltime函数用于计算绝对时间。</p><p>这段代码其实很简单，就是把date的时间转换成一个dispatch_time_t类型的。由NSDate类对象获取能传递给dispatch_after函数的dispatch_time_t类型的值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>after:</span>(NSDate <span style=color:#f92672>*</span>)date <span style=color:#a6e22e>repeatingEvery:</span>(NSTimeInterval)interval <span style=color:#a6e22e>withLeeway:</span>(NSTimeInterval)leeway <span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCParameterAssert(date <span style=color:#f92672>!=</span> nil);
    NSCParameterAssert(interval <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.0</span> <span style=color:#f92672>&amp;&amp;</span> interval <span style=color:#f92672>&lt;</span> INT64_MAX <span style=color:#f92672>/</span> NSEC_PER_SEC);
    NSCParameterAssert(leeway <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.0</span> <span style=color:#f92672>&amp;&amp;</span> leeway <span style=color:#f92672>&lt;</span> INT64_MAX <span style=color:#f92672>/</span> NSEC_PER_SEC);
    NSCParameterAssert(block <span style=color:#f92672>!=</span> NULL);
    
    uint64_t intervalInNanoSecs <span style=color:#f92672>=</span> (uint64_t)(interval <span style=color:#f92672>*</span> NSEC_PER_SEC);
    uint64_t leewayInNanoSecs <span style=color:#f92672>=</span> (uint64_t)(leeway <span style=color:#f92672>*</span> NSEC_PER_SEC);
    
    dispatch_source_t timer <span style=color:#f92672>=</span> dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, self.queue);
    dispatch_source_set_timer(timer, [self.<span style=color:#66d9ef>class</span> wallTimeWithDate:date], intervalInNanoSecs, leewayInNanoSecs);
    dispatch_source_set_event_handler(timer, block);
    dispatch_resume(timer);
    
    <span style=color:#66d9ef>return</span> [RACDisposable disposableWithBlock:<span style=color:#f92672>^</span>{
        dispatch_source_cancel(timer);
    }];
}



</code></pre></div><p>after: repeatingEvery: withLeeway: schedule:方法里面的实现就是用GCD在self.queue上创建了一个Timer，时间间隔是interval，修正时间是leeway。</p><p>leeway这个参数是为dispatch source指定一个期望的定时器事件精度，让系统能够灵活地管理并唤醒内核。例如系统可以使用leeway值来提前或延迟触发定时器，使其更好地与其它系统事件结合。创建自己的定时器时，应该尽量指定一个leeway值。不过就算指定leeway值为0，也不能完完全全期望定时器能够按照精确的纳秒来触发事件。</p><p>这个定时器在interval执行入参闭包。在取消任务的时候调用dispatch_source_cancel取消定时器timer。</p><h5 id=5-ractargetqueuescheduler>5. RACTargetQueueScheduler</h5><p>这个子类在分析mainThreadScheduler方法的时候，详细分析过了，这里不再赘述。</p><h4 id=三-racscheduler是如何取消并发任务的>三. RACScheduler是如何“取消”并发任务的</h4><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_12.png alt></p><p>既然RACScheduler是对GCD的封装，那么在GCD的上层可以实现一些GCD所无法完成的“特性”。这里的“特性”是打引号的，因为底层是GCD，上层的特性只能通过一些特殊手段来实现看似是新的特性。在这一点上，RACScheduler就实现了GCD没有的特性——“取消”任务。</p><p>Operation Queues ：
相对 GCD来说，使用 Operation Queues 会增加一点点额外的开销，但是却换来了非常强大的灵活性和功能，它可以给 operation 之间添加依赖关系、取消一个正在执行的 operation 、暂停和恢复 operation queue 等；</p><p>GCD：
是一种更轻量级的，以 FIFO的顺序执行并发任务的方式，使用 GCD时我们可以并不关心任务的调度情况，而让系统帮我们自动处理。但是 GCD的缺陷也是非常明显的，想要给任务之间添加依赖关系、取消或者暂停一个正在执行的任务时就会变得非常棘手。</p><p>既然GCD不方便取消一个任务，那么RACScheduler是怎么做到的呢？</p><p>这就体现在RACQueueScheduler上。回头看看RACQueueScheduler的schedule:实现 和 after: schedule:实现。</p><p>最核心的代码:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
 dispatch_async(self.queue, <span style=color:#f92672>^</span>{
      <span style=color:#66d9ef>if</span> (disposable.disposed) <span style=color:#66d9ef>return</span>;
      [self performAsCurrentScheduler:block];
 });

</code></pre></div><p>在调用performAsCurrentScheduler:之前，加了一个判断，判断当前是否取消了任务，如果取消了任务，就return，不会调用block闭包。这样就实现了取消任务的“假象”。</p><h4 id=四-racscheduler是如何和rac其他组件进行完美整合的>四. RACScheduler是如何和RAC其他组件进行完美整合的</h4><p>在整个ReactiveCocoa中，利用RACScheduler实现了很多操作，和RAC是深度整合的。这里就来总结总结ReactiveCocoa中总共有哪些地方用到了RACScheduler。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/37_13.png alt></p><p>在ReactiveCocoa 中全局搜索RACScheduler，遍历完所有库，RACScheduler就用在以下10个类中。下面就来看看是如何用在这些地方的。</p><p>从下面这些地方使用了Scheduler中，我们就可以了解到哪些操作是在子线程，哪些是在主线程。区分出了这些，对于线程不安全的操作，我们就能心有成足的处理好它们，让它们回到主线程中去操作，这样就可以减少很多莫名的Crash。这些Crash都是因为线程问题导致的。</p><h5 id=1-在raccommand中>1. 在RACCommand中</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>initWithEnabled:</span>(RACSignal <span style=color:#f92672>*</span>)enabledSignal <span style=color:#a6e22e>signalBlock:</span>(RACSignal <span style=color:#f92672>*</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>id</span> input))signalBlock


</code></pre></div><p>这个方法十分复杂，里面用到了RACScheduler.immediateScheduler，deliverOn:RACScheduler.mainThreadScheduler。具体的源码分析会在下一篇RACCommand源码分析里面详细分析。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>execute:</span>(<span style=color:#66d9ef>id</span>)input

</code></pre></div><p>在这个方法中，会调用subscribeOn:RACScheduler.mainThreadScheduler。</p><h5 id=2-在racdynamicsignal中>2. 在RACDynamicSignal中</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>subscribe:</span>(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>RACSubscriber<span style=color:#f92672>&gt;</span>)subscriber {
    NSCParameterAssert(subscriber <span style=color:#f92672>!=</span> nil);
    
    RACCompoundDisposable <span style=color:#f92672>*</span>disposable <span style=color:#f92672>=</span> [RACCompoundDisposable compoundDisposable];
    subscriber <span style=color:#f92672>=</span> [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];
    
    <span style=color:#66d9ef>if</span> (self.didSubscribe <span style=color:#f92672>!=</span> NULL) {
        RACDisposable <span style=color:#f92672>*</span>schedulingDisposable <span style=color:#f92672>=</span> [RACScheduler.subscriptionScheduler schedule:<span style=color:#f92672>^</span>{
            RACDisposable <span style=color:#f92672>*</span>innerDisposable <span style=color:#f92672>=</span> self.didSubscribe(subscriber);
            [disposable addDisposable:innerDisposable];
        }];
        
        [disposable addDisposable:schedulingDisposable];
    }
    
    <span style=color:#66d9ef>return</span> disposable;
}

</code></pre></div><p>在RACDynamicSignal的subscribe:订阅过程中会用到subscriptionScheduler。于是对这个scheduler调用schedule:就会执行下面这段代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCParameterAssert(block <span style=color:#f92672>!=</span> NULL);
    
    <span style=color:#66d9ef>if</span> (RACScheduler.currentScheduler <span style=color:#f92672>==</span> nil) <span style=color:#66d9ef>return</span> [self.backgroundScheduler schedule:block];
    
    block();
    <span style=color:#66d9ef>return</span> nil;
}

</code></pre></div><p>如果currentScheduler不为空，闭包会在currentScheduler中执行，如果currentScheduler为空，闭包就会在backgroundScheduler中执行，这是一个Global Dispatch Queue，优先级是RACSchedulerPriorityDefault。</p><p>同理，在RACEmptySignal，RACErrorSignal，RACReturnSignal，RACSignal的相关的signal的订阅中也都会调用subscriptionScheduler。</p><h5 id=3-在racbehaviorsubject中>3. 在RACBehaviorSubject中</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>subscribe:</span>(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>RACSubscriber<span style=color:#f92672>&gt;</span>)subscriber {
    RACDisposable <span style=color:#f92672>*</span>subscriptionDisposable <span style=color:#f92672>=</span> [super subscribe:subscriber];
    
    RACDisposable <span style=color:#f92672>*</span>schedulingDisposable <span style=color:#f92672>=</span> [RACScheduler.subscriptionScheduler schedule:<span style=color:#f92672>^</span>{
        <span style=color:#66d9ef>@synchronized</span> (self) {
            [subscriber sendNext:self.currentValue];
        }
    }];
    
    <span style=color:#66d9ef>return</span> [RACDisposable disposableWithBlock:<span style=color:#f92672>^</span>{
        [subscriptionDisposable dispose];
        [schedulingDisposable dispose];
    }];
}


</code></pre></div><p>在RACBehaviorSubject的subscribe:订阅过程中会用到subscriptionScheduler。于是对这个scheduler调用schedule:，代码在上面分析过了。</p><p>同理，如果currentScheduler不为空，闭包会在currentScheduler中执行，如果currentScheduler为空，闭包就会在backgroundScheduler中执行，这是一个Global Dispatch Queue，优先级是RACSchedulerPriorityDefault。</p><h5 id=4-在racreplaysubject中>4. 在RACReplaySubject中</h5><p>它的订阅也同上面信号的订阅一样，会调用subscriptionScheduler。</p><p>由于RACReplaySubject是在子线程上，所以建议<strong>在使用Core Data这些不安全库的时候一定要记得加上deliverOn。</strong></p><h5 id=5-在racsequence中>5. 在RACSequence中</h5><p>在RACSequence中，以下两个方法用到了RACScheduler：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>signal</span> {
    <span style=color:#66d9ef>return</span> [[self signalWithScheduler:[RACScheduler scheduler]] setNameWithFormat:<span style=color:#e6db74>@&#34;[%@] -signal&#34;</span>, self.name];
}


</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>signalWithScheduler:</span>(RACScheduler <span style=color:#f92672>*</span>)scheduler {
    <span style=color:#66d9ef>return</span> [[RACSignal createSignal:<span style=color:#f92672>^</span>(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>RACSubscriber<span style=color:#f92672>&gt;</span> subscriber) {
        <span style=color:#66d9ef>__block</span> RACSequence <span style=color:#f92672>*</span>sequence <span style=color:#f92672>=</span> self;
        
        <span style=color:#66d9ef>return</span> [scheduler scheduleRecursiveBlock:<span style=color:#f92672>^</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>reschedule)(<span style=color:#66d9ef>void</span>)) {
            <span style=color:#66d9ef>if</span> (sequence.head <span style=color:#f92672>==</span> nil) {
                [subscriber sendCompleted];
                <span style=color:#66d9ef>return</span>;
            }
            
            [subscriber sendNext:sequence.head];
            
            sequence <span style=color:#f92672>=</span> sequence.tail;
            reschedule();
        }];
    }] setNameWithFormat:<span style=color:#e6db74>@&#34;[%@] -signalWithScheduler: %@&#34;</span>, self.name, scheduler];
}


</code></pre></div><p>上面两个方法会调用RACScheduler中的scheduleRecursiveBlock:方法。关于这个方法的源码分析可以看<a href=http://www.jianshu.com/p/5c2119b3f2eb>RACSequence的源码分析</a>。</p><h5 id=6-在racsignaloperations中>6. 在RACSignal+Operations中</h5><p>这里总共有9个方法用到了Scheduler。</p><p>第一个方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>static</span> RACDisposable <span style=color:#f92672>*</span>subscribeForever (RACSignal <span style=color:#f92672>*</span>signal, <span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>next)(<span style=color:#66d9ef>id</span>), <span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>error)(NSError <span style=color:#f92672>*</span>, RACDisposable <span style=color:#f92672>*</span>), <span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>completed)(RACDisposable <span style=color:#f92672>*</span>))

</code></pre></div><p>在上面这个方法里面用到了</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
RACScheduler <span style=color:#f92672>*</span>recursiveScheduler <span style=color:#f92672>=</span> RACScheduler.currentScheduler <span style=color:#f92672>?:</span> [RACScheduler scheduler];

</code></pre></div><p>取出currentScheduler或者一个Global Dispatch Queue，然后调用scheduleRecursiveBlock:。</p><p>第二个方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>throttle:</span>(NSTimeInterval)interval <span style=color:#a6e22e>valuesPassingTest:</span>(<span style=color:#66d9ef>BOOL</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>id</span> next))predicate

</code></pre></div><p>在上面这个方法中会调用</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
RACScheduler <span style=color:#f92672>*</span>scheduler <span style=color:#f92672>=</span> [RACScheduler scheduler];
RACScheduler <span style=color:#f92672>*</span>delayScheduler <span style=color:#f92672>=</span> RACScheduler.currentScheduler <span style=color:#f92672>?:</span> scheduler

</code></pre></div><p>在delayScheduler中调用afterDelay: schedule:方法，这也是throttle:valuesPassingTest:方法实现的很重要的一步。</p><p>第三个方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>delay:</span>(NSTimeInterval)interval

</code></pre></div><p>由于这是一个延迟方法，肯定是会调用Scheduler的after方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
   RACScheduler <span style=color:#f92672>*</span>delayScheduler <span style=color:#f92672>=</span> RACScheduler.currentScheduler <span style=color:#f92672>?:</span> scheduler;
   RACDisposable <span style=color:#f92672>*</span>schedulerDisposable <span style=color:#f92672>=</span> [delayScheduler afterDelay:interval schedule:block];

</code></pre></div><p>RACScheduler.currentScheduler ?: scheduler 这个判断在上述几个时间相关的方法都用到了。</p><p>所以，这里给一个建议：<strong>delay由于不一定会回到当前线程中，所以delay之后再去订阅可能就在子线程中去执行。所以使用delay的时候最好追加一个deliverOn。</strong></p><p>第四个方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>bufferWithTime:</span>(NSTimeInterval)interval <span style=color:#a6e22e>onScheduler:</span>(RACScheduler <span style=color:#f92672>*</span>)scheduler

</code></pre></div><p>在这个方法中理所当然的需要调用[scheduler afterDelay:interval schedule:flushValues]这个方法，来达到延迟的目的，从而实现缓冲buffer的效果。</p><p>第五个方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>interval:</span>(NSTimeInterval)interval <span style=color:#a6e22e>onScheduler:</span>(RACScheduler <span style=color:#f92672>*</span>)scheduler

</code></pre></div><p>第六个方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>interval:</span>(NSTimeInterval)interval <span style=color:#a6e22e>onScheduler:</span>(RACScheduler <span style=color:#f92672>*</span>)scheduler <span style=color:#a6e22e>withLeeway:</span>(NSTimeInterval)leeway { }

</code></pre></div><p>第五个方法 和 第六个方法都用传进去的入参scheduler去调用after: repeatingEvery: withLeeway: schedule:方法。</p><p>第七个方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>timeout:</span>(NSTimeInterval)interval <span style=color:#a6e22e>onScheduler:</span>(RACScheduler <span style=color:#f92672>*</span>)scheduler { }

</code></pre></div><p>在这个方法中会用入参scheduler调用afterDelay: schedule:，延迟一段时候后，执行[disposable dispose]，从而也实现了超时发送sendError:。</p><p>第八个方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>deliverOn:</span>(RACScheduler <span style=color:#f92672>*</span>)scheduler { }

</code></pre></div><p>第九个方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>subscribeOn:</span>(RACScheduler <span style=color:#f92672>*</span>)scheduler { }

</code></pre></div><p>第八个方法 和 第九个方法都是根据入参scheduler去调用schedule:方法。入参是什么类型的scheduler决定了schedule:执行在哪个queue上。</p><h5 id=7-在racsignal中>7. 在RACSignal中</h5><p>在RACSignal也有积极计算和惰性求值的信号。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>startEagerlyWithScheduler:</span>(RACScheduler <span style=color:#f92672>*</span>)scheduler <span style=color:#a6e22e>block:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>RACSubscriber<span style=color:#f92672>&gt;</span> subscriber))block {
    NSCParameterAssert(scheduler <span style=color:#f92672>!=</span> nil);
    NSCParameterAssert(block <span style=color:#f92672>!=</span> NULL);
    
    RACSignal <span style=color:#f92672>*</span>signal <span style=color:#f92672>=</span> [self startLazilyWithScheduler:scheduler block:block];
    [[signal publish] connect];
    <span style=color:#66d9ef>return</span> [signal setNameWithFormat:<span style=color:#e6db74>@&#34;+startEagerlyWithScheduler: %@ block:&#34;</span>, scheduler];
}


</code></pre></div><p>startEagerlyWithScheduler中会调用startLazilyWithScheduler产生一个信号signal，然后紧接着转换成热信号。通过startEagerlyWithScheduler产生的信号就直接是一个热信号。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>startLazilyWithScheduler:</span>(RACScheduler <span style=color:#f92672>*</span>)scheduler <span style=color:#a6e22e>block:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>RACSubscriber<span style=color:#f92672>&gt;</span> subscriber))block {
    NSCParameterAssert(scheduler <span style=color:#f92672>!=</span> nil);
    NSCParameterAssert(block <span style=color:#f92672>!=</span> NULL);
    
    RACMulticastConnection <span style=color:#f92672>*</span>connection <span style=color:#f92672>=</span> [[RACSignal
                                           createSignal:<span style=color:#f92672>^</span> <span style=color:#66d9ef>id</span> (<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>RACSubscriber<span style=color:#f92672>&gt;</span> subscriber) {
                                               block(subscriber);
                                               <span style=color:#66d9ef>return</span> nil;
                                           }]
                                          multicast:[RACReplaySubject subject]];
    
    <span style=color:#66d9ef>return</span> [[[RACSignal
              createSignal:<span style=color:#f92672>^</span> <span style=color:#66d9ef>id</span> (<span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span>RACSubscriber<span style=color:#f92672>&gt;</span> subscriber) {
                  [connection.signal subscribe:subscriber];
                  [connection connect];
                  <span style=color:#66d9ef>return</span> nil;
              }]
             subscribeOn:scheduler]
            setNameWithFormat:<span style=color:#e6db74>@&#34;+startLazilyWithScheduler: %@ block:&#34;</span>, scheduler];
}

</code></pre></div><p>上述是startLazilyWithScheduler:的源码实现，在这个方法中和startEagerlyWithScheduler最大的区别就出来了，connect方法在return的信号中，所以Lazily就体现在，通过startLazilyWithScheduler建立出来的信号，只有订阅它之后才能调用到connect，转变成热信号。</p><p>在这里调用了subscribeOn:scheduler，这里用到了scheduler。</p><h5 id=8-在nsdataracsupport中>8. 在NSData+RACSupport中</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>rac_readContentsOfURL:</span>(NSURL <span style=color:#f92672>*</span>)URL <span style=color:#a6e22e>options:</span>(NSDataReadingOptions)options <span style=color:#a6e22e>scheduler:</span>(RACScheduler <span style=color:#f92672>*</span>)scheduler {
    NSCParameterAssert(scheduler <span style=color:#f92672>!=</span> nil);
    
    RACReplaySubject <span style=color:#f92672>*</span>subject <span style=color:#f92672>=</span> [RACReplaySubject subject];
    [subject setNameWithFormat:<span style=color:#e6db74>@&#34;+rac_readContentsOfURL: %@ options: %lu scheduler: %@&#34;</span>, URL, (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)options, scheduler];
    
    [scheduler schedule:<span style=color:#f92672>^</span>{
        NSError <span style=color:#f92672>*</span>error <span style=color:#f92672>=</span> nil;
        NSData <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> [[NSData alloc] initWithContentsOfURL:URL options:options error:<span style=color:#f92672>&amp;</span>error];
        <span style=color:#66d9ef>if</span> (data <span style=color:#f92672>==</span> nil) {
            [subject sendError:error];
        } <span style=color:#66d9ef>else</span> {
            [subject sendNext:data];
            [subject sendCompleted];
        }
    }];
    
    <span style=color:#66d9ef>return</span> subject;
}


</code></pre></div><p>在这个方法中，会传入RACQueueScheduler或者RACTargetQueueScheduler的RACScheduler。那么调用schedule方法就会执行到这里：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (RACDisposable <span style=color:#f92672>*</span>)<span style=color:#a6e22e>schedule:</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block {
    NSCParameterAssert(block <span style=color:#f92672>!=</span> NULL);
    
    RACDisposable <span style=color:#f92672>*</span>disposable <span style=color:#f92672>=</span> [[RACDisposable alloc] init];
    
    dispatch_async(self.queue, <span style=color:#f92672>^</span>{
        <span style=color:#66d9ef>if</span> (disposable.disposed) <span style=color:#66d9ef>return</span>;
        [self performAsCurrentScheduler:block];
    });
    
    <span style=color:#66d9ef>return</span> disposable;
}


</code></pre></div><h5 id=9-在nsstringracsupport中>9. 在NSString+RACSupport中</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
+ (RACSignal <span style=color:#f92672>*</span>)<span style=color:#a6e22e>rac_readContentsOfURL:</span>(NSURL <span style=color:#f92672>*</span>)URL <span style=color:#a6e22e>usedEncoding:</span>(NSStringEncoding <span style=color:#f92672>*</span>)encoding <span style=color:#a6e22e>scheduler:</span>(RACScheduler <span style=color:#f92672>*</span>)scheduler {
    NSCParameterAssert(scheduler <span style=color:#f92672>!=</span> nil);
    
    RACReplaySubject <span style=color:#f92672>*</span>subject <span style=color:#f92672>=</span> [RACReplaySubject subject];
    [subject setNameWithFormat:<span style=color:#e6db74>@&#34;+rac_readContentsOfURL: %@ usedEncoding:scheduler: %@&#34;</span>, URL, scheduler];
    
    [scheduler schedule:<span style=color:#f92672>^</span>{
        NSError <span style=color:#f92672>*</span>error <span style=color:#f92672>=</span> nil;
        NSString <span style=color:#f92672>*</span>string <span style=color:#f92672>=</span> [NSString stringWithContentsOfURL:URL usedEncoding:encoding error:<span style=color:#f92672>&amp;</span>error];
        <span style=color:#66d9ef>if</span> (string <span style=color:#f92672>==</span> nil) {
            [subject sendError:error];
        } <span style=color:#66d9ef>else</span> {
            [subject sendNext:string];
            [subject sendCompleted];
        }
    }];
    
    <span style=color:#66d9ef>return</span> subject;
}


</code></pre></div><p>同NSData+RACSupport中的rac_readContentsOfURL: options: scheduler:一样，也会传入RACQueueScheduler或者RACTargetQueueScheduler的RACScheduler。</p><h5 id=10-在nsuserdefaultsracsupport中>10. 在NSUserDefaults+RACSupport中</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
RACScheduler <span style=color:#f92672>*</span>scheduler <span style=color:#f92672>=</span> [RACScheduler scheduler];

</code></pre></div><p>在这个方法中也会新建RACTargetQueueScheduler，一个Global Dispatch Queue。优先级是RACSchedulerPriorityDefault。</p><h3 id=最后>最后</h3><p>关于RACScheduler底层实现分析都已经分析完成。最后请大家多多指教。</p><img src=https://img.halfrost.com/wechat-qr-code.png></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div id=toc-footer style=display:none><nav id=TableOfContents><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#目录>目录</a><ul><li><a href=#一-racscheduler是如何封装gcd的>一. RACScheduler是如何封装GCD的</a></li><li><a href=#二-racscheduler的一些子类>二. RACScheduler的一些子类</a></li><li><a href=#三-racscheduler是如何取消并发任务的>三. RACScheduler是如何“取消”并发任务的</a></li><li><a href=#四-racscheduler是如何和rac其他组件进行完美整合的>四. RACScheduler是如何和RAC其他组件进行完美整合的</a></li></ul></li><li><a href=#最后>最后</a></li></ul></li></ul></nav></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f"><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&text=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&title=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&is_video=false&description=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f"><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&title=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&title=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&title=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-stumbleupon fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&title=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-digg fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&name=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84&description=%e5%89%8d%e8%a8%80%20%e5%9c%a8%e4%bd%bf%e7%94%a8ReactiveCocoa%20%e8%bf%87%e7%a8%8b%e4%b8%ad%ef%bc%8cJosh%20Abernathy%e5%92%8cJustin%20Spahr-Summers%20%e4%b8%a4%e4%bd%8d%e5%a4%a7%e7%a5%9e%e4%b8%ba%e4%ba%86%e8%83%bd%e8%ae%a9RAC%e7%9a%84%e4%bd%bf%e7%94%a8%e8%80%85%e6%9b%b4%e7%95%85%e5%bf%ab%e7%9a%84%e5%9c%a8%e6%b2%89%e6%b5%b8%e5%9c%a8FRP%e7%9a%84%e4%b8%96%e7%95%8c%e9%87%8c%ef%bc%8c%e6%9b%b4%e5%a5%bd%e7%9a%84%e8%bf%9b%e8%a1%8c%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%ef%bc%8c%e4%ba%8e%e6%98%af%e5%b0%b1%e5%af%b9GCD%e8%bf%9b%e8%a1%8c%e4%ba%86%e4%b8%80%e6%ac%a1%e5%b0%81%e8%a3%85%ef%bc%8c%e5%b9%b6%e4%b8%8eRAC%e7%9a%84%e5%90%84%e5%a4%a7%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e4%ba%86%e5%ae%8c%e7%be%8e%e7%9a%84%e6%95%b4%e5%90%88%e3%80%82%0a%e8%87%aa%e4%bb%8e%e6%9c%89%e4%ba%86RACScheduler%e4%bb%a5%e5%90%8e%ef%bc%8c%e4%bd%bf%e6%95%b4%e4%b8%aaRAC%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e7%9a%84%e4%bb%a3%e7%a0%81%e9%87%8c%e9%9d%a2%e6%9b%b4%e5%8a%a0%e5%92%8c%e8%b0%90%e7%bb%9f%e4%b8%80%ef%bc%8c%e6%9b%b4%e5%8a%a0%e9%a1%ba%e6%89%8b%ef%bc%8c%e6%9b%b4%e5%8a%a0%e2%80%9cReactiveCocoa%e2%80%9d%e3%80%82%0a%e7%9b%ae%e5%bd%95%20%201.RACScheduler%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85GCD%e7%9a%84%202.RACScheduler%e7%9a%84%e4%b8%80%e4%ba%9b%e5%ad%90%e7%b1%bb%203.RACScheduler%e6%98%af%e5%a6%82%e4%bd%95%e2%80%9c%e5%8f%96%e6%b6%88%e2%80%9d%e5%b9%b6%e5%8f%91%e4%bb%bb%e5%8a%a1%e7%9a%84%204.RACScheduler%e6%98%af%e5%a6%82%e4%bd%95%e5%92%8cRAC%e5%85%b6%e4%bb%96%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e5%ae%8c%e7%be%8e%e6%95%b4%e5%90%88%e7%9a%84%20%20%e4%b8%80.%20RACScheduler%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85GCD%e7%9a%84%20RACScheduler%e5%9c%a8ReactiveCocoa%e4%b8%ad%e5%88%b0%e5%ba%95%e6%98%af%e5%b9%b2%e5%98%9b%e7%9a%84%e5%91%a2%ef%bc%9f%e5%a4%84%e4%ba%8e%e4%bb%80%e4%b9%88%e5%9c%b0%e4%bd%8d%e5%91%a2%ef%bc%9f%e5%ae%98%e6%96%b9%e7%bb%99%e5%87%ba%e7%9a%84%e5%ae%9a%e4%b9%89%e5%a6%82%e4%b8%8b%ef%bc%9a%0aSchedulers%20are%20used%20to%20control%20when%20and%20where%20work%20is%20performedRACScheduler%e5%9c%a8ReactiveCocoa%e4%b8%ad%e6%98%af%e7%94%a8%e6%9d%a5%e6%8e%a7%e5%88%b6%e4%b8%80%e4%b8%aa%e4%bb%bb%e5%8a%a1%ef%bc%8c%e4%bd%95%e6%97%b6%e4%bd%95%e5%9c%b0%e8%a2%ab%e6%89%a7%e8%a1%8c%e3%80%82%e5%ae%83%e4%b8%bb%e8%a6%81%e6%98%af%e7%94%a8%e6%9d%a5%e8%a7%a3%e5%86%b3ReactiveCocoa%e4%b8%ad%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e7%9a%84%e9%97%ae%e9%a2%98%e7%9a%84%e3%80%82%0aRACScheduler%e7%9a%84%e5%ae%9e%e8%b4%a8%e6%98%af%e5%af%b9GCD%e7%9a%84%e5%b0%81%e8%a3%85%ef%bc%8c%e5%ba%95%e5%b1%82%e5%b0%b1%e6%98%afGCD%e5%ae%9e%e7%8e%b0%e7%9a%84%e3%80%82%0a%e8%a6%81%e5%88%86%e6%9e%90RACScheduler%ef%bc%8c%e5%85%88%e6%9d%a5%e5%9b%9e%e9%a1%be%e4%b8%80%e4%b8%8bGCD%e3%80%82%0a%e4%bc%97%e6%89%80%e5%91%a8%e7%9f%a5%ef%bc%8c%e5%9c%a8GCD%e4%b8%ad%ef%bc%8cDispatch%20Queue%e4%b8%bb%e8%a6%81%e5%88%86%e4%b8%ba2%e7%b1%bb%ef%bc%8cSerial%20Dispatch%20Queue%20%e5%92%8c%20Concurrent%20Dispatch%20Queue%20%e3%80%82%e5%85%b6%e4%b8%adSerial%20Dispatch%20Queue%e6%98%af%e7%ad%89%e5%be%85%e7%8e%b0%e5%9c%a8%e6%89%a7%e8%a1%8c%e4%b8%ad%e5%a4%84%e7%90%86%e7%bb%93%e6%9d%9f%e7%9a%84%e9%98%9f%e5%88%97%ef%bc%8cConcurrent%20Dispatch%20Queue%e6%98%af%e4%b8%8d%e7%ad%89%e5%be%85%e7%8e%b0%e5%9c%a8%e6%89%a7%e8%a1%8c%e4%b8%ad%e5%a4%84%e7%90%86%e7%bb%93%e6%9d%9f%e7%9a%84%e9%98%9f%e5%88%97%e3%80%82%0a%e7%94%9f%e6%88%90Dispatch%20Queue%e7%9a%84%e6%96%b9%e6%b3%95%e4%b9%9f%e6%9c%892%e7%a7%8d%ef%bc%8c%e7%ac%ac%e4%b8%80%e7%a7%8d%e6%96%b9%e5%bc%8f%e6%98%af%e9%80%9a%e8%bf%87GCD%e7%9a%84API%e7%94%9f%e6%88%90Dispatch%20Queue%e3%80%82%0a%e7%94%9f%e6%88%90Serial%20Dispatch%20Queue%0adispatch_queue_t%20serialDispatchQueue%20%3d%20dispatch_queue_create%28%26%2334%3bcom.gcd.SerialDispatchQueue%26%2334%3b%2c%20DISPATCH_QUEUE_SERIAL%29%3b%20%e7%94%9f%e6%88%90Concurrent%20Dispatch%20Queue%0adispatch_queue_t%20concurrentDispatchQueue%20%3d%20dispatch_queue_create%28%26%2334%3bcom.gcd.ConcurrentDispatchQueue%26%2334%3b%2c%20DISPATCH_QUEUE_CONCURRENT%29%3b%20%e7%ac%ac%e4%ba%8c%e7%a7%8d%e6%96%b9%e6%b3%95%e6%98%af%e7%9b%b4%e6%8e%a5%e8%8e%b7%e5%8f%96%e7%b3%bb%e7%bb%9f%e6%8f%90%e4%be%9b%e7%9a%84Dispatch%20Queue%e3%80%82%e7%b3%bb%e7%bb%9f%e6%8f%90%e4%be%9b%e7%9a%84%e4%b9%9f%e5%88%86%e4%b8%ba2%e7%b1%bb%ef%bc%8cMain%20Dispatch%20Queue%20%e5%92%8c%20Global%20Dispatch%20Queue%e3%80%82Main%20Dispatch%20Queue%20%e5%af%b9%e5%ba%94%e7%9d%80%e6%98%afSerial%20Dispatch%20Queue%ef%bc%8cGlobal%20Dispatch%20Queue%20%e5%af%b9%e5%ba%94%e7%9d%80%e6%98%afConcurrent%20Dispatch%20Queue%e3%80%82"><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2freactivecocoa_racscheduler%2f&t=ReactiveCocoa%20%e4%b8%ad%20RACScheduler%20%e6%98%af%e5%a6%82%e4%bd%95%e5%b0%81%e8%a3%85%20GCD%20%e7%9a%84"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu class=icon href=# onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden=true></i>Menu</a>
<a id=toc class=icon href=# onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden=true></i>TOC</a>
<a id=share class=icon href=# onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden=true></i>share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i>Top</a></div></div></div><footer id=footer><div class=footer-left><p class=copyright style=float:left;margin-bottom:0><a href=https://github.com/halfrost/Halfrost-Field class=github-repo style=height:18px><span class=gadget-github></span>Star</a>
Copyright &copy;halfrost 2016 - 2021
<a href=http://www.miit.gov.cn/>鄂ICP备16014744号</a></p><br><p class="copyright statistics" style=margin-bottom:20px><span id=busuanzi_container_site_pv>Cumulative Page Views <span id=busuanzi_value_site_pv></span>| Unique Visitors <span id=busuanzi_value_site_uv></span></span></p></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/main.min.f870a4d110314b9e50e65f8ac982dc1c9c376c8f1a5083d39c62cfc49073f011.js></script><script async src=/prism.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>
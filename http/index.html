<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=theme-color content="#FFFFFF"><meta http-equiv=x-ua-compatible content="IE=edge"><title>HTTP 指南 | prometheus</title><meta name=description content="Explore in every moment of the hard thinking"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="HTTP 指南"><meta property="og:description" content="Web 使用一种名为 HTTP (HyperText Transfer Protocol，超文本传输协议) 的协议作为规范的。
 HTTP 更加严谨的译名应该是 超文本转移协议。
 HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准，因为被称为 HTTP/0.9
HTTP 正式作为标准被公布是 1996 年 5 月，版本命名为 HTTP/1.0，记载于 RFC1945
HTTP 在 1997 年 1 月公布了当前最主流的版本，版本命名为 HTTP/1.1，记载于 RFC2616
HTTP/2 于 2015 年 5 月 14 日发布，引入了服务器推送等多种功能，是目前最新的版本。记载于 RFC7540 (它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3)
一. HTTP 支持的方法 HTTP 是一种不保存状态，即 无状态（ stateless ）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这也是为了更快的处理大量事务，确保协议的可伸缩性。
HTTP/1.1 虽然是无状态协议，但是为了实现期望的保持状态的功能，特意引入了 Cookie 技术。
在HTTP/1.1规范中幂等性的定义是：
 Methods can also have the property of &ldquo;idempotence&rdquo; in that (aside from error or expiration issues) the side-effects of N > 0 identical requests is the same as for a single request."><meta property="og:type" content="article"><meta property="og:url" content="https://new.halfrost.com/http/"><meta property="article:published_time" content="2017-02-14T09:29:00+00:00"><meta property="article:modified_time" content="2017-02-14T09:29:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="HTTP 指南"><meta name=twitter:description content="Web 使用一种名为 HTTP (HyperText Transfer Protocol，超文本传输协议) 的协议作为规范的。
 HTTP 更加严谨的译名应该是 超文本转移协议。
 HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准，因为被称为 HTTP/0.9
HTTP 正式作为标准被公布是 1996 年 5 月，版本命名为 HTTP/1.0，记载于 RFC1945
HTTP 在 1997 年 1 月公布了当前最主流的版本，版本命名为 HTTP/1.1，记载于 RFC2616
HTTP/2 于 2015 年 5 月 14 日发布，引入了服务器推送等多种功能，是目前最新的版本。记载于 RFC7540 (它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3)
一. HTTP 支持的方法 HTTP 是一种不保存状态，即 无状态（ stateless ）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这也是为了更快的处理大量事务，确保协议的可伸缩性。
HTTP/1.1 虽然是无状态协议，但是为了实现期望的保持状态的功能，特意引入了 Cookie 技术。
在HTTP/1.1规范中幂等性的定义是：
 Methods can also have the property of &ldquo;idempotence&rdquo; in that (aside from error or expiration issues) the side-effects of N > 0 identical requests is the same as for a single request."><link rel=stylesheet href=/css/style-white.min.css><link rel=manifest href=/manifest.json><link rel=stylesheet href=/prism.css><link href=/images/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=/images/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=/images/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=/images/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=/images/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=/images/apple-touch-icon-512x512.png rel=apple-touch-icon sizes=512x512><link href=/images/apple-touch-icon-1024x1024.png rel=apple-touch-icon sizes=1024x1024><script async>if('serviceWorker'in navigator){navigator.serviceWorker.register("\/serviceworker-v1.min.a64912b78d282eab1ad3715a0943da21616e5f326f8afea27034784ad445043b.js").then(function(){if(navigator.serviceWorker.controller){console.log('Assets cached by the controlling service worker.');}else{console.log('Please reload this page to allow the service worker to handle network operations.');}}).catch(function(error){console.log('ERROR: '+error);});}else{console.log('Service workers are not supported in the current browser.');}</script><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://new.halfrost.com/images/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-82753806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="single-max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a><a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a><a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast');" style=display:none><i class="fas fa-chevron-up fa-lg"></i></a><span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://new.halfrost.com/reactivecocoa_macro/><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li><li><a class=icon href=https://new.halfrost.com/tcp_ip/><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li><li><a class=icon href=#><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fhttp%2f"><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&text=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&title=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&is_video=false&description=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=HTTP%20%e6%8c%87%e5%8d%97&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fhttp%2f"><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&title=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&title=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&title=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-stumbleupon" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&title=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-digg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&name=HTTP%20%e6%8c%87%e5%8d%97&description=Web%20%e4%bd%bf%e7%94%a8%e4%b8%80%e7%a7%8d%e5%90%8d%e4%b8%ba%20HTTP%20%28HyperText%20Transfer%20Protocol%ef%bc%8c%e8%b6%85%e6%96%87%e6%9c%ac%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae%29%20%e7%9a%84%e5%8d%8f%e8%ae%ae%e4%bd%9c%e4%b8%ba%e8%a7%84%e8%8c%83%e7%9a%84%e3%80%82%0a%20HTTP%20%e6%9b%b4%e5%8a%a0%e4%b8%a5%e8%b0%a8%e7%9a%84%e8%af%91%e5%90%8d%e5%ba%94%e8%af%a5%e6%98%af%20%e8%b6%85%e6%96%87%e6%9c%ac%e8%bd%ac%e7%a7%bb%e5%8d%8f%e8%ae%ae%e3%80%82%0a%20HTTP%20%e4%ba%8e%201990%20%e5%b9%b4%e9%97%ae%e4%b8%96%e3%80%82%e9%82%a3%e6%97%b6%e7%9a%84%20HTTP%20%e5%b9%b6%e6%b2%a1%e6%9c%89%e4%bd%9c%e4%b8%ba%e6%ad%a3%e5%bc%8f%e7%9a%84%e6%a0%87%e5%87%86%ef%bc%8c%e5%9b%a0%e4%b8%ba%e8%a2%ab%e7%a7%b0%e4%b8%ba%20HTTP%2f0.9%0aHTTP%20%e6%ad%a3%e5%bc%8f%e4%bd%9c%e4%b8%ba%e6%a0%87%e5%87%86%e8%a2%ab%e5%85%ac%e5%b8%83%e6%98%af%201996%20%e5%b9%b4%205%20%e6%9c%88%ef%bc%8c%e7%89%88%e6%9c%ac%e5%91%bd%e5%90%8d%e4%b8%ba%20HTTP%2f1.0%ef%bc%8c%e8%ae%b0%e8%bd%bd%e4%ba%8e%20RFC1945%0aHTTP%20%e5%9c%a8%201997%20%e5%b9%b4%201%20%e6%9c%88%e5%85%ac%e5%b8%83%e4%ba%86%e5%bd%93%e5%89%8d%e6%9c%80%e4%b8%bb%e6%b5%81%e7%9a%84%e7%89%88%e6%9c%ac%ef%bc%8c%e7%89%88%e6%9c%ac%e5%91%bd%e5%90%8d%e4%b8%ba%20HTTP%2f1.1%ef%bc%8c%e8%ae%b0%e8%bd%bd%e4%ba%8e%20RFC2616%0aHTTP%2f2%20%e4%ba%8e%202015%20%e5%b9%b4%205%20%e6%9c%88%2014%20%e6%97%a5%e5%8f%91%e5%b8%83%ef%bc%8c%e5%bc%95%e5%85%a5%e4%ba%86%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%8e%a8%e9%80%81%e7%ad%89%e5%a4%9a%e7%a7%8d%e5%8a%9f%e8%83%bd%ef%bc%8c%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e6%96%b0%e7%9a%84%e7%89%88%e6%9c%ac%e3%80%82%e8%ae%b0%e8%bd%bd%e4%ba%8e%20RFC7540%20%28%e5%ae%83%e4%b8%8d%e5%8f%ab%20HTTP%2f2.0%ef%bc%8c%e6%98%af%e5%9b%a0%e4%b8%ba%e6%a0%87%e5%87%86%e5%a7%94%e5%91%98%e4%bc%9a%e4%b8%8d%e6%89%93%e7%ae%97%e5%86%8d%e5%8f%91%e5%b8%83%e5%ad%90%e7%89%88%e6%9c%ac%e4%ba%86%ef%bc%8c%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%96%b0%e7%89%88%e6%9c%ac%e5%b0%86%e6%98%af%20HTTP%2f3%29%0a%e4%b8%80.%20HTTP%20%e6%94%af%e6%8c%81%e7%9a%84%e6%96%b9%e6%b3%95%20HTTP%20%e6%98%af%e4%b8%80%e7%a7%8d%e4%b8%8d%e4%bf%9d%e5%ad%98%e7%8a%b6%e6%80%81%ef%bc%8c%e5%8d%b3%20%e6%97%a0%e7%8a%b6%e6%80%81%ef%bc%88%20stateless%20%ef%bc%89%e5%8d%8f%e8%ae%ae%e3%80%82HTTP%20%e5%8d%8f%e8%ae%ae%e8%87%aa%e8%ba%ab%e4%b8%8d%e5%af%b9%e8%af%b7%e6%b1%82%e5%92%8c%e5%93%8d%e5%ba%94%e4%b9%8b%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1%e7%8a%b6%e6%80%81%e8%bf%9b%e8%a1%8c%e4%bf%9d%e5%ad%98%e3%80%82%e4%b9%9f%e5%b0%b1%e6%98%af%e8%af%b4%e5%9c%a8%20HTTP%20%e8%bf%99%e4%b8%aa%e7%ba%a7%e5%88%ab%ef%bc%8c%e5%8d%8f%e8%ae%ae%e5%af%b9%e4%ba%8e%e5%8f%91%e9%80%81%e8%bf%87%e7%9a%84%e8%af%b7%e6%b1%82%e6%88%96%e5%93%8d%e5%ba%94%e9%83%bd%e4%b8%8d%e5%81%9a%e6%8c%81%e4%b9%85%e5%8c%96%e5%a4%84%e7%90%86%e3%80%82%e8%bf%99%e4%b9%9f%e6%98%af%e4%b8%ba%e4%ba%86%e6%9b%b4%e5%bf%ab%e7%9a%84%e5%a4%84%e7%90%86%e5%a4%a7%e9%87%8f%e4%ba%8b%e5%8a%a1%ef%bc%8c%e7%a1%ae%e4%bf%9d%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7%e3%80%82%0aHTTP%2f1.1%20%e8%99%bd%e7%84%b6%e6%98%af%e6%97%a0%e7%8a%b6%e6%80%81%e5%8d%8f%e8%ae%ae%ef%bc%8c%e4%bd%86%e6%98%af%e4%b8%ba%e4%ba%86%e5%ae%9e%e7%8e%b0%e6%9c%9f%e6%9c%9b%e7%9a%84%e4%bf%9d%e6%8c%81%e7%8a%b6%e6%80%81%e7%9a%84%e5%8a%9f%e8%83%bd%ef%bc%8c%e7%89%b9%e6%84%8f%e5%bc%95%e5%85%a5%e4%ba%86%20Cookie%20%e6%8a%80%e6%9c%af%e3%80%82%0a%e5%9c%a8HTTP%2f1.1%e8%a7%84%e8%8c%83%e4%b8%ad%e5%b9%82%e7%ad%89%e6%80%a7%e7%9a%84%e5%ae%9a%e4%b9%89%e6%98%af%ef%bc%9a%0a%20Methods%20can%20also%20have%20the%20property%20of%20%26ldquo%3bidempotence%26rdquo%3b%20in%20that%20%28aside%20from%20error%20or%20expiration%20issues%29%20the%20side-effects%20of%20N%20%26gt%3b%200%20identical%20requests%20is%20the%20same%20as%20for%20a%20single%20request."><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&t=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div><div id=toc><nav id=TableOfContents><ul><li><a href=#一-http-支持的方法>一. HTTP 支持的方法</a></li><li><a href=#二-http-状态码>二. HTTP 状态码</a><ul><li><a href=#1xx-信息>1XX 信息</a></li><li><a href=#2xx-成功>2XX 成功</a></li><li><a href=#3xx-重定向>3XX 重定向</a></li><li><a href=#4xx-客户端错误>4XX 客户端错误</a></li><li><a href=#5xx-服务器错误>5XX 服务器错误</a></li></ul></li><li><a href=#rfc-2616-状态码>RFC 2616 状态码</a></li><li><a href=#三-mime-媒体内容>三. MIME 媒体内容</a></li><li><a href=#四-http-报文结构>四. HTTP 报文结构</a><ul><li><a href=#1-通用首部>1. 通用首部</a></li><li><a href=#http-缓存控制>HTTP 缓存控制</a></li><li><a href=#2-请求首部>2. 请求首部</a></li><li><a href=#请求信息性首部>请求信息性首部</a></li><li><a href=#accept-首部>Accept 首部</a></li><li><a href=#条件请求首部>条件请求首部</a></li><li><a href=#安全请求首部>安全请求首部</a></li><li><a href=#代理请求首部>代理请求首部</a></li><li><a href=#3-响应首部>3. 响应首部</a></li><li><a href=#响应信息性首部>响应信息性首部</a></li><li><a href=#协商首部>协商首部</a></li><li><a href=#安全响应首部>安全响应首部</a></li><li><a href=#4-实体首部>4. 实体首部</a></li><li><a href=#实体信息性首部>实体信息性首部</a></li><li><a href=#内容首部>内容首部</a></li><li><a href=#实体缓存首部>实体缓存首部</a></li><li><a href=#5-扩展首部>5. 扩展首部</a></li><li><a href=#1x-frame-options>（1）X-Frame-Options</a></li><li><a href=#2x-xss-protection>（2）X-XSS-Protection</a></li><li><a href=#3dnt>（3）DNT</a></li><li><a href=#4p3p>（4）P3P</a></li></ul></li><li><a href=#五-提高-http-性能>五. 提高 HTTP 性能</a><ul><li><a href=#1-并行连接>1. 并行连接</a></li><li><a href=#2-持久连接>2. 持久连接</a></li><li><a href=#3-管道化连接>3. 管道化连接</a></li><li><a href=#4-复用的连接>4. 复用的连接</a></li></ul></li><li><a href=#六-get-和-post-的区别>六. GET 和 POST 的区别</a></li><li><a href=#参数>参数</a></li><li><a href=#安全>安全</a></li><li><a href=#幂等性>幂等性</a></li><li><a href=#可缓存>可缓存</a></li><li><a href=#xmlhttprequest>XMLHttpRequest</a></li><li><a href=#七-http-各版本比较>七. HTTP 各版本比较</a></li><li><a href=#http10-与-http11-的区别>HTTP/1.0 与 HTTP/1.1 的区别</a></li><li><a href=#http11-与-http20-的区别>HTTP/1.1 与 HTTP/2.0 的区别</a><ul><li><a href=#1-多路复用>1. 多路复用</a></li><li><a href=#2-首部压缩>2. 首部压缩</a></li><li><a href=#3-服务端推送>3. 服务端推送</a></li><li><a href=#4-二进制格式>4. 二进制格式</a></li></ul></li><li><a href=#八-cors-跨域>八. CORS 跨域</a><ul><li><a href=#1-简单请求>1. 简单请求</a></li><li><a href=#2-预请求>2. 预请求</a></li><li><a href=#3-附带凭证信息的请求>3. 附带凭证信息的请求</a></li></ul></li><li><a href=#九-cors-和-jsonp-对比>九. CORS 和 JSONP 对比</a></li></ul></nav></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">HTTP 指南</h1><div class=meta><div class=postdate><time datetime="2017-02-14 09:29:00 +0000 UTC" itemprop=datePublished>Feb 14</time></div><div class=article-category><i class="fas fa-archive"></i><a class=category-link href=/categories/http>HTTP</a>
,
<a class=category-link href=/categories/protocol>Protocol</a></div><div class=article-tag><i class="fas fa-tag"></i><a class=tag-link href=/tags/http rel=tag>HTTP</a>
,
<a class=tag-link href=/tags/protocol rel=tag>Protocol</a></div></div></header><div class=content itemprop=articleBody><p>Web 使用一种名为 HTTP (HyperText Transfer Protocol，超文本传输协议) 的协议作为规范的。</p><blockquote><p>HTTP 更加严谨的译名应该是 超文本转移协议。</p></blockquote><p>HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准，因为被称为 HTTP/0.9<br>HTTP 正式作为标准被公布是 1996 年 5 月，版本命名为 HTTP/1.0，记载于 RFC1945<br>HTTP 在 1997 年 1 月公布了当前最主流的版本，版本命名为 HTTP/1.1，记载于 RFC2616<br>HTTP/2 于 2015 年 5 月 14 日发布，引入了服务器推送等多种功能，是目前最新的版本。记载于 RFC7540
(它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3)</p><h2 id=一-http-支持的方法>一. HTTP 支持的方法</h2><p>HTTP 是一种不保存状态，即 无状态（ stateless ）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这也是为了更快的处理大量事务，确保协议的可伸缩性。</p><p>HTTP/1.1 虽然是无状态协议，但是为了实现期望的保持状态的功能，特意引入了 Cookie 技术。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_1.png alt></p><p>在HTTP/1.1规范中幂等性的定义是：</p><blockquote><p>Methods can also have the property of &ldquo;idempotence&rdquo; in that (aside from error or expiration issues) the side-effects of N > 0 identical requests is the same as for a single request.</p></blockquote><p>从定义上看，HTTP 方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP 规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而 HTTP 的分布式本质也决定了它在 HTTP 中具有重要地位。</p><p>HTTP 方法的安全性指的是不会改变服务器状态，也就是说它只是可读的。所以只有 OPTIONS、GET、HEAD 是安全的，其他都是不安全的。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_2.png alt></p><p><strong>POST 和 PATCH 这两个不是幂等性的</strong>。<br>两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI。<br>对同一URI进行多次PUT的副作用和一次PUT是相同的。</p><h2 id=二-http-状态码>二. HTTP 状态码</h2><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_3.png alt></p><h3 id=1xx-信息>1XX 信息</h3><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h3 id=2xx-成功>2XX 成功</h3><ul><li><p><strong>200 OK</strong></p></li><li><p><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p></li><li><p><strong>206 Partial Content</strong> ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。</p></li></ul><h3 id=3xx-重定向>3XX 重定向</h3><ul><li><p><strong>301 Moved Permanently</strong> ：永久性重定向</p></li><li><p><strong>302 Found</strong> ：临时性重定向</p></li><li><p><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p></li><li><p>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p></li><li><p><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p></li><li><p><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p></li></ul><h3 id=4xx-客户端错误>4XX 客户端错误</h3><ul><li><p><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</p></li><li><p><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p></li><li><p><strong>403 Forbidden</strong> ：请求被拒绝，服务器端没有必要给出拒绝的详细理由。</p></li><li><p><strong>404 Not Found</strong></p></li></ul><h3 id=5xx-服务器错误>5XX 服务器错误</h3><ul><li><p><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</p></li><li><p><strong>503 Service Unavilable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p></li></ul><hr><h2 id=rfc-2616-状态码>RFC 2616 状态码</h2><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_4.png alt></p><blockquote><p>在 RFC2616 中定义了 40 种 HTTP 状态码，webDAV ( Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制)在 RFC4918 和 RFC5842 中，定义了一些特殊的状态码，在 RFC2518、RFC2817、RFC2295、RFC2774、RFC6585 中还额外定义了一些附加的 HTTP 状态码。总共有 60+ 种。具体链接可以见 <a href=https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81>HTTP状态码 (wikipedia)</a></p></blockquote><p>webDAV 新增状态码</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_5.png alt></p><h2 id=三-mime-媒体内容>三. MIME 媒体内容</h2><p>HTTP 仔细地给每种要通过 Web 传输的对象都打上了名为 MIME 类型（MIME type）的数据格式标签。最初设计 MIME（Multipurpose Internet Mail Extension，多用途因特网邮件扩展）是为了解决在不同的电子邮件系统之间搬移报文时存在的问题。MIME 在电子邮件系统中工作得非常好，因此 HTTP 也采纳了它，用它来描述并标记多媒体内容。</p><p>RFC2045，“ MIME: Format of Internet Message Bodies”（“ MIME：因特网报文主体的格式”）</p><p>常见的主 MIME 类型</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_6.png alt></p><h2 id=四-http-报文结构>四. HTTP 报文结构</h2><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_7.png alt></p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_8.png alt></p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_9.png alt></p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_10.png alt></p><p>举个例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>General:
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>Request URL: https://github.com/halfrost
</span><span style=color:#960050;background-color:#1e0010>Request Method: GET
</span><span style=color:#960050;background-color:#1e0010>Status Code: 200 OK
</span><span style=color:#960050;background-color:#1e0010>Remote Address: 127.0.0.1:6152
</span><span style=color:#960050;background-color:#1e0010>Referrer Policy: no-referrer-when-downgrade
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>Response Headers:</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_11.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span> <span style=color:#ae81ff>200</span> <span style=color:#a6e22e>OK</span>
Date<span style=color:#f92672>:</span> <span style=color:#ae81ff>Sun, 22 Apr 2018 15:47:27 GMT</span>
Content-Type<span style=color:#f92672>:</span> <span style=color:#ae81ff>text/html; charset=utf-8</span>
Transfer-Encoding<span style=color:#f92672>:</span> <span style=color:#ae81ff>chunked</span>
Server<span style=color:#f92672>:</span> <span style=color:#ae81ff>GitHub.com</span>
Status<span style=color:#f92672>:</span> <span style=color:#ae81ff>200 OK</span>
Cache-Control<span style=color:#f92672>:</span> <span style=color:#ae81ff>no-cache</span>
Vary<span style=color:#f92672>:</span> <span style=color:#ae81ff>X-Requested-With</span>
Set-Cookie<span style=color:#f92672>:</span> <span style=color:#ae81ff>user_session=GYkmjrs9T6H9r16Gx85; path=/; expires=Sun, 06 May 2018 15:47:27 -0000; secure; HttpOnly</span>
Set-Cookie<span style=color:#f92672>:</span> <span style=color:#ae81ff>__Host-user_session_same_site=GYkmjre6H9r16Gx85; path=/; expires=Sun, 06 May 2018 15:47:27 -0000; secure; HttpOnly; SameSite=Strict</span>
Set-Cookie<span style=color:#f92672>:</span> <span style=color:#ae81ff>_gh_sess=OHppNS84T05ubXZFS2swUm9SUlBqdXNpWlA2bHZZ3alUyUGNLZ0pqMD0tLTNLWDI0K1pTUUFlaWJUVU5XUTJaNFE9PQ%3D%3D--74346822d2bf179f6ff73ce52c8b8606c8f78755; path=/; secure; HttpOnly</span>
X-Request-Id<span style=color:#f92672>:</span> <span style=color:#ae81ff>855feee9-5be2-482f-911a-b0eb22d55088</span>
X-Runtime<span style=color:#f92672>:</span> <span style=color:#ae81ff>0.170448</span>
Strict-Transport-Security<span style=color:#f92672>:</span> <span style=color:#ae81ff>max-age=31536000; includeSubdomains; preload</span>
X-Frame-Options<span style=color:#f92672>:</span> <span style=color:#ae81ff>deny</span>
X-Content-Type-Options<span style=color:#f92672>:</span> <span style=color:#ae81ff>nosniff</span>
X-XSS-Protection<span style=color:#f92672>:</span> <span style=color:#ae81ff>1; mode=block</span>
Referrer-Policy<span style=color:#f92672>:</span> <span style=color:#ae81ff>origin-when-cross-origin, strict-origin-when-cross-origin</span>
Expect-CT<span style=color:#f92672>:</span> <span style=color:#ae81ff>max-age=2592000, report-uri=&#34;https://api.github.com/_private/browser/errors&#34;</span>
Content-Security-Policy<span style=color:#f92672>:</span> <span style=color:#ae81ff>default-src &#39;none&#39;; base-uri &#39;self&#39;; block-all-mixed-content; child-src render.githubusercontent.com; connect-src &#39;self&#39; uploads.github.com status.github.com collector.githubapp.com api.github.com www.google-analytics.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com wss://live.github.com; font-src assets-cdn.github.com; form-action &#39;self&#39; github.com gist.github.com; frame-ancestors &#39;none&#39;; img-src &#39;self&#39; data: assets-cdn.github.com identicons.github.com collector.githubapp.com github-cloud.s3.amazonaws.com *.githubusercontent.com; manifest-src &#39;self&#39;; media-src &#39;none&#39;; script-src assets-cdn.github.com; style-src &#39;unsafe-inline&#39; assets-cdn.github.com</span>
X-Runtime-rack<span style=color:#f92672>:</span> <span style=color:#ae81ff>0.175479</span>
Content-Encoding<span style=color:#f92672>:</span> <span style=color:#ae81ff>gzip</span>
Vary<span style=color:#f92672>:</span> <span style=color:#ae81ff>Accept-Encoding</span>
X-GitHub-Request-Id<span style=color:#f92672>:</span> <span style=color:#ae81ff>B706:3019:355B8D9:52B9B00:5ADCAE85</span>


</code></pre></div><p>Request Headers:</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_12.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>GET</span> /halfrost <span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span>
Host<span style=color:#f92672>:</span> <span style=color:#ae81ff>github.com</span>
Connection<span style=color:#f92672>:</span> <span style=color:#ae81ff>keep-alive</span>
Cache-Control<span style=color:#f92672>:</span> <span style=color:#ae81ff>max-age=0</span>
Upgrade-Insecure-Requests<span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>
User-Agent<span style=color:#f92672>:</span> <span style=color:#ae81ff>Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Mobile Safari/537.36</span>
Accept<span style=color:#f92672>:</span> <span style=color:#ae81ff>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span>
Referer<span style=color:#f92672>:</span> <span style=color:#ae81ff>https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/HTTP.md</span>
Accept-Encoding<span style=color:#f92672>:</span> <span style=color:#ae81ff>gzip, deflate, br</span>
Accept-Language<span style=color:#f92672>:</span> <span style=color:#ae81ff>zh-CN,zh;q=0.9,en;q=0.8</span>
Cookie<span style=color:#f92672>:</span> <span style=color:#ae81ff>_octo=GH1.1.101205900.1486965233; logged_in=yes; dotcom_user=halfrost; _ga=GA1.2.183217117.1486965233; user_session=GYkmjrs9Ts80x85; __Host-user_session_same_site=GYkmjrs9THGx85; tz=Asia%2FShanghai; _gat=1; _gh_sess=S1JyM0tEbTVEcU50OXRERmUwOVlqRVZiQWp5SDlBeWt3RitrbEczRkxjaWVLWWNVc2k4YjhBTDVQT3BZajEwSGRJOEE2bz0tLVNLRHhiTlVDN2xEUXJ1OFM1ME1VeVE9PQ%3D%3D--59dc56a889d38d30125fbee36df9dab97e7a46c0</span>


</code></pre></div><p>请求报文是由请求方法，请求 URI，协议版本，可选请求首部字段和内容实体构成的。</p><p>响应报文基本上由协议版本，状态码（表示请求成功与失败的数字代码），用以解释状态码的原因短语，可选的响应首部字段以及实体主体构成。</p><h3 id=1-通用首部>1. 通用首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_13.png alt></p><p>Cache-Control 首部功能很强大。服务器和客户端都可以用它来说明新鲜度，并且除了使用期或过期时间之外，还有很多指令可用。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_14.png alt></p><blockquote><p>no-cache 和 no-store 的区别：no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后再处理资源。no-store 才是真正的不缓存。</p></blockquote><p>no-cache 并不代表完全的禁用缓存，而是代表会每次去核对服务端的 Etag，如果相同，那么就不会去服务端下载完整的资源，返回一个 304 Not Modified。（最长缓存 3 年）</p><p>no-store 才是真正的禁用缓存，它表示每次服务端都会去下载最新的资源。（当然，通常似乎都用不上）。</p><p>public 和 private 的差别主要在于如果是有用户认证环节的页面，设置为private 就只有终端浏览器会缓存，中间 CDN 并不会缓存，而设置为 public，则会在每一个环节缓存。默认不需要设置 public，因为 max-age 已经表明可以由各个环节缓存了（单位为秒）。此刻如果命中缓存，则不会再去请求服务器核对 Etag，而是直接返回 200(from disk)。</p><p>当然，由于 public 会在每一个环节缓存，如果对修改更新预览又强需求的网页，那么最好不要使用这一缓存策略，否则还需要刷新 CDN 源，很麻烦。</p><p>如果挑选缓存策略，可以见下图：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_15.png alt></p><h3 id=http-缓存控制>HTTP 缓存控制</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_16.png alt></p><p>针对 “Expires 时间是相对服务器而言，无法保证和客户端时间统一” 的问题，http1.1 新增了 Cache-Control 来定义缓存过期时间。注意：若报文中同时出现了 Expires 和 Cache-Control，则以 Cache-Control 为准。</p><p>也就是说优先级从高到低分别是 <strong>Pragma -> Cache-Control -> Expires</strong>。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_17.png alt></p><p>1、Expires / Cache-Control<br>Expires用时刻来标识失效时间，不免收到时间同步的影响，而Cache-Control使用时间间隔很好的解决了这个问题。 但是 Cache-Control 是 HTTP1.1 才有的，不适用于 HTTP1.0，而 Expires 既适用于 HTTP1.0，也适用于 HTTP1.1，所以说在大多数情况下同时发送这两个头会是一个更好的选择，当客户端两种头都能解析的时候，<strong>会优先使用 Cache-Control</strong>。</p><p>2、Last-Modified / ETag<br>二者都是通过某个标识值来请求资源， 如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed）状态码，内容为空，这样就节省了传输数据量。而当资源发生比那话后，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。<br>其中 Last-Modified 使用文件最后修改作为文件标识值，它无法处理文件一秒内多次修改的情况，而且只要文件修改了哪怕文件实质内容没有修改，也会重新返回资源内容；ETag 作为“被请求变量的实体值”，其完全可以解决 Last-Modified 头部的问题，但是其计算过程需要耗费服务器资源。</p><p>3、from-cache / 304<br>Expires 和 Cache-Control 都有一个问题就是服务端作为的修改，如果还在缓存时效里，那么客户端是不会去请求服务端资源的（非刷新），这就存在一个资源版本不符的问题，而强制刷新一定会发起 HTTP 请求并返回资源内容，无论该内容在这段时间内是否修改过；<strong>而 Last-Modified 和 Etag 每次请求资源都会发起请求，哪怕是很久都不会有修改的资源，都至少有一次请求响应的消耗</strong>。</p><p>对于所有可缓存资源，指定一个 Expires 或 Cache-Control max-age 以及一个 Last-Modified 或 ETag 至关重要。同时使用前者和后者可以很好的相互适应。<br><strong>前者不需要每次都发起一次请求来校验资源时效性，后者保证当资源未出现修改的时候不需要重新发送该资源</strong>。而在用户的不同刷新页面行为中，二者的结合也能很好的利用 HTTP 缓存控制特性，无论是在地址栏输入 URI 然后输入回车进行访问，还是点击刷新按钮，浏览器都能充分利用缓存内容，避免进行不必要的请求与数据传输。</p><p>4、避免 304</p><p>做法实际上很简单，<strong>它把服务侧 ETag 的那一套理论搬到了前端来使用</strong>。 页面的静态资源以版本形式发布，常用的方法是在文件名或参数带上一串md5或时间标记符：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>https://hm.baidu.com/hm.js?e23800c454aa573c0ccb16b52665ac26
</span><span style=color:#960050;background-color:#1e0010>http://tb1.bdstatic.com/tb/_/tbean_safe_ajax_94e7ca2.js
</span><span style=color:#960050;background-color:#1e0010>http://img1.gtimg.com/ninja/2/2016/04/ninja145972803357449.jpg
</span></code></pre></div><p>可以看到上面的例子中有不同的做法，有的在URI后面加上了md5参数，有的将md5值作为文件名的一部分，有的将资源放在特性版本的目录中。</p><p>那么在文件没有变动的时候，浏览器不用发起请求直接可以使用缓存文件；而在文件有变化的时候，由于文件版本号的变更，导致文件名变化，请求的 url 变了，自然文件就更新了。这样能确保客户端能及时从服务器收取到新修改的文件。通过这样的处理，增长了静态资源，特别是图片资源的缓存时间，避免该资源很快过期，客户端频繁向服务端发起资源请求，服务器再返回 304 响应的情况（有 Last-Modified/Etag）。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_18.png alt></p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_19.png alt></p><p>总结：</p><ul><li>需要兼容 HTTP1.0 的时候需要使用 Expires，不然可以考虑直接使用 Cache-Control。</li><li>需要处理一秒内多次修改的情况，或者其他 Last-Modified 处理不了的情况，才使用 ETag，否则使用 Last-Modified。</li><li>对于所有可缓存资源，需要指定一个 Expires 或 Cache-Control，同时指定 Last-Modified 或者 Etag。</li><li>可以通过标识文件版本名、加长缓存时间的方式来减少 304 响应。</li></ul><hr><p>Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。</p><p>Warning 首部的格式如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>Warning: [警告码][警告的主机：端口号]&#34;[警告内容]&#34;([日期内容])
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>HTTP/1.1 中定义了 7 种警告，警告码具备扩展性，今后可以能追加新的警告码。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_20.png alt></p><h3 id=2-请求首部>2. 请求首部</h3><h3 id=请求信息性首部>请求信息性首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_21.png alt></p><h3 id=accept-首部>Accept 首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_22.png alt></p><p>常见内容编码</p><p>常用的内容编码有以下几种：</p><ul><li>gzip（GNU zip）<br>由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，统称 CRC）</li><li>compress（UNIX 系统的标准压缩）<br>由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel-Ziv-Welch 算法 （LZW）</li><li>deflate（zlib）<br>组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式</li><li>identity（不进行编码）<br>不执行压缩或不会变化的默认编码格式</li></ul><h3 id=条件请求首部>条件请求首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_23.png alt></p><h3 id=安全请求首部>安全请求首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_24.png alt></p><h3 id=代理请求首部>代理请求首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_25.png alt></p><h3 id=3-响应首部>3. 响应首部</h3><h3 id=响应信息性首部>响应信息性首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_26.png alt></p><h3 id=协商首部>协商首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_27.png alt></p><h3 id=安全响应首部>安全响应首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_28.png alt></p><p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为了防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>Set-Cookie: name-value;HttpOnly
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>顺带一提，该扩展并非是为了防止 XSS 而开发的。</p><h3 id=4-实体首部>4. 实体首部</h3><h3 id=实体信息性首部>实体信息性首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_29.png alt></p><h3 id=内容首部>内容首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_30.png alt></p><p>由于 HTTP 首部无法记录二进制值，所以要通过 Base-64 编码处理。采用 Content-MD5 这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改。原因在于，内容如果被篡改了，那么同时意味着 Content-MD5 也可以被重新计算后更新，被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过的。</p><h3 id=实体缓存首部>实体缓存首部</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_31.png alt></p><p>如果两者的 URI 是相同，所以仅凭 URI 指定缓存的资源是很困难的。若下载过程中出现连续中断、再连接的情况，都会依据 ETag 值指定资源。</p><p>ETag 也分为强 ETag 值和弱 ETag 值：</p><p>强 ETag 值：</p><p>强 ETag 值，不论实体发生多少细微的变化都会改变其值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>ETag: &#34;usagi-1234&#34;
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>弱 ETag 值：</p><p>弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>ETag: W/&#34;usagi-1234&#34;
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><h3 id=5-扩展首部>5. 扩展首部</h3><h3 id=1x-frame-options>（1）X-Frame-Options</h3><p>首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</p><h3 id=2x-xss-protection>（2）X-XSS-Protection</h3><p>首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。0：将 XSS 过滤设置成无效状态，1：将 XSS 过滤设置成有效状态。</p><h3 id=3dnt>（3）DNT</h3><p>首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。0：同意被追踪，1：拒绝被追踪。</p><h3 id=4p3p>（4）P3P</h3><p>首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</p><blockquote><p>在 HTTP 等多种协议中，通过给非标准参数加上前缀 X- ，来区别于标准参数，并使那些非标准的参数作为扩展变成可能。但是这种简单粗暴的做法有百害而无一益，因此在 “RFC6648 - Deprecating the &ldquo;X-&rdquo; Prefix and Similar Constructs in Application Protocols ”中提议停止该做法。然而，对已经在使用中的 X- 前缀来说，不应该要求其变更。</p></blockquote><p>HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分为 端到端首部（End-to-end Header）、逐跳首部（Hop-by-hop Header）</p><ul><li>端到端首部：分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的相应中，另外规定它必须被转发。</li><li>逐跳首部：分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。（Connection、Keep-Alive、Proxy-Authenticate、Proxy-Authorization、Trailer、TE、Transfer-Encoding、Upgrade 这 8 个首部字段属于逐跳首部，除此以外的字段都属于端到端首部）</li></ul><h2 id=五-提高-http-性能>五. 提高 HTTP 性能</h2><h3 id=1-并行连接>1. 并行连接</h3><p>通过多条 TCP 连接发起并发的 HTTP 请求。</p><h3 id=2-持久连接>2. 持久连接</h3><p>重用 TCP 连接，以消除连接及关闭的时延。 持久连接（HTTP Persistent Connections），也称为 HTTP keep-alive 或者 HTTP connection reuse 。</p><p>在 HTTP/1.1 中，所有的连接默认都是持久连接。但是服务器端不一定都能够支持持久连接，所以除了服务端，客户端也需要支持持久连接。</p><h3 id=3-管道化连接>3. 管道化连接</h3><p>通过共享的 TCP 连接发起并发的 HTTP 请求。</p><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。以前发送请求后需要等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应，直接发送下一个请求。</p><p>比如当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。</p><h3 id=4-复用的连接>4. 复用的连接</h3><p>交替传送请求和响应报文（实验阶段）。</p><h2 id=六-get-和-post-的区别>六. GET 和 POST 的区别</h2><h2 id=参数>参数</h2><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在内容实体中(依旧是明文传输，只是和 GET 存放的位置不同罢了)。</p><p>GET 的传参方式相比于 POST 安全性较差，因为 GET 传的参数在 URL 中是可见的，可能会泄露私密信息。并且 GET 只支持 ASCII 字符，如果参数为中文则可能会出现乱码，而 POST 支持标准字符集。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#a6e22e>GET</span> /test/demo_form.asp?name1=value1&amp;name2=value2 <span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#a6e22e>POST</span> /test/demo_form.asp <span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span>
Host<span style=color:#f92672>:</span> <span style=color:#ae81ff>w3schools.com</span>
<span style=color:#960050;background-color:#1e0010>name1=value1&amp;name2=value2</span>
</code></pre></div><h2 id=安全>安全</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><h2 id=幂等性>幂等性</h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的安全方法也都是幂等的。</p><p>GET /pageX HTTP/1.1 是幂等的。连续调用多次，客户端接收到的结果都是一样的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#a6e22e>GET</span> /pageX <span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span>
<span style=color:#960050;background-color:#1e0010>GET</span> <span style=color:#ae81ff>/pageX HTTP/1.1</span>
<span style=color:#960050;background-color:#1e0010>GET</span> <span style=color:#ae81ff>/pageX HTTP/1.1</span>
<span style=color:#960050;background-color:#1e0010>GET</span> <span style=color:#ae81ff>/pageX HTTP/1.1</span>
</code></pre></div><p>POST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#a6e22e>POST</span> /add_row <span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span>
<span style=color:#960050;background-color:#1e0010>POST</span> <span style=color:#ae81ff>/add_row HTTP/1.1   -&gt; Adds a 2nd row</span>
<span style=color:#960050;background-color:#1e0010>POST</span> <span style=color:#ae81ff>/add_row HTTP/1.1   -&gt; Adds a 3rd row</span>
</code></pre></div><p>DELETE /idX/delete HTTP/1.1 是幂等的，即便是不同请求之间接收到的状态码不一样：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists
</span><span style=color:#960050;background-color:#1e0010>DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted
</span><span style=color:#960050;background-color:#1e0010>DELETE /idX/delete HTTP/1.1   -&gt; Returns 404
</span></code></pre></div><h2 id=可缓存>可缓存</h2><p>如果要对响应进行缓存，需要满足以下条件：</p><ol><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ol><h2 id=xmlhttprequest>XMLHttpRequest</h2><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><p>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</p><h2 id=七-http-各版本比较>七. HTTP 各版本比较</h2><h2 id=http10-与-http11-的区别>HTTP/1.0 与 HTTP/1.1 的区别</h2><ol><li>HTTP/1.1 默认是持久连接</li><li>HTTP/1.1 支持管线化处理</li><li>HTTP/1.1 支持虚拟主机</li><li>HTTP/1.1 新增状态码 100</li><li>HTTP/1.1 支持分块传输编码</li><li>HTTP/1.1 新增缓存处理指令 max-age</li></ol><p>具体内容见上文</p><h2 id=http11-与-http20-的区别>HTTP/1.1 与 HTTP/2.0 的区别</h2><blockquote><p><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn">HTTP/2 简介</a></p></blockquote><h3 id=1-多路复用>1. 多路复用</h3><p>HTTP/2.0 使用多路复用技术，同一个 TCP 连接可以处理多个请求。</p><h3 id=2-首部压缩>2. 首部压缩</h3><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。</p><h3 id=3-服务端推送>3. 服务端推送</h3><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 index.html 页面，服务端就把 index.js 一起发给客户端。</p><h3 id=4-二进制格式>4. 二进制格式</h3><p>HTTP/1.1 的解析是基于文本的，而 HTTP/2.0 采用二进制格式。</p><h2 id=八-cors-跨域>八. CORS 跨域</h2><p>当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p><p>比如，站点 <a href=http://domain-a.com>http://domain-a.com</a> 的某 HTML 页面通过 的 src 请求 <a href=http://domain-b.com/image.jpg>http://domain-b.com/image.jpg</a>。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。</p><p>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。</p><p>（译者注：跨域并不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如 Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。）</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_32.png alt></p><p>隶属于 W3C 的 Web 应用工作组推荐了一种新的机制，即跨源资源共享（Cross-Origin Resource Sharing ) CORS。这种机制让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。需要特别注意的是，这个规范是针对API容器的（比如说XMLHttpReques 或者 Fetch），以减轻跨域HTTP请求的风险。**CORS 需要客户端和服务器同时支持。目前，所有浏览器都支持该机制。 **</p><p>跨域资源共享标准（ cross-origin sharing standard ）允许在下列场景中使用跨域 HTTP 请求：</p><ul><li>前文提到的由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。</li><li>Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</li><li>WebGL 贴图</li><li>使用 drawImage 将 Images/video 画面绘制到 canvas</li><li>样式表（使用 CSSOM）</li><li>Scripts (未处理的异常)</li></ul><p>把CORS分为：简单请求、预请求和附带凭证信息的请求。</p><h3 id=1-简单请求>1. 简单请求</h3><p>某些请求不会触发 CORS 预检请求。本文称这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p><p>(1). 使用下列方法之一：</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>(2). Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：</p><p>Accept<br>Accept-Language<br>Content-Language<br>Content-Type （需要注意额外的限制）<br>DPR<br>Downlink<br>Save-Data<br>Viewport-Width<br>Width</p><p>(3). Content-Type 的值仅限于下列三者之一：</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>(4). 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p><p>(5). 请求中没有使用 ReadableStream 对象。</p><p>简单来说，重点需要记住的就是两点：</p><p><strong>（1）只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。<br>（2）不会使用自定义请求头（类似于 X-Modified 这种）。</strong></p><p>举例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>
<span style=color:#75715e>//比如说，假如站点 http://foo.example 的网页应用想要访问 http://bar.other 的资源。以下的 JavaScript 代 
</span><span style=color:#75715e>//码应该会在 foo.example 上执行：    
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>invocation</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>XMLHttpRequest</span>();
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;http://bar.other/resources/public-data/&#39;</span>;
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>callOtherDomain</span>() {
  <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>invocation</span>) {    
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#39;GET&#39;</span>, <span style=color:#a6e22e>url</span>, <span style=color:#66d9ef>true</span>);
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>onreadystatechange</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>handler</span>;
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>send</span>(); 
  }
}

</code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_33.png alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>//让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#a6e22e>GET</span> /resources/public-data/ <span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span>
Host<span style=color:#f92672>:</span> <span style=color:#ae81ff>bar.other</span>
User-Agent<span style=color:#f92672>:</span> <span style=color:#ae81ff>Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 </span>
<span style=color:#960050;background-color:#1e0010>Minefield/3.1b3pre</span>
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Referer: http://foo.example/examples/access-control/simpleXSInvocation.html
Origin: http://foo.example //该请求来自于 http://foo.exmaple。
//以上是浏览器发送请求

HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 00:23:53 GMT
Server: Apache/2.0.61 
Access-Control-Allow-Origin: * //这表明服务器接受来自任何站点的跨站请求。如果设置为http://foo.example。其它站点就不能跨站访问 http://bar.other 的资源了。
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: application/xml
//以上是服务器返回信息给浏览器

</code></pre></div><p>以下情况，请求会返回相关响应信息</p><ul><li>如果资源是允许公开访问的(就像任何允许GET访问的 HTTP资源),返回Access-Control-Allow-Origin:*头信息就足够了,除非是一些需要Cookies和HTTP身份验证信息的请求。</li><li>如果资源访问被限制基于相同的域名,或者如果要访问的资源需要凭证(或设置凭证),那么就有必要对请求头信息中的ORIGIN进行过滤,或者至少响应请求的来源(例如Access-Control-Allow-Origin:http://arunranga.com)。<br>另外,将发送Access-Control-Allow-Credentials:TRUE头信息，这在后续部分将进行讨论。</li></ul><h3 id=2-预请求>2. 预请求</h3><p>与前述简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。&ldquo;预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p><p>当请求满足下述任一条件时，即应首先发送预检请求：</p><p>(1). 使用了下面任一 HTTP 方法：</p><p>PUT<br>DELETE<br>CONNECT<br>OPTIONS<br>TRACE<br>PATCH</p><p>(2). 人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：</p><p>Accept<br>Accept-Language<br>Content-Language<br>Content-Type (but note the additional requirements below)<br>DPR<br>Downlink<br>Save-Data<br>Viewport-Width<br>Width</p><p>(3). Content-Type 的值不属于下列之一:</p><p>application/x-www-form-urlencoded<br>multipart/form-data<br>text/plain</p><p>(4). 请求中的XMLHttpRequestUpload 对象注册了任意多个事件监听器。<br>(5). 请求中使用了ReadableStream对象。</p><p>不同于上面讨论的简单请求，“预请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。 当请求具备以下条件，就会被当成预请求处理：</p><p><strong>（1）请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。<br>（2）使用自定义请求头（比如添加诸如 X-PINGOTHER）</strong></p><p>举个例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>invocation</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>XMLHttpRequest</span>();
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;http://bar.other/resources/post-here/&#39;</span>;
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>body</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;{C}{C}{C}{C}{C}{C}{C}{C}{C}{C}Arun&#39;</span>;
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>callOtherDomain</span>(){
  <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>invocation</span>){
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#39;POST&#39;</span>, <span style=color:#a6e22e>url</span>, <span style=color:#66d9ef>true</span>);
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>setRequestHeader</span>(<span style=color:#e6db74>&#39;X-PINGOTHER&#39;</span>, <span style=color:#e6db74>&#39;pingpong&#39;</span>);
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>setRequestHeader</span>(<span style=color:#e6db74>&#39;Content-Type&#39;</span>, <span style=color:#e6db74>&#39;application/xml&#39;</span>);
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>onreadystatechange</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>handler</span>;
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>body</span>); 
  }
}

</code></pre></div><p>如上，以 XMLHttpRequest 创建了一个 POST 请求，为该请求添加了一个自定义请求头(X-PINGOTHER: pingpong)，并指定数据类型为 application/xml。所以，该请求是一个“预请求”形式的跨站请求。浏览器使用一个 OPTIONS 发送了一个“预请求”。Firefox 3.1 根据请求参数，决定需要发送一个“预请求”，来探明服务器端是否接受后续真正的请求。 OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。 随同 OPTIONS 请求，以下两个请求头一起被发送：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>Access-Control-Request-Method: POST
</span><span style=color:#960050;background-color:#1e0010>Access-Control-Request-Headers: X-PINGOTHER
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>假设服务器成功响应返回部分信息如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>Access-Control-Allow-Origin: http://foo.example //表明服务器允许http://foo.example的请求
</span><span style=color:#960050;background-color:#1e0010>Access-Control-Allow-Methods: POST, GET, OPTIONS //表明服务器可以接受POST, GET和 OPTIONS的请求方法
</span><span style=color:#960050;background-color:#1e0010>Access-Control-Allow-Headers: X-PINGOTHER //传递一个可接受的自定义请求头列表。服务器也需要设置一个与浏览器对应。否则会报 Request header field X-Requested-With is not allowed by Access-Control-Allow-Headers in preflight response 的错误
</span><span style=color:#960050;background-color:#1e0010>Access-Control-Max-Age: 1728000 //告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_34.png alt></p><h3 id=3-附带凭证信息的请求>3. 附带凭证信息的请求</h3><p>Fetch 与 CORS 的一个有趣的特性是，可以基于 HTTP cookies 和 HTTP 认证信息发送身份凭证。一般而言，对于跨域 XMLHttpRequest 或 Fetch 请求，浏览器不会发送身份凭证信息。如果要发送凭证信息，需要设置 XMLHttpRequest 的某个特殊标志位。</p><p>本例中，http://foo.example 的某脚本向 <a href=http://bar.other>http://bar.other</a> 发起一个GET 请求，并设置 Cookies：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>invocation</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>XMLHttpRequest</span>();
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;http://bar.other/resources/credentialed-content/&#39;</span>;
    
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>callOtherDomain</span>(){
  <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>invocation</span>) {
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#39;GET&#39;</span>, <span style=color:#a6e22e>url</span>, <span style=color:#66d9ef>true</span>);
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>withCredentials</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>onreadystatechange</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>handler</span>;
    <span style=color:#a6e22e>invocation</span>.<span style=color:#a6e22e>send</span>(); 
  }
}

</code></pre></div><p>第 7 行将 XMLHttpRequest 的 withCredentials 标志设置为 true，从而向服务器发送 Cookies。因为这是一个简单 GET 请求，所以浏览器不会对其发起“预检请求”。但是，如果服务器端的响应中未携带 Access-Control-Allow-Credentials: true ，浏览器将不会把响应内容返回给请求的发送者。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/89_35.png alt></p><p>假设服务器成功响应返回部分信息如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#960050;background-color:#1e0010>Access-Control-Allow-Origin: http://foo.example
</span><span style=color:#960050;background-color:#1e0010>Access-Control-Allow-Credentials: true
</span><span style=color:#960050;background-color:#1e0010>Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT
</span></code></pre></div><p>如果bar.other的响应头里没有Access-Control-Allow-Credentials：true，则响应会被忽略.。特别注意: 给一个带有withCredentials的请求发送响应的时候，服务器端必须指定允许请求的域名,不能使用“*”。上面这个例子中，如果响应头是这样的 Access-Control-Allow-Origin：* ，则响应会失败。在这个例子里,因为Access-Control-Allow-Origin的值是 <a href=http://foo.example>http://foo.example</a> 这个指定的请求域名，所以客户端把带有凭证信息的内容被返回给了客户端。另外注意，更多的cookie信息也被创建了。</p><h2 id=九-cors-和-jsonp-对比>九. CORS 和 JSONP 对比</h2><ul><li><p>JSONP 只能实现 GET 请求，而 CORS 支持所有类型的 HTTP 请求。</p></li><li><p>使用 CORS，开发者可以使用普通的 XMLHttpRequest 发起请求和获得数据，比起 JSONP 有更好的错误处理。</p></li><li><p>JSONP 主要被老的浏览器支持，它们往往不支持 CORS，而绝大多数现代浏览器都已经支持了 CORS）。</p></li><li><p>CORS 与 JSONP 相比，无疑更为先进、方便和可靠。</p></li></ul><hr><p>Reference：<br>《图解 HTTP》<br>《HTTP 权威指南》<br><a href=https://tools.ietf.org/html/rfc2616>RFC2616</a><br><a href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS>HTTP访问控制（CORS）</a><br><a href=http://www.ruanyifeng.com/blog/2016/04/cors.html>跨域资源共享 CORS 详解</a></p><blockquote><p>GitHub Repo：<a href=https://github.com/halfrost/Halfrost-Field>Halfrost-Field</a></p><p>Follow: <a href=https://github.com/halfrost>halfrost · GitHub</a></p><p>Source: <a href=https://halfrost.com/http/>https://halfrost.com/http/</a></p></blockquote><img src=https://img.halfrost.com/wechat-qr-code.png></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div id=toc-footer style=display:none><nav id=TableOfContents><ul><li><a href=#一-http-支持的方法>一. HTTP 支持的方法</a></li><li><a href=#二-http-状态码>二. HTTP 状态码</a><ul><li><a href=#1xx-信息>1XX 信息</a></li><li><a href=#2xx-成功>2XX 成功</a></li><li><a href=#3xx-重定向>3XX 重定向</a></li><li><a href=#4xx-客户端错误>4XX 客户端错误</a></li><li><a href=#5xx-服务器错误>5XX 服务器错误</a></li></ul></li><li><a href=#rfc-2616-状态码>RFC 2616 状态码</a></li><li><a href=#三-mime-媒体内容>三. MIME 媒体内容</a></li><li><a href=#四-http-报文结构>四. HTTP 报文结构</a><ul><li><a href=#1-通用首部>1. 通用首部</a></li><li><a href=#http-缓存控制>HTTP 缓存控制</a></li><li><a href=#2-请求首部>2. 请求首部</a></li><li><a href=#请求信息性首部>请求信息性首部</a></li><li><a href=#accept-首部>Accept 首部</a></li><li><a href=#条件请求首部>条件请求首部</a></li><li><a href=#安全请求首部>安全请求首部</a></li><li><a href=#代理请求首部>代理请求首部</a></li><li><a href=#3-响应首部>3. 响应首部</a></li><li><a href=#响应信息性首部>响应信息性首部</a></li><li><a href=#协商首部>协商首部</a></li><li><a href=#安全响应首部>安全响应首部</a></li><li><a href=#4-实体首部>4. 实体首部</a></li><li><a href=#实体信息性首部>实体信息性首部</a></li><li><a href=#内容首部>内容首部</a></li><li><a href=#实体缓存首部>实体缓存首部</a></li><li><a href=#5-扩展首部>5. 扩展首部</a></li><li><a href=#1x-frame-options>（1）X-Frame-Options</a></li><li><a href=#2x-xss-protection>（2）X-XSS-Protection</a></li><li><a href=#3dnt>（3）DNT</a></li><li><a href=#4p3p>（4）P3P</a></li></ul></li><li><a href=#五-提高-http-性能>五. 提高 HTTP 性能</a><ul><li><a href=#1-并行连接>1. 并行连接</a></li><li><a href=#2-持久连接>2. 持久连接</a></li><li><a href=#3-管道化连接>3. 管道化连接</a></li><li><a href=#4-复用的连接>4. 复用的连接</a></li></ul></li><li><a href=#六-get-和-post-的区别>六. GET 和 POST 的区别</a></li><li><a href=#参数>参数</a></li><li><a href=#安全>安全</a></li><li><a href=#幂等性>幂等性</a></li><li><a href=#可缓存>可缓存</a></li><li><a href=#xmlhttprequest>XMLHttpRequest</a></li><li><a href=#七-http-各版本比较>七. HTTP 各版本比较</a></li><li><a href=#http10-与-http11-的区别>HTTP/1.0 与 HTTP/1.1 的区别</a></li><li><a href=#http11-与-http20-的区别>HTTP/1.1 与 HTTP/2.0 的区别</a><ul><li><a href=#1-多路复用>1. 多路复用</a></li><li><a href=#2-首部压缩>2. 首部压缩</a></li><li><a href=#3-服务端推送>3. 服务端推送</a></li><li><a href=#4-二进制格式>4. 二进制格式</a></li></ul></li><li><a href=#八-cors-跨域>八. CORS 跨域</a><ul><li><a href=#1-简单请求>1. 简单请求</a></li><li><a href=#2-预请求>2. 预请求</a></li><li><a href=#3-附带凭证信息的请求>3. 附带凭证信息的请求</a></li></ul></li><li><a href=#九-cors-和-jsonp-对比>九. CORS 和 JSONP 对比</a></li></ul></nav></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fhttp%2f"><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&text=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&title=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&is_video=false&description=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=HTTP%20%e6%8c%87%e5%8d%97&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fhttp%2f"><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&title=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&title=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&title=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-stumbleupon fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&title=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-digg fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&name=HTTP%20%e6%8c%87%e5%8d%97&description=Web%20%e4%bd%bf%e7%94%a8%e4%b8%80%e7%a7%8d%e5%90%8d%e4%b8%ba%20HTTP%20%28HyperText%20Transfer%20Protocol%ef%bc%8c%e8%b6%85%e6%96%87%e6%9c%ac%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae%29%20%e7%9a%84%e5%8d%8f%e8%ae%ae%e4%bd%9c%e4%b8%ba%e8%a7%84%e8%8c%83%e7%9a%84%e3%80%82%0a%20HTTP%20%e6%9b%b4%e5%8a%a0%e4%b8%a5%e8%b0%a8%e7%9a%84%e8%af%91%e5%90%8d%e5%ba%94%e8%af%a5%e6%98%af%20%e8%b6%85%e6%96%87%e6%9c%ac%e8%bd%ac%e7%a7%bb%e5%8d%8f%e8%ae%ae%e3%80%82%0a%20HTTP%20%e4%ba%8e%201990%20%e5%b9%b4%e9%97%ae%e4%b8%96%e3%80%82%e9%82%a3%e6%97%b6%e7%9a%84%20HTTP%20%e5%b9%b6%e6%b2%a1%e6%9c%89%e4%bd%9c%e4%b8%ba%e6%ad%a3%e5%bc%8f%e7%9a%84%e6%a0%87%e5%87%86%ef%bc%8c%e5%9b%a0%e4%b8%ba%e8%a2%ab%e7%a7%b0%e4%b8%ba%20HTTP%2f0.9%0aHTTP%20%e6%ad%a3%e5%bc%8f%e4%bd%9c%e4%b8%ba%e6%a0%87%e5%87%86%e8%a2%ab%e5%85%ac%e5%b8%83%e6%98%af%201996%20%e5%b9%b4%205%20%e6%9c%88%ef%bc%8c%e7%89%88%e6%9c%ac%e5%91%bd%e5%90%8d%e4%b8%ba%20HTTP%2f1.0%ef%bc%8c%e8%ae%b0%e8%bd%bd%e4%ba%8e%20RFC1945%0aHTTP%20%e5%9c%a8%201997%20%e5%b9%b4%201%20%e6%9c%88%e5%85%ac%e5%b8%83%e4%ba%86%e5%bd%93%e5%89%8d%e6%9c%80%e4%b8%bb%e6%b5%81%e7%9a%84%e7%89%88%e6%9c%ac%ef%bc%8c%e7%89%88%e6%9c%ac%e5%91%bd%e5%90%8d%e4%b8%ba%20HTTP%2f1.1%ef%bc%8c%e8%ae%b0%e8%bd%bd%e4%ba%8e%20RFC2616%0aHTTP%2f2%20%e4%ba%8e%202015%20%e5%b9%b4%205%20%e6%9c%88%2014%20%e6%97%a5%e5%8f%91%e5%b8%83%ef%bc%8c%e5%bc%95%e5%85%a5%e4%ba%86%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%8e%a8%e9%80%81%e7%ad%89%e5%a4%9a%e7%a7%8d%e5%8a%9f%e8%83%bd%ef%bc%8c%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e6%96%b0%e7%9a%84%e7%89%88%e6%9c%ac%e3%80%82%e8%ae%b0%e8%bd%bd%e4%ba%8e%20RFC7540%20%28%e5%ae%83%e4%b8%8d%e5%8f%ab%20HTTP%2f2.0%ef%bc%8c%e6%98%af%e5%9b%a0%e4%b8%ba%e6%a0%87%e5%87%86%e5%a7%94%e5%91%98%e4%bc%9a%e4%b8%8d%e6%89%93%e7%ae%97%e5%86%8d%e5%8f%91%e5%b8%83%e5%ad%90%e7%89%88%e6%9c%ac%e4%ba%86%ef%bc%8c%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%96%b0%e7%89%88%e6%9c%ac%e5%b0%86%e6%98%af%20HTTP%2f3%29%0a%e4%b8%80.%20HTTP%20%e6%94%af%e6%8c%81%e7%9a%84%e6%96%b9%e6%b3%95%20HTTP%20%e6%98%af%e4%b8%80%e7%a7%8d%e4%b8%8d%e4%bf%9d%e5%ad%98%e7%8a%b6%e6%80%81%ef%bc%8c%e5%8d%b3%20%e6%97%a0%e7%8a%b6%e6%80%81%ef%bc%88%20stateless%20%ef%bc%89%e5%8d%8f%e8%ae%ae%e3%80%82HTTP%20%e5%8d%8f%e8%ae%ae%e8%87%aa%e8%ba%ab%e4%b8%8d%e5%af%b9%e8%af%b7%e6%b1%82%e5%92%8c%e5%93%8d%e5%ba%94%e4%b9%8b%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1%e7%8a%b6%e6%80%81%e8%bf%9b%e8%a1%8c%e4%bf%9d%e5%ad%98%e3%80%82%e4%b9%9f%e5%b0%b1%e6%98%af%e8%af%b4%e5%9c%a8%20HTTP%20%e8%bf%99%e4%b8%aa%e7%ba%a7%e5%88%ab%ef%bc%8c%e5%8d%8f%e8%ae%ae%e5%af%b9%e4%ba%8e%e5%8f%91%e9%80%81%e8%bf%87%e7%9a%84%e8%af%b7%e6%b1%82%e6%88%96%e5%93%8d%e5%ba%94%e9%83%bd%e4%b8%8d%e5%81%9a%e6%8c%81%e4%b9%85%e5%8c%96%e5%a4%84%e7%90%86%e3%80%82%e8%bf%99%e4%b9%9f%e6%98%af%e4%b8%ba%e4%ba%86%e6%9b%b4%e5%bf%ab%e7%9a%84%e5%a4%84%e7%90%86%e5%a4%a7%e9%87%8f%e4%ba%8b%e5%8a%a1%ef%bc%8c%e7%a1%ae%e4%bf%9d%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7%e3%80%82%0aHTTP%2f1.1%20%e8%99%bd%e7%84%b6%e6%98%af%e6%97%a0%e7%8a%b6%e6%80%81%e5%8d%8f%e8%ae%ae%ef%bc%8c%e4%bd%86%e6%98%af%e4%b8%ba%e4%ba%86%e5%ae%9e%e7%8e%b0%e6%9c%9f%e6%9c%9b%e7%9a%84%e4%bf%9d%e6%8c%81%e7%8a%b6%e6%80%81%e7%9a%84%e5%8a%9f%e8%83%bd%ef%bc%8c%e7%89%b9%e6%84%8f%e5%bc%95%e5%85%a5%e4%ba%86%20Cookie%20%e6%8a%80%e6%9c%af%e3%80%82%0a%e5%9c%a8HTTP%2f1.1%e8%a7%84%e8%8c%83%e4%b8%ad%e5%b9%82%e7%ad%89%e6%80%a7%e7%9a%84%e5%ae%9a%e4%b9%89%e6%98%af%ef%bc%9a%0a%20Methods%20can%20also%20have%20the%20property%20of%20%26ldquo%3bidempotence%26rdquo%3b%20in%20that%20%28aside%20from%20error%20or%20expiration%20issues%29%20the%20side-effects%20of%20N%20%26gt%3b%200%20identical%20requests%20is%20the%20same%20as%20for%20a%20single%20request."><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fhttp%2f&t=HTTP%20%e6%8c%87%e5%8d%97"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu class=icon href=# onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden=true></i>Menu</a>
<a id=toc class=icon href=# onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden=true></i>TOC</a>
<a id=share class=icon href=# onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden=true></i>share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i>Top</a></div></div></div><footer id=footer><div class=footer-left><p class=copyright style=float:left;margin-bottom:0><a href=https://github.com/halfrost/Halfrost-Field class=github-repo style=height:18px><span class=gadget-github></span>Star</a>
Copyright &copy;halfrost 2016 - 2021
<a href=http://www.miit.gov.cn/>鄂ICP备16014744号</a></p><br><p class="copyright statistics" style=margin-bottom:20px><span id=busuanzi_container_site_pv>Cumulative Page Views <span id=busuanzi_value_site_pv></span>| Unique Visitors <span id=busuanzi_value_site_uv></span></span></p></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/main.min.f870a4d110314b9e50e65f8ac982dc1c9c376c8f1a5083d39c62cfc49073f011.js></script><script async src=/prism.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>
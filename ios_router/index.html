<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=theme-color content="#FFFFFF"><meta http-equiv=x-ua-compatible content="IE=edge"><title>iOS 组件化 —— 路由设计思路分析 | prometheus</title><meta name=description content="Explore in every moment of the hard thinking"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="iOS 组件化 —— 路由设计思路分析"><meta property="og:description" content="前言 随着用户的需求越来越多，对App的用户体验也变的要求越来越高。为了更好的应对各种需求，开发人员从软件工程的角度，将App架构由原来简单的MVC变成MVVM，VIPER等复杂架构。更换适合业务的架构，是为了后期能更好的维护项目。
但是用户依旧不满意，继续对开发人员提出了更多更高的要求，不仅需要高质量的用户体验，还要求快速迭代，最好一天出一个新功能，而且用户还要求不更新就能体验到新功能。为了满足用户需求，于是开发人员就用H5，ReactNative，Weex等技术对已有的项目进行改造。项目架构也变得更加的复杂，纵向的会进行分层，网络层，UI层，数据持久层。每一层横向的也会根据业务进行组件化。尽管这样做了以后会让开发更加有效率，更加好维护，但是如何解耦各层，解耦各个界面和各个组件，降低各个组件之间的耦合度，如何能让整个系统不管多么复杂的情况下都能保持“高内聚，低耦合”的特点？这一系列的问题都摆在开发人员面前，亟待解决。今天就来谈谈解决这个问题的一些思路。
目录  1.引子 2.App路由能解决哪些问题 3.App之间跳转实现 4.App内组件间路由设计 5.各个方案优缺点 6.最好的方案  一. 引子 大前端发展这么多年了，相信也一定会遇到相似的问题。近两年SPA发展极其迅猛，React 和 Vue一直处于风口浪尖，那我们就看看他们是如何处理好这一问题的。
在SPA单页面应用，路由起到了很关键的作用。路由的作用主要是保证视图和 URL 的同步。在前端的眼里看来，视图是被看成是资源的一种表现。当用户在页面中进行操作时，应用会在若干个交互状态中切换，路由则可以记录下某些重要的状态，比如用户查看一个网站，用户是否登录、在访问网站的哪一个页面。而这些变化同样会被记录在浏览器的历史中，用户可以通过浏览器的前进、后退按钮切换状态。总的来说，用户可以通过手动输入或者与页面进行交互来改变 URL，然后通过同步或者异步的方式向服务端发送请求获取资源，成功后重新绘制 UI，原理如下图所示：
react-router通过传入的location到最终渲染新的UI，流程如下：
location的来源有2种，一种是浏览器的回退和前进，另外一种是直接点了一个链接。新的 location 对象后，路由内部的 matchRoutes 方法会匹配出 Route 组件树中与当前 location 对象匹配的一个子集，并且得到了 nextState，在this.setState(nextState) 时就可以实现重新渲染 Router 组件。
大前端的做法大概是这样的，我们可以把这些思想借鉴到iOS这边来。上图中的Back / Forward 在iOS这边很多情况下都可以被UINavgation所管理。所以iOS的Router主要处理绿色的那一块。
二. App路由能解决哪些问题 既然前端能在SPA上解决URL和UI的同步问题，那这种思想可以在App上解决哪些问题呢？
思考如下的问题，平时我们开发中是如何优雅的解决的：
1.3D-Touch功能或者点击推送消息，要求外部跳转到App内部一个很深层次的一个界面。
比如微信的3D-Touch可以直接跳转到“我的二维码”。“我的二维码”界面在我的里面的第三级界面。或者再极端一点，产品需求给了更加变态的需求，要求跳转到App内部第十层的界面，怎么处理？
2.自家的一系列App之间如何相互跳转？
如果自己App有几个，相互之间还想相互跳转，怎么处理？
3.如何解除App组件之间和App页面之间的耦合性？
随着项目越来越复杂，各个组件，各个页面之间的跳转逻辑关联性越来越多，如何能优雅的解除各个组件和页面之间的耦合性？
4.如何能统一iOS和Android两端的页面跳转逻辑？甚至如何能统一三端的请求资源的方式？
项目里面某些模块会混合ReactNative，Weex，H5界面，这些界面还会调用Native的界面，以及Native的组件。那么，如何能统一Web端和Native端请求资源的方式？
5.如果使用了动态下发配置文件来配置App的跳转逻辑，那么如果做到iOS和Android两边只要共用一套配置文件？
6.如果App出现bug了，如何不用JSPatch，就能做到简单的热修复功能？
比如App上线突然遇到了紧急bug，能否把页面动态降级成H5，ReactNative，Weex？或者是直接换成一个本地的错误界面？
7.如何在每个组件间调用和页面跳转时都进行埋点统计？每个跳转的地方都手写代码埋点？利用Runtime AOP ？
8.如何在每个组件间调用的过程中，加入调用的逻辑检查，令牌机制，配合灰度进行风控逻辑？
9.如何在App任何界面都可以调用同一个界面或者同一个组件？只能在AppDelegate里面注册单例来实现？
比如App出现问题了，用户可能在任何界面，如何随时随地的让用户强制登出？或者强制都跳转到同一个本地的error界面？或者跳转到相应的H5，ReactNative，Weex界面？如何让用户在任何界面，随时随地的弹出一个View ？
以上这些问题其实都可以通过在App端设计一个路由来解决。那么我们怎么设计一个路由呢？
三. App之间跳转实现 在谈App内部的路由之前，先来谈谈在iOS系统间，不同App之间是怎么实现跳转的。
1. URL Scheme方式 iOS系统是默认支持URL Scheme的，具体见官方文档。"><meta property="og:type" content="article"><meta property="og:url" content="https://new.halfrost.com/ios_router/"><meta property="article:published_time" content="2017-02-25T03:39:00+00:00"><meta property="article:modified_time" content="2017-02-25T03:39:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="iOS 组件化 —— 路由设计思路分析"><meta name=twitter:description content="前言 随着用户的需求越来越多，对App的用户体验也变的要求越来越高。为了更好的应对各种需求，开发人员从软件工程的角度，将App架构由原来简单的MVC变成MVVM，VIPER等复杂架构。更换适合业务的架构，是为了后期能更好的维护项目。
但是用户依旧不满意，继续对开发人员提出了更多更高的要求，不仅需要高质量的用户体验，还要求快速迭代，最好一天出一个新功能，而且用户还要求不更新就能体验到新功能。为了满足用户需求，于是开发人员就用H5，ReactNative，Weex等技术对已有的项目进行改造。项目架构也变得更加的复杂，纵向的会进行分层，网络层，UI层，数据持久层。每一层横向的也会根据业务进行组件化。尽管这样做了以后会让开发更加有效率，更加好维护，但是如何解耦各层，解耦各个界面和各个组件，降低各个组件之间的耦合度，如何能让整个系统不管多么复杂的情况下都能保持“高内聚，低耦合”的特点？这一系列的问题都摆在开发人员面前，亟待解决。今天就来谈谈解决这个问题的一些思路。
目录  1.引子 2.App路由能解决哪些问题 3.App之间跳转实现 4.App内组件间路由设计 5.各个方案优缺点 6.最好的方案  一. 引子 大前端发展这么多年了，相信也一定会遇到相似的问题。近两年SPA发展极其迅猛，React 和 Vue一直处于风口浪尖，那我们就看看他们是如何处理好这一问题的。
在SPA单页面应用，路由起到了很关键的作用。路由的作用主要是保证视图和 URL 的同步。在前端的眼里看来，视图是被看成是资源的一种表现。当用户在页面中进行操作时，应用会在若干个交互状态中切换，路由则可以记录下某些重要的状态，比如用户查看一个网站，用户是否登录、在访问网站的哪一个页面。而这些变化同样会被记录在浏览器的历史中，用户可以通过浏览器的前进、后退按钮切换状态。总的来说，用户可以通过手动输入或者与页面进行交互来改变 URL，然后通过同步或者异步的方式向服务端发送请求获取资源，成功后重新绘制 UI，原理如下图所示：
react-router通过传入的location到最终渲染新的UI，流程如下：
location的来源有2种，一种是浏览器的回退和前进，另外一种是直接点了一个链接。新的 location 对象后，路由内部的 matchRoutes 方法会匹配出 Route 组件树中与当前 location 对象匹配的一个子集，并且得到了 nextState，在this.setState(nextState) 时就可以实现重新渲染 Router 组件。
大前端的做法大概是这样的，我们可以把这些思想借鉴到iOS这边来。上图中的Back / Forward 在iOS这边很多情况下都可以被UINavgation所管理。所以iOS的Router主要处理绿色的那一块。
二. App路由能解决哪些问题 既然前端能在SPA上解决URL和UI的同步问题，那这种思想可以在App上解决哪些问题呢？
思考如下的问题，平时我们开发中是如何优雅的解决的：
1.3D-Touch功能或者点击推送消息，要求外部跳转到App内部一个很深层次的一个界面。
比如微信的3D-Touch可以直接跳转到“我的二维码”。“我的二维码”界面在我的里面的第三级界面。或者再极端一点，产品需求给了更加变态的需求，要求跳转到App内部第十层的界面，怎么处理？
2.自家的一系列App之间如何相互跳转？
如果自己App有几个，相互之间还想相互跳转，怎么处理？
3.如何解除App组件之间和App页面之间的耦合性？
随着项目越来越复杂，各个组件，各个页面之间的跳转逻辑关联性越来越多，如何能优雅的解除各个组件和页面之间的耦合性？
4.如何能统一iOS和Android两端的页面跳转逻辑？甚至如何能统一三端的请求资源的方式？
项目里面某些模块会混合ReactNative，Weex，H5界面，这些界面还会调用Native的界面，以及Native的组件。那么，如何能统一Web端和Native端请求资源的方式？
5.如果使用了动态下发配置文件来配置App的跳转逻辑，那么如果做到iOS和Android两边只要共用一套配置文件？
6.如果App出现bug了，如何不用JSPatch，就能做到简单的热修复功能？
比如App上线突然遇到了紧急bug，能否把页面动态降级成H5，ReactNative，Weex？或者是直接换成一个本地的错误界面？
7.如何在每个组件间调用和页面跳转时都进行埋点统计？每个跳转的地方都手写代码埋点？利用Runtime AOP ？
8.如何在每个组件间调用的过程中，加入调用的逻辑检查，令牌机制，配合灰度进行风控逻辑？
9.如何在App任何界面都可以调用同一个界面或者同一个组件？只能在AppDelegate里面注册单例来实现？
比如App出现问题了，用户可能在任何界面，如何随时随地的让用户强制登出？或者强制都跳转到同一个本地的error界面？或者跳转到相应的H5，ReactNative，Weex界面？如何让用户在任何界面，随时随地的弹出一个View ？
以上这些问题其实都可以通过在App端设计一个路由来解决。那么我们怎么设计一个路由呢？
三. App之间跳转实现 在谈App内部的路由之前，先来谈谈在iOS系统间，不同App之间是怎么实现跳转的。
1. URL Scheme方式 iOS系统是默认支持URL Scheme的，具体见官方文档。"><link rel=stylesheet href=/css/style-white.min.css><link rel=manifest href=/manifest.json><link rel=stylesheet href=/prism.css><link href=/images/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=/images/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=/images/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=/images/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=/images/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=/images/apple-touch-icon-512x512.png rel=apple-touch-icon sizes=512x512><link href=/images/apple-touch-icon-1024x1024.png rel=apple-touch-icon sizes=1024x1024><script async>if('serviceWorker'in navigator){navigator.serviceWorker.register("\/serviceworker-v1.min.a64912b78d282eab1ad3715a0943da21616e5f326f8afea27034784ad445043b.js").then(function(){if(navigator.serviceWorker.controller){console.log('Assets cached by the controlling service worker.');}else{console.log('Please reload this page to allow the service worker to handle network operations.');}}).catch(function(error){console.log('ERROR: '+error);});}else{console.log('Service workers are not supported in the current browser.');}</script><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://new.halfrost.com/images/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-82753806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="single-max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a><a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a><a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast');" style=display:none><i class="fas fa-chevron-up fa-lg"></i></a><span id=menu><span id=nav><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://new.halfrost.com/advance_tcp/><i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li><li><a class=icon href=https://new.halfrost.com/beehive/><i class="fas fa-chevron-right" aria-hidden=true onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li><li><a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li><li><a class=icon href=#><i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fios_router%2f"><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&text=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&title=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&is_video=false&description=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fios_router%2f"><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&title=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&title=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&title=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-stumbleupon" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&title=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-digg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&name=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90&description=%e5%89%8d%e8%a8%80%20%e9%9a%8f%e7%9d%80%e7%94%a8%e6%88%b7%e7%9a%84%e9%9c%80%e6%b1%82%e8%b6%8a%e6%9d%a5%e8%b6%8a%e5%a4%9a%ef%bc%8c%e5%af%b9App%e7%9a%84%e7%94%a8%e6%88%b7%e4%bd%93%e9%aa%8c%e4%b9%9f%e5%8f%98%e7%9a%84%e8%a6%81%e6%b1%82%e8%b6%8a%e6%9d%a5%e8%b6%8a%e9%ab%98%e3%80%82%e4%b8%ba%e4%ba%86%e6%9b%b4%e5%a5%bd%e7%9a%84%e5%ba%94%e5%af%b9%e5%90%84%e7%a7%8d%e9%9c%80%e6%b1%82%ef%bc%8c%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98%e4%bb%8e%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e7%9a%84%e8%a7%92%e5%ba%a6%ef%bc%8c%e5%b0%86App%e6%9e%b6%e6%9e%84%e7%94%b1%e5%8e%9f%e6%9d%a5%e7%ae%80%e5%8d%95%e7%9a%84MVC%e5%8f%98%e6%88%90MVVM%ef%bc%8cVIPER%e7%ad%89%e5%a4%8d%e6%9d%82%e6%9e%b6%e6%9e%84%e3%80%82%e6%9b%b4%e6%8d%a2%e9%80%82%e5%90%88%e4%b8%9a%e5%8a%a1%e7%9a%84%e6%9e%b6%e6%9e%84%ef%bc%8c%e6%98%af%e4%b8%ba%e4%ba%86%e5%90%8e%e6%9c%9f%e8%83%bd%e6%9b%b4%e5%a5%bd%e7%9a%84%e7%bb%b4%e6%8a%a4%e9%a1%b9%e7%9b%ae%e3%80%82%0a%e4%bd%86%e6%98%af%e7%94%a8%e6%88%b7%e4%be%9d%e6%97%a7%e4%b8%8d%e6%bb%a1%e6%84%8f%ef%bc%8c%e7%bb%a7%e7%bb%ad%e5%af%b9%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98%e6%8f%90%e5%87%ba%e4%ba%86%e6%9b%b4%e5%a4%9a%e6%9b%b4%e9%ab%98%e7%9a%84%e8%a6%81%e6%b1%82%ef%bc%8c%e4%b8%8d%e4%bb%85%e9%9c%80%e8%a6%81%e9%ab%98%e8%b4%a8%e9%87%8f%e7%9a%84%e7%94%a8%e6%88%b7%e4%bd%93%e9%aa%8c%ef%bc%8c%e8%bf%98%e8%a6%81%e6%b1%82%e5%bf%ab%e9%80%9f%e8%bf%ad%e4%bb%a3%ef%bc%8c%e6%9c%80%e5%a5%bd%e4%b8%80%e5%a4%a9%e5%87%ba%e4%b8%80%e4%b8%aa%e6%96%b0%e5%8a%9f%e8%83%bd%ef%bc%8c%e8%80%8c%e4%b8%94%e7%94%a8%e6%88%b7%e8%bf%98%e8%a6%81%e6%b1%82%e4%b8%8d%e6%9b%b4%e6%96%b0%e5%b0%b1%e8%83%bd%e4%bd%93%e9%aa%8c%e5%88%b0%e6%96%b0%e5%8a%9f%e8%83%bd%e3%80%82%e4%b8%ba%e4%ba%86%e6%bb%a1%e8%b6%b3%e7%94%a8%e6%88%b7%e9%9c%80%e6%b1%82%ef%bc%8c%e4%ba%8e%e6%98%af%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98%e5%b0%b1%e7%94%a8H5%ef%bc%8cReactNative%ef%bc%8cWeex%e7%ad%89%e6%8a%80%e6%9c%af%e5%af%b9%e5%b7%b2%e6%9c%89%e7%9a%84%e9%a1%b9%e7%9b%ae%e8%bf%9b%e8%a1%8c%e6%94%b9%e9%80%a0%e3%80%82%e9%a1%b9%e7%9b%ae%e6%9e%b6%e6%9e%84%e4%b9%9f%e5%8f%98%e5%be%97%e6%9b%b4%e5%8a%a0%e7%9a%84%e5%a4%8d%e6%9d%82%ef%bc%8c%e7%ba%b5%e5%90%91%e7%9a%84%e4%bc%9a%e8%bf%9b%e8%a1%8c%e5%88%86%e5%b1%82%ef%bc%8c%e7%bd%91%e7%bb%9c%e5%b1%82%ef%bc%8cUI%e5%b1%82%ef%bc%8c%e6%95%b0%e6%8d%ae%e6%8c%81%e4%b9%85%e5%b1%82%e3%80%82%e6%af%8f%e4%b8%80%e5%b1%82%e6%a8%aa%e5%90%91%e7%9a%84%e4%b9%9f%e4%bc%9a%e6%a0%b9%e6%8d%ae%e4%b8%9a%e5%8a%a1%e8%bf%9b%e8%a1%8c%e7%bb%84%e4%bb%b6%e5%8c%96%e3%80%82%e5%b0%bd%e7%ae%a1%e8%bf%99%e6%a0%b7%e5%81%9a%e4%ba%86%e4%bb%a5%e5%90%8e%e4%bc%9a%e8%ae%a9%e5%bc%80%e5%8f%91%e6%9b%b4%e5%8a%a0%e6%9c%89%e6%95%88%e7%8e%87%ef%bc%8c%e6%9b%b4%e5%8a%a0%e5%a5%bd%e7%bb%b4%e6%8a%a4%ef%bc%8c%e4%bd%86%e6%98%af%e5%a6%82%e4%bd%95%e8%a7%a3%e8%80%a6%e5%90%84%e5%b1%82%ef%bc%8c%e8%a7%a3%e8%80%a6%e5%90%84%e4%b8%aa%e7%95%8c%e9%9d%a2%e5%92%8c%e5%90%84%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%8c%e9%99%8d%e4%bd%8e%e5%90%84%e4%b8%aa%e7%bb%84%e4%bb%b6%e4%b9%8b%e9%97%b4%e7%9a%84%e8%80%a6%e5%90%88%e5%ba%a6%ef%bc%8c%e5%a6%82%e4%bd%95%e8%83%bd%e8%ae%a9%e6%95%b4%e4%b8%aa%e7%b3%bb%e7%bb%9f%e4%b8%8d%e7%ae%a1%e5%a4%9a%e4%b9%88%e5%a4%8d%e6%9d%82%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%e9%83%bd%e8%83%bd%e4%bf%9d%e6%8c%81%e2%80%9c%e9%ab%98%e5%86%85%e8%81%9a%ef%bc%8c%e4%bd%8e%e8%80%a6%e5%90%88%e2%80%9d%e7%9a%84%e7%89%b9%e7%82%b9%ef%bc%9f%e8%bf%99%e4%b8%80%e7%b3%bb%e5%88%97%e7%9a%84%e9%97%ae%e9%a2%98%e9%83%bd%e6%91%86%e5%9c%a8%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98%e9%9d%a2%e5%89%8d%ef%bc%8c%e4%ba%9f%e5%be%85%e8%a7%a3%e5%86%b3%e3%80%82%e4%bb%8a%e5%a4%a9%e5%b0%b1%e6%9d%a5%e8%b0%88%e8%b0%88%e8%a7%a3%e5%86%b3%e8%bf%99%e4%b8%aa%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%80%e4%ba%9b%e6%80%9d%e8%b7%af%e3%80%82%0a%e7%9b%ae%e5%bd%95%20%201.%e5%bc%95%e5%ad%90%202.App%e8%b7%af%e7%94%b1%e8%83%bd%e8%a7%a3%e5%86%b3%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98%203.App%e4%b9%8b%e9%97%b4%e8%b7%b3%e8%bd%ac%e5%ae%9e%e7%8e%b0%204.App%e5%86%85%e7%bb%84%e4%bb%b6%e9%97%b4%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%205.%e5%90%84%e4%b8%aa%e6%96%b9%e6%a1%88%e4%bc%98%e7%bc%ba%e7%82%b9%206.%e6%9c%80%e5%a5%bd%e7%9a%84%e6%96%b9%e6%a1%88%20%20%e4%b8%80.%20%e5%bc%95%e5%ad%90%20%e5%a4%a7%e5%89%8d%e7%ab%af%e5%8f%91%e5%b1%95%e8%bf%99%e4%b9%88%e5%a4%9a%e5%b9%b4%e4%ba%86%ef%bc%8c%e7%9b%b8%e4%bf%a1%e4%b9%9f%e4%b8%80%e5%ae%9a%e4%bc%9a%e9%81%87%e5%88%b0%e7%9b%b8%e4%bc%bc%e7%9a%84%e9%97%ae%e9%a2%98%e3%80%82%e8%bf%91%e4%b8%a4%e5%b9%b4SPA%e5%8f%91%e5%b1%95%e6%9e%81%e5%85%b6%e8%bf%85%e7%8c%9b%ef%bc%8cReact%20%e5%92%8c%20Vue%e4%b8%80%e7%9b%b4%e5%a4%84%e4%ba%8e%e9%a3%8e%e5%8f%a3%e6%b5%aa%e5%b0%96%ef%bc%8c%e9%82%a3%e6%88%91%e4%bb%ac%e5%b0%b1%e7%9c%8b%e7%9c%8b%e4%bb%96%e4%bb%ac%e6%98%af%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e5%a5%bd%e8%bf%99%e4%b8%80%e9%97%ae%e9%a2%98%e7%9a%84%e3%80%82%0a%e5%9c%a8SPA%e5%8d%95%e9%a1%b5%e9%9d%a2%e5%ba%94%e7%94%a8%ef%bc%8c%e8%b7%af%e7%94%b1%e8%b5%b7%e5%88%b0%e4%ba%86%e5%be%88%e5%85%b3%e9%94%ae%e7%9a%84%e4%bd%9c%e7%94%a8%e3%80%82%e8%b7%af%e7%94%b1%e7%9a%84%e4%bd%9c%e7%94%a8%e4%b8%bb%e8%a6%81%e6%98%af%e4%bf%9d%e8%af%81%e8%a7%86%e5%9b%be%e5%92%8c%20URL%20%e7%9a%84%e5%90%8c%e6%ad%a5%e3%80%82%e5%9c%a8%e5%89%8d%e7%ab%af%e7%9a%84%e7%9c%bc%e9%87%8c%e7%9c%8b%e6%9d%a5%ef%bc%8c%e8%a7%86%e5%9b%be%e6%98%af%e8%a2%ab%e7%9c%8b%e6%88%90%e6%98%af%e8%b5%84%e6%ba%90%e7%9a%84%e4%b8%80%e7%a7%8d%e8%a1%a8%e7%8e%b0%e3%80%82%e5%bd%93%e7%94%a8%e6%88%b7%e5%9c%a8%e9%a1%b5%e9%9d%a2%e4%b8%ad%e8%bf%9b%e8%a1%8c%e6%93%8d%e4%bd%9c%e6%97%b6%ef%bc%8c%e5%ba%94%e7%94%a8%e4%bc%9a%e5%9c%a8%e8%8b%a5%e5%b9%b2%e4%b8%aa%e4%ba%a4%e4%ba%92%e7%8a%b6%e6%80%81%e4%b8%ad%e5%88%87%e6%8d%a2%ef%bc%8c%e8%b7%af%e7%94%b1%e5%88%99%e5%8f%af%e4%bb%a5%e8%ae%b0%e5%bd%95%e4%b8%8b%e6%9f%90%e4%ba%9b%e9%87%8d%e8%a6%81%e7%9a%84%e7%8a%b6%e6%80%81%ef%bc%8c%e6%af%94%e5%a6%82%e7%94%a8%e6%88%b7%e6%9f%a5%e7%9c%8b%e4%b8%80%e4%b8%aa%e7%bd%91%e7%ab%99%ef%bc%8c%e7%94%a8%e6%88%b7%e6%98%af%e5%90%a6%e7%99%bb%e5%bd%95%e3%80%81%e5%9c%a8%e8%ae%bf%e9%97%ae%e7%bd%91%e7%ab%99%e7%9a%84%e5%93%aa%e4%b8%80%e4%b8%aa%e9%a1%b5%e9%9d%a2%e3%80%82%e8%80%8c%e8%bf%99%e4%ba%9b%e5%8f%98%e5%8c%96%e5%90%8c%e6%a0%b7%e4%bc%9a%e8%a2%ab%e8%ae%b0%e5%bd%95%e5%9c%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%9a%84%e5%8e%86%e5%8f%b2%e4%b8%ad%ef%bc%8c%e7%94%a8%e6%88%b7%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87%e6%b5%8f%e8%a7%88%e5%99%a8%e7%9a%84%e5%89%8d%e8%bf%9b%e3%80%81%e5%90%8e%e9%80%80%e6%8c%89%e9%92%ae%e5%88%87%e6%8d%a2%e7%8a%b6%e6%80%81%e3%80%82%e6%80%bb%e7%9a%84%e6%9d%a5%e8%af%b4%ef%bc%8c%e7%94%a8%e6%88%b7%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87%e6%89%8b%e5%8a%a8%e8%be%93%e5%85%a5%e6%88%96%e8%80%85%e4%b8%8e%e9%a1%b5%e9%9d%a2%e8%bf%9b%e8%a1%8c%e4%ba%a4%e4%ba%92%e6%9d%a5%e6%94%b9%e5%8f%98%20URL%ef%bc%8c%e7%84%b6%e5%90%8e%e9%80%9a%e8%bf%87%e5%90%8c%e6%ad%a5%e6%88%96%e8%80%85%e5%bc%82%e6%ad%a5%e7%9a%84%e6%96%b9%e5%bc%8f%e5%90%91%e6%9c%8d%e5%8a%a1%e7%ab%af%e5%8f%91%e9%80%81%e8%af%b7%e6%b1%82%e8%8e%b7%e5%8f%96%e8%b5%84%e6%ba%90%ef%bc%8c%e6%88%90%e5%8a%9f%e5%90%8e%e9%87%8d%e6%96%b0%e7%bb%98%e5%88%b6%20UI%ef%bc%8c%e5%8e%9f%e7%90%86%e5%a6%82%e4%b8%8b%e5%9b%be%e6%89%80%e7%a4%ba%ef%bc%9a%0areact-router%e9%80%9a%e8%bf%87%e4%bc%a0%e5%85%a5%e7%9a%84location%e5%88%b0%e6%9c%80%e7%bb%88%e6%b8%b2%e6%9f%93%e6%96%b0%e7%9a%84UI%ef%bc%8c%e6%b5%81%e7%a8%8b%e5%a6%82%e4%b8%8b%ef%bc%9a%0alocation%e7%9a%84%e6%9d%a5%e6%ba%90%e6%9c%892%e7%a7%8d%ef%bc%8c%e4%b8%80%e7%a7%8d%e6%98%af%e6%b5%8f%e8%a7%88%e5%99%a8%e7%9a%84%e5%9b%9e%e9%80%80%e5%92%8c%e5%89%8d%e8%bf%9b%ef%bc%8c%e5%8f%a6%e5%a4%96%e4%b8%80%e7%a7%8d%e6%98%af%e7%9b%b4%e6%8e%a5%e7%82%b9%e4%ba%86%e4%b8%80%e4%b8%aa%e9%93%be%e6%8e%a5%e3%80%82%e6%96%b0%e7%9a%84%20location%20%e5%af%b9%e8%b1%a1%e5%90%8e%ef%bc%8c%e8%b7%af%e7%94%b1%e5%86%85%e9%83%a8%e7%9a%84%20matchRoutes%20%e6%96%b9%e6%b3%95%e4%bc%9a%e5%8c%b9%e9%85%8d%e5%87%ba%20Route%20%e7%bb%84%e4%bb%b6%e6%a0%91%e4%b8%ad%e4%b8%8e%e5%bd%93%e5%89%8d%20location%20%e5%af%b9%e8%b1%a1%e5%8c%b9%e9%85%8d%e7%9a%84%e4%b8%80%e4%b8%aa%e5%ad%90%e9%9b%86%ef%bc%8c%e5%b9%b6%e4%b8%94%e5%be%97%e5%88%b0%e4%ba%86%20nextState%ef%bc%8c%e5%9c%a8this.setState%28nextState%29%20%e6%97%b6%e5%b0%b1%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e9%87%8d%e6%96%b0%e6%b8%b2%e6%9f%93%20Router%20%e7%bb%84%e4%bb%b6%e3%80%82%0a%e5%a4%a7%e5%89%8d%e7%ab%af%e7%9a%84%e5%81%9a%e6%b3%95%e5%a4%a7%e6%a6%82%e6%98%af%e8%bf%99%e6%a0%b7%e7%9a%84%ef%bc%8c%e6%88%91%e4%bb%ac%e5%8f%af%e4%bb%a5%e6%8a%8a%e8%bf%99%e4%ba%9b%e6%80%9d%e6%83%b3%e5%80%9f%e9%89%b4%e5%88%b0iOS%e8%bf%99%e8%be%b9%e6%9d%a5%e3%80%82%e4%b8%8a%e5%9b%be%e4%b8%ad%e7%9a%84Back%20%2f%20Forward%20%e5%9c%a8iOS%e8%bf%99%e8%be%b9%e5%be%88%e5%a4%9a%e6%83%85%e5%86%b5%e4%b8%8b%e9%83%bd%e5%8f%af%e4%bb%a5%e8%a2%abUINavgation%e6%89%80%e7%ae%a1%e7%90%86%e3%80%82%e6%89%80%e4%bb%a5iOS%e7%9a%84Router%e4%b8%bb%e8%a6%81%e5%a4%84%e7%90%86%e7%bb%bf%e8%89%b2%e7%9a%84%e9%82%a3%e4%b8%80%e5%9d%97%e3%80%82%0a%e4%ba%8c.%20App%e8%b7%af%e7%94%b1%e8%83%bd%e8%a7%a3%e5%86%b3%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98%20%e6%97%a2%e7%84%b6%e5%89%8d%e7%ab%af%e8%83%bd%e5%9c%a8SPA%e4%b8%8a%e8%a7%a3%e5%86%b3URL%e5%92%8cUI%e7%9a%84%e5%90%8c%e6%ad%a5%e9%97%ae%e9%a2%98%ef%bc%8c%e9%82%a3%e8%bf%99%e7%a7%8d%e6%80%9d%e6%83%b3%e5%8f%af%e4%bb%a5%e5%9c%a8App%e4%b8%8a%e8%a7%a3%e5%86%b3%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98%e5%91%a2%ef%bc%9f%0a%e6%80%9d%e8%80%83%e5%a6%82%e4%b8%8b%e7%9a%84%e9%97%ae%e9%a2%98%ef%bc%8c%e5%b9%b3%e6%97%b6%e6%88%91%e4%bb%ac%e5%bc%80%e5%8f%91%e4%b8%ad%e6%98%af%e5%a6%82%e4%bd%95%e4%bc%98%e9%9b%85%e7%9a%84%e8%a7%a3%e5%86%b3%e7%9a%84%ef%bc%9a%0a1.3D-Touch%e5%8a%9f%e8%83%bd%e6%88%96%e8%80%85%e7%82%b9%e5%87%bb%e6%8e%a8%e9%80%81%e6%b6%88%e6%81%af%ef%bc%8c%e8%a6%81%e6%b1%82%e5%a4%96%e9%83%a8%e8%b7%b3%e8%bd%ac%e5%88%b0App%e5%86%85%e9%83%a8%e4%b8%80%e4%b8%aa%e5%be%88%e6%b7%b1%e5%b1%82%e6%ac%a1%e7%9a%84%e4%b8%80%e4%b8%aa%e7%95%8c%e9%9d%a2%e3%80%82%0a%e6%af%94%e5%a6%82%e5%be%ae%e4%bf%a1%e7%9a%843D-Touch%e5%8f%af%e4%bb%a5%e7%9b%b4%e6%8e%a5%e8%b7%b3%e8%bd%ac%e5%88%b0%e2%80%9c%e6%88%91%e7%9a%84%e4%ba%8c%e7%bb%b4%e7%a0%81%e2%80%9d%e3%80%82%e2%80%9c%e6%88%91%e7%9a%84%e4%ba%8c%e7%bb%b4%e7%a0%81%e2%80%9d%e7%95%8c%e9%9d%a2%e5%9c%a8%e6%88%91%e7%9a%84%e9%87%8c%e9%9d%a2%e7%9a%84%e7%ac%ac%e4%b8%89%e7%ba%a7%e7%95%8c%e9%9d%a2%e3%80%82%e6%88%96%e8%80%85%e5%86%8d%e6%9e%81%e7%ab%af%e4%b8%80%e7%82%b9%ef%bc%8c%e4%ba%a7%e5%93%81%e9%9c%80%e6%b1%82%e7%bb%99%e4%ba%86%e6%9b%b4%e5%8a%a0%e5%8f%98%e6%80%81%e7%9a%84%e9%9c%80%e6%b1%82%ef%bc%8c%e8%a6%81%e6%b1%82%e8%b7%b3%e8%bd%ac%e5%88%b0App%e5%86%85%e9%83%a8%e7%ac%ac%e5%8d%81%e5%b1%82%e7%9a%84%e7%95%8c%e9%9d%a2%ef%bc%8c%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86%ef%bc%9f%0a2.%e8%87%aa%e5%ae%b6%e7%9a%84%e4%b8%80%e7%b3%bb%e5%88%97App%e4%b9%8b%e9%97%b4%e5%a6%82%e4%bd%95%e7%9b%b8%e4%ba%92%e8%b7%b3%e8%bd%ac%ef%bc%9f%0a%e5%a6%82%e6%9e%9c%e8%87%aa%e5%b7%b1App%e6%9c%89%e5%87%a0%e4%b8%aa%ef%bc%8c%e7%9b%b8%e4%ba%92%e4%b9%8b%e9%97%b4%e8%bf%98%e6%83%b3%e7%9b%b8%e4%ba%92%e8%b7%b3%e8%bd%ac%ef%bc%8c%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86%ef%bc%9f%0a3.%e5%a6%82%e4%bd%95%e8%a7%a3%e9%99%a4App%e7%bb%84%e4%bb%b6%e4%b9%8b%e9%97%b4%e5%92%8cApp%e9%a1%b5%e9%9d%a2%e4%b9%8b%e9%97%b4%e7%9a%84%e8%80%a6%e5%90%88%e6%80%a7%ef%bc%9f%0a%e9%9a%8f%e7%9d%80%e9%a1%b9%e7%9b%ae%e8%b6%8a%e6%9d%a5%e8%b6%8a%e5%a4%8d%e6%9d%82%ef%bc%8c%e5%90%84%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%8c%e5%90%84%e4%b8%aa%e9%a1%b5%e9%9d%a2%e4%b9%8b%e9%97%b4%e7%9a%84%e8%b7%b3%e8%bd%ac%e9%80%bb%e8%be%91%e5%85%b3%e8%81%94%e6%80%a7%e8%b6%8a%e6%9d%a5%e8%b6%8a%e5%a4%9a%ef%bc%8c%e5%a6%82%e4%bd%95%e8%83%bd%e4%bc%98%e9%9b%85%e7%9a%84%e8%a7%a3%e9%99%a4%e5%90%84%e4%b8%aa%e7%bb%84%e4%bb%b6%e5%92%8c%e9%a1%b5%e9%9d%a2%e4%b9%8b%e9%97%b4%e7%9a%84%e8%80%a6%e5%90%88%e6%80%a7%ef%bc%9f%0a4.%e5%a6%82%e4%bd%95%e8%83%bd%e7%bb%9f%e4%b8%80iOS%e5%92%8cAndroid%e4%b8%a4%e7%ab%af%e7%9a%84%e9%a1%b5%e9%9d%a2%e8%b7%b3%e8%bd%ac%e9%80%bb%e8%be%91%ef%bc%9f%e7%94%9a%e8%87%b3%e5%a6%82%e4%bd%95%e8%83%bd%e7%bb%9f%e4%b8%80%e4%b8%89%e7%ab%af%e7%9a%84%e8%af%b7%e6%b1%82%e8%b5%84%e6%ba%90%e7%9a%84%e6%96%b9%e5%bc%8f%ef%bc%9f%0a%e9%a1%b9%e7%9b%ae%e9%87%8c%e9%9d%a2%e6%9f%90%e4%ba%9b%e6%a8%a1%e5%9d%97%e4%bc%9a%e6%b7%b7%e5%90%88ReactNative%ef%bc%8cWeex%ef%bc%8cH5%e7%95%8c%e9%9d%a2%ef%bc%8c%e8%bf%99%e4%ba%9b%e7%95%8c%e9%9d%a2%e8%bf%98%e4%bc%9a%e8%b0%83%e7%94%a8Native%e7%9a%84%e7%95%8c%e9%9d%a2%ef%bc%8c%e4%bb%a5%e5%8f%8aNative%e7%9a%84%e7%bb%84%e4%bb%b6%e3%80%82%e9%82%a3%e4%b9%88%ef%bc%8c%e5%a6%82%e4%bd%95%e8%83%bd%e7%bb%9f%e4%b8%80Web%e7%ab%af%e5%92%8cNative%e7%ab%af%e8%af%b7%e6%b1%82%e8%b5%84%e6%ba%90%e7%9a%84%e6%96%b9%e5%bc%8f%ef%bc%9f%0a5.%e5%a6%82%e6%9e%9c%e4%bd%bf%e7%94%a8%e4%ba%86%e5%8a%a8%e6%80%81%e4%b8%8b%e5%8f%91%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e6%9d%a5%e9%85%8d%e7%bd%aeApp%e7%9a%84%e8%b7%b3%e8%bd%ac%e9%80%bb%e8%be%91%ef%bc%8c%e9%82%a3%e4%b9%88%e5%a6%82%e6%9e%9c%e5%81%9a%e5%88%b0iOS%e5%92%8cAndroid%e4%b8%a4%e8%be%b9%e5%8f%aa%e8%a6%81%e5%85%b1%e7%94%a8%e4%b8%80%e5%a5%97%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%ef%bc%9f%0a6.%e5%a6%82%e6%9e%9cApp%e5%87%ba%e7%8e%b0bug%e4%ba%86%ef%bc%8c%e5%a6%82%e4%bd%95%e4%b8%8d%e7%94%a8JSPatch%ef%bc%8c%e5%b0%b1%e8%83%bd%e5%81%9a%e5%88%b0%e7%ae%80%e5%8d%95%e7%9a%84%e7%83%ad%e4%bf%ae%e5%a4%8d%e5%8a%9f%e8%83%bd%ef%bc%9f%0a%e6%af%94%e5%a6%82App%e4%b8%8a%e7%ba%bf%e7%aa%81%e7%84%b6%e9%81%87%e5%88%b0%e4%ba%86%e7%b4%a7%e6%80%a5bug%ef%bc%8c%e8%83%bd%e5%90%a6%e6%8a%8a%e9%a1%b5%e9%9d%a2%e5%8a%a8%e6%80%81%e9%99%8d%e7%ba%a7%e6%88%90H5%ef%bc%8cReactNative%ef%bc%8cWeex%ef%bc%9f%e6%88%96%e8%80%85%e6%98%af%e7%9b%b4%e6%8e%a5%e6%8d%a2%e6%88%90%e4%b8%80%e4%b8%aa%e6%9c%ac%e5%9c%b0%e7%9a%84%e9%94%99%e8%af%af%e7%95%8c%e9%9d%a2%ef%bc%9f%0a7.%e5%a6%82%e4%bd%95%e5%9c%a8%e6%af%8f%e4%b8%aa%e7%bb%84%e4%bb%b6%e9%97%b4%e8%b0%83%e7%94%a8%e5%92%8c%e9%a1%b5%e9%9d%a2%e8%b7%b3%e8%bd%ac%e6%97%b6%e9%83%bd%e8%bf%9b%e8%a1%8c%e5%9f%8b%e7%82%b9%e7%bb%9f%e8%ae%a1%ef%bc%9f%e6%af%8f%e4%b8%aa%e8%b7%b3%e8%bd%ac%e7%9a%84%e5%9c%b0%e6%96%b9%e9%83%bd%e6%89%8b%e5%86%99%e4%bb%a3%e7%a0%81%e5%9f%8b%e7%82%b9%ef%bc%9f%e5%88%a9%e7%94%a8Runtime%20AOP%20%ef%bc%9f%0a8.%e5%a6%82%e4%bd%95%e5%9c%a8%e6%af%8f%e4%b8%aa%e7%bb%84%e4%bb%b6%e9%97%b4%e8%b0%83%e7%94%a8%e7%9a%84%e8%bf%87%e7%a8%8b%e4%b8%ad%ef%bc%8c%e5%8a%a0%e5%85%a5%e8%b0%83%e7%94%a8%e7%9a%84%e9%80%bb%e8%be%91%e6%a3%80%e6%9f%a5%ef%bc%8c%e4%bb%a4%e7%89%8c%e6%9c%ba%e5%88%b6%ef%bc%8c%e9%85%8d%e5%90%88%e7%81%b0%e5%ba%a6%e8%bf%9b%e8%a1%8c%e9%a3%8e%e6%8e%a7%e9%80%bb%e8%be%91%ef%bc%9f%0a9.%e5%a6%82%e4%bd%95%e5%9c%a8App%e4%bb%bb%e4%bd%95%e7%95%8c%e9%9d%a2%e9%83%bd%e5%8f%af%e4%bb%a5%e8%b0%83%e7%94%a8%e5%90%8c%e4%b8%80%e4%b8%aa%e7%95%8c%e9%9d%a2%e6%88%96%e8%80%85%e5%90%8c%e4%b8%80%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9f%e5%8f%aa%e8%83%bd%e5%9c%a8AppDelegate%e9%87%8c%e9%9d%a2%e6%b3%a8%e5%86%8c%e5%8d%95%e4%be%8b%e6%9d%a5%e5%ae%9e%e7%8e%b0%ef%bc%9f%0a%e6%af%94%e5%a6%82App%e5%87%ba%e7%8e%b0%e9%97%ae%e9%a2%98%e4%ba%86%ef%bc%8c%e7%94%a8%e6%88%b7%e5%8f%af%e8%83%bd%e5%9c%a8%e4%bb%bb%e4%bd%95%e7%95%8c%e9%9d%a2%ef%bc%8c%e5%a6%82%e4%bd%95%e9%9a%8f%e6%97%b6%e9%9a%8f%e5%9c%b0%e7%9a%84%e8%ae%a9%e7%94%a8%e6%88%b7%e5%bc%ba%e5%88%b6%e7%99%bb%e5%87%ba%ef%bc%9f%e6%88%96%e8%80%85%e5%bc%ba%e5%88%b6%e9%83%bd%e8%b7%b3%e8%bd%ac%e5%88%b0%e5%90%8c%e4%b8%80%e4%b8%aa%e6%9c%ac%e5%9c%b0%e7%9a%84error%e7%95%8c%e9%9d%a2%ef%bc%9f%e6%88%96%e8%80%85%e8%b7%b3%e8%bd%ac%e5%88%b0%e7%9b%b8%e5%ba%94%e7%9a%84H5%ef%bc%8cReactNative%ef%bc%8cWeex%e7%95%8c%e9%9d%a2%ef%bc%9f%e5%a6%82%e4%bd%95%e8%ae%a9%e7%94%a8%e6%88%b7%e5%9c%a8%e4%bb%bb%e4%bd%95%e7%95%8c%e9%9d%a2%ef%bc%8c%e9%9a%8f%e6%97%b6%e9%9a%8f%e5%9c%b0%e7%9a%84%e5%bc%b9%e5%87%ba%e4%b8%80%e4%b8%aaView%20%ef%bc%9f%0a%e4%bb%a5%e4%b8%8a%e8%bf%99%e4%ba%9b%e9%97%ae%e9%a2%98%e5%85%b6%e5%ae%9e%e9%83%bd%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87%e5%9c%a8App%e7%ab%af%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e8%b7%af%e7%94%b1%e6%9d%a5%e8%a7%a3%e5%86%b3%e3%80%82%e9%82%a3%e4%b9%88%e6%88%91%e4%bb%ac%e6%80%8e%e4%b9%88%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e8%b7%af%e7%94%b1%e5%91%a2%ef%bc%9f%0a%e4%b8%89.%20App%e4%b9%8b%e9%97%b4%e8%b7%b3%e8%bd%ac%e5%ae%9e%e7%8e%b0%20%e5%9c%a8%e8%b0%88App%e5%86%85%e9%83%a8%e7%9a%84%e8%b7%af%e7%94%b1%e4%b9%8b%e5%89%8d%ef%bc%8c%e5%85%88%e6%9d%a5%e8%b0%88%e8%b0%88%e5%9c%a8iOS%e7%b3%bb%e7%bb%9f%e9%97%b4%ef%bc%8c%e4%b8%8d%e5%90%8cApp%e4%b9%8b%e9%97%b4%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e8%b7%b3%e8%bd%ac%e7%9a%84%e3%80%82%0a1.%20URL%20Scheme%e6%96%b9%e5%bc%8f%20iOS%e7%b3%bb%e7%bb%9f%e6%98%af%e9%bb%98%e8%ae%a4%e6%94%af%e6%8c%81URL%20Scheme%e7%9a%84%ef%bc%8c%e5%85%b7%e4%bd%93%e8%a7%81%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%e3%80%82"><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&t=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div><div id=toc><nav id=TableOfContents><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#目录>目录</a></li><li><a href=#一-引子>一. 引子</a></li><li><a href=#二-app路由能解决哪些问题>二. App路由能解决哪些问题</a></li><li><a href=#三-app之间跳转实现>三. App之间跳转实现</a><ul><li><a href=#1-url-scheme方式>1. URL Scheme方式</a></li><li><a href=#2-universal-links方式>2. Universal Links方式</a></li></ul></li><li><a href=#四-app内组件间路由设计>四. App内组件间路由设计</a><ul><li><a href=#1-关于页面跳转>1. 关于页面跳转</a></li><li><a href=#2-关于组件间调用>2. 关于组件间调用</a></li><li><a href=#3-如何设计一个路由>3. 如何设计一个路由</a></li><li><a href=#1jlrouteshttpsgithubcomjoeldevjlroutes-star-3189>（1）<strong><a href=https://github.com/joeldev/JLRoutes>JLRoutes</a></strong> Star 3189</a></li><li><a href=#2routable-ioshttpsgithubcomclayallsopproutable-ios-star-1415>（2）<strong><a href=https://github.com/clayallsopp/routable-ios>routable-ios</a></strong> Star 1415</a></li><li><a href=#3hhrouterhttpsgithubcomlightoryhhrouter--star-1277>（3）<strong><a href=https://github.com/lightory/HHRouter>HHRouter</a></strong> Star 1277</a></li><li><a href=#4mgjrouterhttpsgithubcommogujiemgjrouter-star-633>（4）<strong><a href=https://github.com/mogujie/MGJRouter>MGJRouter</a></strong> Star 633</a></li><li><a href=#5ctmediatorhttpsgithubcomcasatwyctmediator--star-803>（5）<strong><a href=https://github.com/casatwy/CTMediator>CTMediator</a></strong> Star 803</a></li><li><a href=#6一些并没有开源的方案>（6）一些并没有开源的方案</a></li></ul></li><li><a href=#五-各个方案优缺点>五. 各个方案优缺点</a><ul><li><a href=#1-urlroute注册方案的优缺点>1. URLRoute注册方案的优缺点</a></li><li><a href=#2-protocol-class注册方案的优缺点>2. Protocol-Class注册方案的优缺点</a></li><li><a href=#3-target-action方案的优缺点>3. Target-Action方案的优缺点</a></li><li><a href=#4-组件如何拆分>4. 组件如何拆分？</a></li></ul></li><li><a href=#六-最好的方案>六. 最好的方案</a></li></ul></li></ul></nav></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">iOS 组件化 —— 路由设计思路分析</h1><div class=meta><div class=postdate><time datetime="2017-02-25 03:39:00 +0000 UTC" itemprop=datePublished>Feb 25</time></div><div class=article-category><i class="fas fa-archive"></i><a class=category-link href=/categories/ios>iOS</a>
,
<a class=category-link href=/categories/router>Router</a>
,
<a class=category-link href=/categories/%E7%BB%84%E4%BB%B6%E5%8C%96>组件化</a></div><div class=article-tag><i class="fas fa-tag"></i><a class=tag-link href=/tags/ios rel=tag>iOS</a>
,
<a class=tag-link href=/tags/router rel=tag>Router</a>
,
<a class=tag-link href=/tags/%E7%BB%84%E4%BB%B6%E5%8C%96 rel=tag>组件化</a></div></div></header><div class=content itemprop=articleBody><h3 id=前言>前言</h3><p>随着用户的需求越来越多，对App的用户体验也变的要求越来越高。为了更好的应对各种需求，开发人员从软件工程的角度，将App架构由原来简单的MVC变成MVVM，VIPER等复杂架构。更换适合业务的架构，是为了后期能更好的维护项目。</p><p>但是用户依旧不满意，继续对开发人员提出了更多更高的要求，不仅需要高质量的用户体验，还要求快速迭代，最好一天出一个新功能，而且用户还要求不更新就能体验到新功能。为了满足用户需求，于是开发人员就用H5，ReactNative，Weex等技术对已有的项目进行改造。项目架构也变得更加的复杂，纵向的会进行分层，网络层，UI层，数据持久层。每一层横向的也会根据业务进行组件化。尽管这样做了以后会让开发更加有效率，更加好维护，但是如何解耦各层，解耦各个界面和各个组件，降低各个组件之间的耦合度，如何能让整个系统不管多么复杂的情况下都能保持“高内聚，低耦合”的特点？这一系列的问题都摆在开发人员面前，亟待解决。今天就来谈谈解决这个问题的一些思路。</p><h3 id=目录>目录</h3><ul><li>1.引子</li><li>2.App路由能解决哪些问题</li><li>3.App之间跳转实现</li><li>4.App内组件间路由设计</li><li>5.各个方案优缺点</li><li>6.最好的方案</li></ul><h3 id=一-引子>一. 引子</h3><p>大前端发展这么多年了，相信也一定会遇到相似的问题。近两年SPA发展极其迅猛，React 和 Vue一直处于风口浪尖，那我们就看看他们是如何处理好这一问题的。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_1.png alt></p><p>在SPA单页面应用，路由起到了很关键的作用。路由的作用主要是保证视图和 URL 的同步。在前端的眼里看来，视图是被看成是资源的一种表现。当用户在页面中进行操作时，应用会在若干个交互状态中切换，路由则可以记录下某些重要的状态，比如用户查看一个网站，用户是否登录、在访问网站的哪一个页面。而这些变化同样会被记录在浏览器的历史中，用户可以通过浏览器的前进、后退按钮切换状态。总的来说，用户可以通过手动输入或者与页面进行交互来改变 URL，然后通过同步或者异步的方式向服务端发送请求获取资源，成功后重新绘制 UI，原理如下图所示：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_2.png alt></p><p>react-router通过传入的location到最终渲染新的UI，流程如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_3.png alt></p><p>location的来源有2种，一种是浏览器的回退和前进，另外一种是直接点了一个链接。新的 location 对象后，路由内部的 matchRoutes 方法会匹配出 Route 组件树中与当前 location 对象匹配的一个子集，并且得到了 nextState，在this.setState(nextState) 时就可以实现重新渲染 Router 组件。</p><p>大前端的做法大概是这样的，我们可以把这些思想借鉴到iOS这边来。上图中的Back / Forward 在iOS这边很多情况下都可以被UINavgation所管理。所以iOS的Router主要处理绿色的那一块。</p><h3 id=二-app路由能解决哪些问题>二. App路由能解决哪些问题</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_4.png alt></p><p>既然前端能在SPA上解决URL和UI的同步问题，那这种思想可以在App上解决哪些问题呢？</p><p>思考如下的问题，平时我们开发中是如何优雅的解决的：</p><p>1.3D-Touch功能或者点击推送消息，要求外部跳转到App内部一个很深层次的一个界面。</p><p>比如微信的3D-Touch可以直接跳转到“我的二维码”。“我的二维码”界面在我的里面的第三级界面。或者再极端一点，产品需求给了更加变态的需求，要求跳转到App内部第十层的界面，怎么处理？</p><p>2.自家的一系列App之间如何相互跳转？</p><p>如果自己App有几个，相互之间还想相互跳转，怎么处理？</p><p>3.如何解除App组件之间和App页面之间的耦合性？</p><p>随着项目越来越复杂，各个组件，各个页面之间的跳转逻辑关联性越来越多，如何能优雅的解除各个组件和页面之间的耦合性？</p><p>4.如何能统一iOS和Android两端的页面跳转逻辑？甚至如何能统一三端的请求资源的方式？</p><p>项目里面某些模块会混合ReactNative，Weex，H5界面，这些界面还会调用Native的界面，以及Native的组件。那么，如何能统一Web端和Native端请求资源的方式？</p><p>5.如果使用了动态下发配置文件来配置App的跳转逻辑，那么如果做到iOS和Android两边只要共用一套配置文件？</p><p>6.如果App出现bug了，如何不用JSPatch，就能做到简单的热修复功能？</p><p>比如App上线突然遇到了紧急bug，能否把页面动态降级成H5，ReactNative，Weex？或者是直接换成一个本地的错误界面？</p><p>7.如何在每个组件间调用和页面跳转时都进行埋点统计？每个跳转的地方都手写代码埋点？利用Runtime AOP ？</p><p>8.如何在每个组件间调用的过程中，加入调用的逻辑检查，令牌机制，配合灰度进行风控逻辑？</p><p>9.如何在App任何界面都可以调用同一个界面或者同一个组件？只能在AppDelegate里面注册单例来实现？</p><p>比如App出现问题了，用户可能在任何界面，如何随时随地的让用户强制登出？或者强制都跳转到同一个本地的error界面？或者跳转到相应的H5，ReactNative，Weex界面？如何让用户在任何界面，随时随地的弹出一个View ？</p><p>以上这些问题其实都可以通过在App端设计一个路由来解决。那么我们怎么设计一个路由呢？</p><h3 id=三-app之间跳转实现>三. App之间跳转实现</h3><p>在谈App内部的路由之前，先来谈谈在iOS系统间，不同App之间是怎么实现跳转的。</p><h4 id=1-url-scheme方式>1. URL Scheme方式</h4><p>iOS系统是默认支持URL Scheme的，具体见<a href=https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899>官方文档</a>。</p><p>比如说，在iPhone的Safari浏览器上面输入如下的命令，会自动打开一些App：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#75715e>// 打开邮箱
</span><span style=color:#75715e></span>mailto:<span style=color:#75715e>//
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 给110拨打电话
</span><span style=color:#75715e></span>tel:<span style=color:#75715e>//110
</span><span style=color:#75715e></span>
</code></pre></div><p>在iOS 9 之前只要在App的info.plist里面添加URL types - URL Schemes，如下图：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_5.jpg alt></p><p>这里就添加了一个com.ios.Qhomer的Scheme。这样就可以在iPhone的Safari浏览器上面输入：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
com.ios.Qhomer:<span style=color:#75715e>//
</span><span style=color:#75715e></span>
</code></pre></div><p>就可以直接打开这个App了。</p><p>关于其他一些常见的App，可以从iTunes里面下载到它的ipa文件，解压，显示包内容里面可以找到info.plist文件，打开它，在里面就可以相应的URL Scheme。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#75715e>// 手机QQ
</span><span style=color:#75715e></span>mqq:<span style=color:#75715e>//
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 微信
</span><span style=color:#75715e></span>weixin:<span style=color:#75715e>//
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 新浪微博
</span><span style=color:#75715e></span>sinaweibo:<span style=color:#75715e>//
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 饿了么
</span><span style=color:#75715e></span>eleme:<span style=color:#75715e>//
</span><span style=color:#75715e></span>
</code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_6.png alt></p><p>当然了，某些App对于调用URL Scheme比较敏感，它们不希望其他的App随意的就调用自己。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>application:</span>(UIApplication <span style=color:#f92672>*</span>)application
            <span style=color:#a6e22e>openURL:</span>(NSURL <span style=color:#f92672>*</span>)url
  <span style=color:#a6e22e>sourceApplication:</span>(NSString <span style=color:#f92672>*</span>)sourceApplication
         <span style=color:#a6e22e>annotation:</span>(<span style=color:#66d9ef>id</span>)annotation
{
    NSLog(<span style=color:#e6db74>@&#34;sourceApplication: %@&#34;</span>, sourceApplication);
    NSLog(<span style=color:#e6db74>@&#34;URL scheme:%@&#34;</span>, [url scheme]);
    NSLog(<span style=color:#e6db74>@&#34;URL query: %@&#34;</span>, [url query]);
    
    <span style=color:#66d9ef>if</span> ([sourceApplication isEqualToString:<span style=color:#e6db74>@&#34;com.tencent.weixin&#34;</span>]){
        <span style=color:#75715e>// 允许打开
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> YES;
    }<span style=color:#66d9ef>else</span>{
        <span style=color:#66d9ef>return</span> NO;
    }
}

</code></pre></div><p>如果待调用的App已经运行了，那么它的生命周期如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_7.png alt></p><p>如果待调用的App在后台，那么它的生命周期如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_8.png alt></p><p>明白了上面的生命周期之后，我们就可以通过调用<a href=https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623073-application>application:openURL:sourceApplication:annotation:</a>这个方法，来阻止一些App的随意调用。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_9.png alt></p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_10.png alt></p><p>如上图，饿了么App允许通过URL Scheme调用，那么我们可以在Safari里面调用到饿了么App。手机QQ不允许调用，我们在Safari里面也就没法跳转过去。</p><p>关于App间的跳转问题，感兴趣的可以查看官方文档<a href=https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW2>Inter-App Communication</a>。</p><p>App也是可以直接跳转到系统设置的。比如有些需求要求检测用户有没有开启某些系统权限，如果没有开启就弹框提示，点击弹框的按钮直接跳转到系统设置里面对应的设置界面。</p><p><a href=https://www.zhihu.com/question/50635906/answer/125195317>iOS 10 支持通过 URL Scheme 跳转到系统设置</a><br><a href=http://www.jianshu.com/p/bb3f42fdbc31>iOS10跳转系统设置的正确姿势</a><br><a href=http://www.jianshu.com/p/32ca4bcda3d1>关于 iOS 系统功能的 URL 汇总列表</a></p><h4 id=2-universal-links方式>2. Universal Links方式</h4><p>虽然在微信内部开网页会禁止所有的Scheme，但是iOS 9.0新增加了一项功能是Universal Links，使用这个功能可以使我们的App通过HTTP链接来启动App。
1.如果安装过App，不管在微信里面http链接还是在Safari浏览器，还是其他第三方浏览器，都可以打开App。
2.如果没有安装过App，就会打开网页。</p><p>具体设置需要3步：</p><p>1.App需要开启Associated Domains服务，并设置Domains，注意必须要applinks：开头。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_11.png alt></p><p>2.域名必须要支持HTTPS。</p><p>3.上传内容是Json格式的文件，文件名为apple-app-site-association到自己域名的根目录下，或者.well-known目录下。iOS自动会去读取这个文件。具体的文件内容请查看<a href=https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html>官方文档</a>。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_12.png alt></p><p>如果App支持了Universal Links方式，那么可以在其他App里面直接跳转到我们自己的App里面。如下图，点击链接，由于该链接会Matcher到我们设置的链接，所以菜单里面会显示用我们的App打开。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_13.PNG alt></p><p>在浏览器里面也是一样的效果，如果是支持了Universal Links方式，访问相应的URL，会有不同的效果。如下图：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_14.png alt></p><p>以上就是iOS系统中App间跳转的二种方式。</p><p>从iOS 系统里面支持的URL Scheme方式，我们可以看出，对于一个资源的访问，苹果也是用URI的方式来访问的。</p><blockquote><p><strong>统一资源标识符</strong>（英语：Uniform Resource Identifier，或<strong>URI</strong>)是一个用于<a href=https://zh.wikipedia.org/wiki/%E6%A0%87%E8%AF%86>标识</a>某一<a href=https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91>互联网</a><a href=https://zh.wikipedia.org/wiki/%E8%B5%84%E6%BA%90>资源</a>名称的<a href=https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2>字符串</a>。 该种标识允许用户对网络中（一般指<a href=https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91>万维网</a>）的资源通过特定的<a href=https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE>协议</a>进行交互操作。URI的最常见的形式是<a href=https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6>统一资源定位符</a>（URL）。</p></blockquote><p>举个例子：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_15.png alt></p><p>这是一段URI，每一段都代表了对应的含义。对方接收到了这样一串字符串，按照规则解析出来，就能获取到所有的有用信息。</p><p>这个能给我们设计App组件间的路由带来一些思路么？如果我们想要定义一个三端（iOS，Android，H5）的统一访问资源的方式，能用URI的这种方式实现么？</p><h3 id=四-app内组件间路由设计>四. App内组件间路由设计</h3><p>上一章节中我们介绍了iOS系统中，系统是如何帮我们处理App间跳转逻辑的。这一章节我们着重讨论一下，App内部，各个组件之间的路由应该怎么设计。关于App内部的路由设计，主要需要解决2个问题：</p><p>1.各个页面和组件之间的跳转问题。
2.各个组件之间相互调用。</p><p>先来分析一下这两个问题。</p><h4 id=1-关于页面跳转>1. 关于页面跳转</h4><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_16.png alt></p><p>在iOS开发的过程中，经常会遇到以下的场景，点击按钮跳转Push到另外一个界面，或者点击一个cell Present一个新的ViewController。在MVC模式中，一般都是新建一个VC，然后Push / Present到下一个VC。但是在MVVM中，会有一些不合适的情况。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_17.gif alt></p><p>众所周知，MVVM把MVC拆成了上图演示的样子，原来View对应的与数据相关的代码都移到ViewModel中，相应的C也变瘦了，演变成了M-VM-C-V的结构。这里的C里面的代码可以只剩下页面跳转相关的逻辑。如果用代码表示就是下面这样子：</p><p>假设一个按钮的执行逻辑都封装成了command。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    @weakify(self);
    [[[_viewModel.someCommand executionSignals] flatten] subscribeNext:<span style=color:#f92672>^</span>(<span style=color:#66d9ef>id</span> x) {
        @strongify(self);
        <span style=color:#75715e>// 跳转逻辑
</span><span style=color:#75715e></span>        [self.navigationController pushViewController:targetViewController animated:YES];
  }];


</code></pre></div><p>上述的代码本身没啥问题，但是可能会弱化MVVM框架的一个重要作用。</p><p>MVVM框架的目的除去解耦以外，还有2个很重要的目的：</p><ol><li>代码高复用率</li><li>方便进行单元测试</li></ol><p>如果需要测试一个业务是否正确，我们只要对ViewModel进行单元测试即可。前提是假定我们使用ReactiveCocoa进行UI绑定的过程是准确无误的。目前绑定是正确的。所以我们只需要单元测试到ViewModel即可完成业务逻辑的测试。</p><p>页面跳转也属于业务逻辑，所以应该放在ViewModel中一起单元测试，保证业务逻辑测试的覆盖率。</p><p>把页面跳转放到ViewModel中，有2种做法，第一种就是用路由来实现，第二种由于和路由没有关系，所以这里就不多阐述，有兴趣的可以看<a href=https://github.com/LPD-iOS/lpd-mvvm-kit>lpd-mvvm-kit</a>这个库关于页面跳转的具体实现。</p><p>页面跳转相互的耦合性也就体现出来了：</p><p>1.由于pushViewController或者presentViewController，后面都需要带一个待操作的ViewController，那么就必须要引入该类，import头文件也就引入了耦合性。
2.由于跳转这里写死了跳转操作，如果线上一旦出现了bug，这里是不受我们控制的。
3.推送消息或者是3D-Touch需求，要求直接跳转到内部第10级界面，那么就需要写一个入口跳转到指定界面。</p><h4 id=2-关于组件间调用>2. 关于组件间调用</h4><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_18.png alt></p><p>关于组件间的调用，也需要解耦。随着业务越来越复杂，我们封装的组件越来越多，要是封装的粒度拿捏不准，就会出现大量组件之间耦合度高的问题。组件的粒度可以随着业务的调整，不断的调整组件职责的划分。但是组件之间的调用依旧不可避免，相互调用对方组件暴露的接口。如何减少各个组件之间的耦合度，是一个设计优秀的路由的职责所在。</p><h4 id=3-如何设计一个路由>3. 如何设计一个路由</h4><p>如何设计一个能完美解决上述2个问题的路由，让我们先来看看GitHub上优秀开源库的设计思路。以下是我从Github上面找的一些路由方案，按照Star从高到低排列。依次来分析一下它们各自的设计思路。</p><h4 id=1jlrouteshttpsgithubcomjoeldevjlroutes-star-3189>（1）<strong><a href=https://github.com/joeldev/JLRoutes>JLRoutes</a></strong> Star 3189</h4><p>JLRoutes在整个Github上面Star最多，那就来从它来分析分析它的具体设计思路。</p><p>首先JLRoutes是受URL Scheme思路的影响。它把所有对资源的请求看成是一个URI。</p><p>首先来熟悉一下NSURLComponent的各个字段：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_19.png alt></p><blockquote><p>Note
The URLs employed by the NSURL
 class are described in <a href=https://tools.ietf.org/html/rfc1808>RFC 1808</a>, <a href=https://tools.ietf.org/html/rfc1738>RFC 1738</a>, and <a href=https://tools.ietf.org/html/rfc2732>RFC 2732</a>.</p></blockquote><p>JLRoutes会传入每个字符串，都按照上面的样子进行切分处理，分别根据RFC的标准定义，取到各个NSURLComponent。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_20.png alt></p><p>JLRoutes全局会保存一个Map，这个Map会以scheme为Key，JLRoutes为Value。所以在routeControllerMap里面每个scheme都是唯一的。</p><p>至于为何有这么多条路由，笔者认为，如果路由按照业务线进行划分的话，每个业务线可能会有不相同的逻辑，即使每个业务里面的组件名字可能相同，但是由于业务线不同，会有不同的路由规则。</p><p>举个例子：如果滴滴按照每个城市的打车业务进行组件化拆分，那么每个城市就对应着这里的每个scheme。每个城市的打车业务都有叫车，付款……等业务，但是由于每个城市的地方法规不相同，所以这些组件即使名字相同，但是里面的功能也许千差万别。所以这里划分出了多个route，也可以理解为不同的命名空间。</p><p>在每个JLRoutes里面都保存了一个数组，这个数组里面保存了每个路由规则JLRRouteDefinition里面会保存外部传进来的block闭包，pattern，和拆分之后的pattern。</p><p>在每个JLRoutes的数组里面，会按照路由的优先级进行排列，优先级高的排列在前面。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>_registerRoute:</span>(NSString <span style=color:#f92672>*</span>)routePattern <span style=color:#a6e22e>priority:</span>(NSUInteger)priority <span style=color:#a6e22e>handler:</span>(<span style=color:#66d9ef>BOOL</span> (<span style=color:#f92672>^</span>)(NSDictionary <span style=color:#f92672>*</span>parameters))handlerBlock
{
    JLRRouteDefinition <span style=color:#f92672>*</span>route <span style=color:#f92672>=</span> [[JLRRouteDefinition alloc] initWithScheme:self.scheme pattern:routePattern priority:priority handlerBlock:handlerBlock];
    
    <span style=color:#66d9ef>if</span> (priority <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> self.routes.count <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
        [self.routes addObject:route];
    } <span style=color:#66d9ef>else</span> {
        NSUInteger index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>BOOL</span> addedRoute <span style=color:#f92672>=</span> NO;
        
        <span style=color:#75715e>// 找到当前已经存在的一条优先级比当前待插入的路由低的路由
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (JLRRouteDefinition <span style=color:#f92672>*</span>existingRoute <span style=color:#66d9ef>in</span> [self.routes <span style=color:#66d9ef>copy</span>]) {
            <span style=color:#66d9ef>if</span> (existingRoute.priority <span style=color:#f92672>&lt;</span> priority) {
                <span style=color:#75715e>// 如果找到，就插入数组
</span><span style=color:#75715e></span>                [self.routes insertObject:route atIndex:index];
                addedRoute <span style=color:#f92672>=</span> YES;
                <span style=color:#66d9ef>break</span>;
            }
            index<span style=color:#f92672>++</span>;
        }
        
        <span style=color:#75715e>// 如果没有找到任何一条路由比当前待插入的路由低的路由，或者最后一条路由优先级和当前路由一样，那么就只能插入到最后。
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>addedRoute) {
            [self.routes addObject:route];
        }
    }
}


</code></pre></div><p>由于这个数组里面的路由是一个单调队列，所以查找优先级的时候只用从高往低遍历即可。</p><p>具体查找路由的过程如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_21.png alt></p><p>首先根据外部传进来的URL初始化一个JLRRouteRequest，然后用这个JLRRouteRequest在当前的路由数组里面依次request，每个规则都会生成一个response，但是只有符合条件的response才会match，最后取出匹配的JLRRouteResponse拿出其字典parameters里面对应的参数就可以了。查找和匹配过程中重要的代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>_routeURL:</span>(NSURL <span style=color:#f92672>*</span>)URL <span style=color:#a6e22e>withParameters:</span>(NSDictionary <span style=color:#f92672>*</span>)parameters <span style=color:#a6e22e>executeRouteBlock:</span>(<span style=color:#66d9ef>BOOL</span>)executeRouteBlock
{
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>URL) {
        <span style=color:#66d9ef>return</span> NO;
    }
    
    [self _verboseLog:<span style=color:#e6db74>@&#34;Trying to route URL %@&#34;</span>, URL];
    
    <span style=color:#66d9ef>BOOL</span> didRoute <span style=color:#f92672>=</span> NO;
    JLRRouteRequest <span style=color:#f92672>*</span>request <span style=color:#f92672>=</span> [[JLRRouteRequest alloc] initWithURL:URL];
    
    <span style=color:#66d9ef>for</span> (JLRRouteDefinition <span style=color:#f92672>*</span>route <span style=color:#66d9ef>in</span> [self.routes <span style=color:#66d9ef>copy</span>]) {
        <span style=color:#75715e>// 检查每一个route，生成对应的response
</span><span style=color:#75715e></span>        JLRRouteResponse <span style=color:#f92672>*</span>response <span style=color:#f92672>=</span> [route routeResponseForRequest:request decodePlusSymbols:shouldDecodePlusSymbols];
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>response.isMatch) {
            <span style=color:#66d9ef>continue</span>;
        }
        
        [self _verboseLog:<span style=color:#e6db74>@&#34;Successfully matched %@&#34;</span>, route];
        
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>executeRouteBlock) {
            <span style=color:#75715e>// 如果我们被要求不允许执行，但是又找了匹配的路由response。
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> YES;
        }
        
        <span style=color:#75715e>// 装配最后的参数
</span><span style=color:#75715e></span>        NSMutableDictionary <span style=color:#f92672>*</span>finalParameters <span style=color:#f92672>=</span> [NSMutableDictionary dictionary];
        [finalParameters addEntriesFromDictionary:response.parameters];
        [finalParameters addEntriesFromDictionary:parameters];
        [self _verboseLog:<span style=color:#e6db74>@&#34;Final parameters are %@&#34;</span>, finalParameters];
        
        didRoute <span style=color:#f92672>=</span> [route callHandlerBlockWithParameters:finalParameters];
        
        <span style=color:#66d9ef>if</span> (didRoute) {
            <span style=color:#75715e>// 调用Handler成功
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>break</span>;
        }
    }
    
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>didRoute) {
        [self _verboseLog:<span style=color:#e6db74>@&#34;Could not find a matching route&#34;</span>];
    }
    
    <span style=color:#75715e>// 如果在当前路由规则里面没有找到匹配的路由，当前路由不是global 的，并且允许降级到global里面去查找，那么我们继续在global的路由规则里面去查找。
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>didRoute <span style=color:#f92672>&amp;&amp;</span> self.shouldFallbackToGlobalRoutes <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>[self _isGlobalRoutesController]) {
        [self _verboseLog:<span style=color:#e6db74>@&#34;Falling back to global routes...&#34;</span>];
        didRoute <span style=color:#f92672>=</span> [[JLRoutes globalRoutes] _routeURL:URL withParameters:parameters executeRouteBlock:executeRouteBlock];
    }
    
    <span style=color:#75715e>// 最后，依旧没有找到任何能匹配的，如果有unmatched URL handler，调用这个闭包进行最后的处理。
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>if</span>, after everything, we did not route anything and we have an unmatched URL handler, then call it
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>didRoute <span style=color:#f92672>&amp;&amp;</span> executeRouteBlock <span style=color:#f92672>&amp;&amp;</span> self.unmatchedURLHandler) {
        [self _verboseLog:<span style=color:#e6db74>@&#34;Falling back to the unmatched URL handler&#34;</span>];
        self.unmatchedURLHandler(self, URL, parameters);
    }
    
    <span style=color:#66d9ef>return</span> didRoute;
}


</code></pre></div><p>举个例子：</p><p>我们先注册一个Router，规则如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

[[JLRoutes globalRoutes] addRoute:<span style=color:#e6db74>@&#34;/:object/:action&#34;</span> handler:<span style=color:#f92672>^</span><span style=color:#66d9ef>BOOL</span>(NSDictionary <span style=color:#f92672>*</span>parameters) {
  NSString <span style=color:#f92672>*</span>object <span style=color:#f92672>=</span> parameters[<span style=color:#e6db74>@&#34;object&#34;</span>];
  NSString <span style=color:#f92672>*</span>action <span style=color:#f92672>=</span> parameters[<span style=color:#e6db74>@&#34;action&#34;</span>];
  <span style=color:#75715e>// stuff
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> YES;
}];


</code></pre></div><p>我们传入一个URL，让Router进行处理。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
NSURL <span style=color:#f92672>*</span>editPost <span style=color:#f92672>=</span> [NSURL URLWithString:<span style=color:#e6db74>@&#34;ele://post/halfrost?debug=true&amp;foo=bar&#34;</span>];
[[UIApplication sharedApplication] openURL:editPost];

</code></pre></div><p>匹配成功之后，我们会得到下面这样一个字典：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
{
  <span style=color:#e6db74>&#34;object&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;post&#34;</span>,
  <span style=color:#e6db74>&#34;action&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;halfrost&#34;</span>,
  <span style=color:#e6db74>&#34;debug&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;true&#34;</span>,
  <span style=color:#e6db74>&#34;foo&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bar&#34;</span>,
  <span style=color:#e6db74>&#34;JLRouteURL&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;ele://post/halfrost?debug=true&amp;foo=bar&#34;</span>,
  <span style=color:#e6db74>&#34;JLRoutePattern&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;/:object/:action&#34;</span>,
  <span style=color:#e6db74>&#34;JLRouteScheme&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;JLRoutesGlobalRoutesScheme&#34;</span>
}

</code></pre></div><p>把上述过程图解出来，见下图：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_22.png alt></p><p>JLRoutes还可以支持Optional的路由规则，假如定义一条路由规则：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#f92672>/</span>the(<span style=color:#f92672>/</span>foo<span style=color:#f92672>/:</span>a)(<span style=color:#f92672>/</span>bar<span style=color:#f92672>/:</span>b)

</code></pre></div><p>JLRoutes 会帮我们默认注册如下4条路由规则：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>
<span style=color:#f92672>/</span>the<span style=color:#f92672>/</span>foo<span style=color:#f92672>/:</span>a<span style=color:#f92672>/</span>bar<span style=color:#f92672>/:</span>b
<span style=color:#f92672>/</span>the<span style=color:#f92672>/</span>foo<span style=color:#f92672>/:</span>a
<span style=color:#f92672>/</span>the<span style=color:#f92672>/</span>bar<span style=color:#f92672>/:</span>b
<span style=color:#f92672>/</span>the

</code></pre></div><h4 id=2routable-ioshttpsgithubcomclayallsopproutable-ios-star-1415>（2）<strong><a href=https://github.com/clayallsopp/routable-ios>routable-ios</a></strong> Star 1415</h4><p>Routable路由是用在in-app native端的 URL router, 它可以用在iOS上也可以用在<a href=https://github.com/usepropeller/routable-android>Android</a>上。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_23.png alt></p><p>UPRouter里面保存了2个字典。routes字典里面存储的Key是路由规则，Value存储的是UPRouterOptions。cachedRoutes里面存储的Key是最终的URL，带传参的，Value存储的是RouterParams。RouterParams里面会包含在routes匹配的到的UPRouterOptions，还有额外的打开参数openParams和一些额外参数extraParams。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>



- (RouterParams <span style=color:#f92672>*</span>)<span style=color:#a6e22e>routerParamsForUrl:</span>(NSString <span style=color:#f92672>*</span>)url <span style=color:#a6e22e>extraParams:</span> (NSDictionary <span style=color:#f92672>*</span>)extraParams {
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>url) {
        <span style=color:#75715e>//if we wait, caching this as key would throw an exception
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (_ignoresExceptions) {
            <span style=color:#66d9ef>return</span> nil;
        }
        <span style=color:#66d9ef>@throw</span> [NSException exceptionWithName:<span style=color:#e6db74>@&#34;RouteNotFoundException&#34;</span>
                                       reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url]
                                     userInfo:nil];
    }
    
    <span style=color:#66d9ef>if</span> ([self.cachedRoutes objectForKey:url] <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>extraParams) {
        <span style=color:#66d9ef>return</span> [self.cachedRoutes objectForKey:url];
    }
    
   <span style=color:#75715e>// 比对url通过/分割之后的参数个数和pathComponents的个数是否一样
</span><span style=color:#75715e></span>    NSArray <span style=color:#f92672>*</span>givenParts <span style=color:#f92672>=</span> url.pathComponents;
    NSArray <span style=color:#f92672>*</span>legacyParts <span style=color:#f92672>=</span> [url componentsSeparatedByString:<span style=color:#e6db74>@&#34;/&#34;</span>];
    <span style=color:#66d9ef>if</span> ([legacyParts count] <span style=color:#f92672>!=</span> [givenParts count]) {
        NSLog(<span style=color:#e6db74>@&#34;Routable Warning - your URL %@ has empty path components - this will throw an error in an upcoming release&#34;</span>, url);
        givenParts <span style=color:#f92672>=</span> legacyParts;
    }
    
    <span style=color:#66d9ef>__block</span> RouterParams <span style=color:#f92672>*</span>openParams <span style=color:#f92672>=</span> nil;
    [self.routes enumerateKeysAndObjectsUsingBlock:
     <span style=color:#f92672>^</span>(NSString <span style=color:#f92672>*</span>routerUrl, UPRouterOptions <span style=color:#f92672>*</span>routerOptions, <span style=color:#66d9ef>BOOL</span> <span style=color:#f92672>*</span>stop) {
         
         NSArray <span style=color:#f92672>*</span>routerParts <span style=color:#f92672>=</span> [routerUrl pathComponents];
         <span style=color:#66d9ef>if</span> ([routerParts count] <span style=color:#f92672>==</span> [givenParts count]) {
             
             NSDictionary <span style=color:#f92672>*</span>givenParams <span style=color:#f92672>=</span> [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts];
             <span style=color:#66d9ef>if</span> (givenParams) {
                 openParams <span style=color:#f92672>=</span> [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams];
                 <span style=color:#f92672>*</span>stop <span style=color:#f92672>=</span> YES;
             }
         }
     }];
    
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>openParams) {
        <span style=color:#66d9ef>if</span> (_ignoresExceptions) {
            <span style=color:#66d9ef>return</span> nil;
        }
        <span style=color:#66d9ef>@throw</span> [NSException exceptionWithName:<span style=color:#e6db74>@&#34;RouteNotFoundException&#34;</span>
                                       reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url]
                                     userInfo:nil];
    }
    [self.cachedRoutes setObject:openParams forKey:url];
    <span style=color:#66d9ef>return</span> openParams;
}


</code></pre></div><p>这一段代码里面重点在干一件事情，遍历routes字典，然后找到参数匹配的字符串，封装成RouterParams返回。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (NSDictionary <span style=color:#f92672>*</span>)<span style=color:#a6e22e>paramsForUrlComponents:</span>(NSArray <span style=color:#f92672>*</span>)givenUrlComponents <span style=color:#a6e22e>routerUrlComponents:</span>(NSArray <span style=color:#f92672>*</span>)routerUrlComponents {
    
    <span style=color:#66d9ef>__block</span> NSMutableDictionary <span style=color:#f92672>*</span>params <span style=color:#f92672>=</span> [NSMutableDictionary dictionary];
    [routerUrlComponents enumerateObjectsUsingBlock:
     <span style=color:#f92672>^</span>(NSString <span style=color:#f92672>*</span>routerComponent, NSUInteger idx, <span style=color:#66d9ef>BOOL</span> <span style=color:#f92672>*</span>stop) {
         
         NSString <span style=color:#f92672>*</span>givenComponent <span style=color:#f92672>=</span> givenUrlComponents[idx];
         <span style=color:#66d9ef>if</span> ([routerComponent hasPrefix:<span style=color:#e6db74>@&#34;:&#34;</span>]) {
             NSString <span style=color:#f92672>*</span>key <span style=color:#f92672>=</span> [routerComponent substringFromIndex:<span style=color:#ae81ff>1</span>];
             [params setObject:givenComponent forKey:key];
         }
         <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>[routerComponent isEqualToString:givenComponent]) {
             params <span style=color:#f92672>=</span> nil;
             <span style=color:#f92672>*</span>stop <span style=color:#f92672>=</span> YES;
         }
     }];
    <span style=color:#66d9ef>return</span> params;
}


</code></pre></div><p>上面这段函数，第一个参数是外部传进来URL带有各个入参的分割数组。第二个参数是路由规则分割开的数组。routerComponent由于规定：号后面才是参数，所以routerComponent的第1个位置就是对应的参数名。params字典里面以参数名为Key，参数为Value。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

 NSDictionary <span style=color:#f92672>*</span>givenParams <span style=color:#f92672>=</span> [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts];
<span style=color:#66d9ef>if</span> (givenParams) {
       openParams <span style=color:#f92672>=</span> [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams];
       <span style=color:#f92672>*</span>stop <span style=color:#f92672>=</span> YES;
}


</code></pre></div><p>最后通过RouterParams的初始化方法，把路由规则对应的UPRouterOptions，上一步封装好的参数字典givenParams，还有
routerParamsForUrl: extraParams: 方法的第二个入参，这3个参数作为初始化参数，生成了一个RouterParams。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
[self.cachedRoutes setObject:openParams forKey:url];

</code></pre></div><p>最后一步self.cachedRoutes的字典里面Key为带参数的URL，Value是RouterParams。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_24.png alt></p><p>最后将匹配封装出来的RouterParams转换成对应的Controller。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (UIViewController <span style=color:#f92672>*</span>)<span style=color:#a6e22e>controllerForRouterParams:</span>(RouterParams <span style=color:#f92672>*</span>)params {
    <span style=color:#66d9ef>SEL</span> CONTROLLER_CLASS_SELECTOR <span style=color:#f92672>=</span> sel_registerName(<span style=color:#e6db74>&#34;allocWithRouterParams:&#34;</span>);
    <span style=color:#66d9ef>SEL</span> CONTROLLER_SELECTOR <span style=color:#f92672>=</span> sel_registerName(<span style=color:#e6db74>&#34;initWithRouterParams:&#34;</span>);
    UIViewController <span style=color:#f92672>*</span>controller <span style=color:#f92672>=</span> nil;
    <span style=color:#66d9ef>Class</span> controllerClass <span style=color:#f92672>=</span> params.routerOptions.openClass;
<span style=color:#75715e>#pragma clang diagnostic push
</span><span style=color:#75715e>#pragma clang diagnostic ignored &#34;-Warc-performSelector-leaks&#34;
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ([controllerClass respondsToSelector:CONTROLLER_CLASS_SELECTOR]) {
        controller <span style=color:#f92672>=</span> [controllerClass performSelector:CONTROLLER_CLASS_SELECTOR withObject:[params controllerParams]];
    }
    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ([params.routerOptions.openClass instancesRespondToSelector:CONTROLLER_SELECTOR]) {
        controller <span style=color:#f92672>=</span> [[params.routerOptions.openClass alloc] performSelector:CONTROLLER_SELECTOR withObject:[params controllerParams]];
    }
<span style=color:#75715e>#pragma clang diagnostic pop
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>controller) {
        <span style=color:#66d9ef>if</span> (_ignoresExceptions) {
            <span style=color:#66d9ef>return</span> controller;
        }
        <span style=color:#66d9ef>@throw</span> [NSException exceptionWithName:<span style=color:#e6db74>@&#34;RoutableInitializerNotFound&#34;</span>
                                       reason:[NSString stringWithFormat:INVALID_CONTROLLER_FORMAT, NSStringFromClass(controllerClass), NSStringFromSelector(CONTROLLER_CLASS_SELECTOR),  NSStringFromSelector(CONTROLLER_SELECTOR)]
                                     userInfo:nil];
    }
    
    controller.modalTransitionStyle <span style=color:#f92672>=</span> params.routerOptions.transitionStyle;
    controller.modalPresentationStyle <span style=color:#f92672>=</span> params.routerOptions.presentationStyle;
    <span style=color:#66d9ef>return</span> controller;
}



</code></pre></div><p>如果Controller是一个类，那么就调用allocWithRouterParams:方法去初始化。如果Controller已经是一个实例了，那么就调用initWithRouterParams:方法去初始化。</p><p>将Routable的大致流程图解如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_25.png alt></p><h4 id=3hhrouterhttpsgithubcomlightoryhhrouter--star-1277>（3）<strong><a href=https://github.com/lightory/HHRouter>HHRouter</a></strong> Star 1277</h4><p>这是布丁动画的一个Router，灵感来自于 <a href=https://github.com/aaronbrethorst/ABRouter>ABRouter</a> 和 <a href=https://github.com/usepropeller/routable-ios>Routable iOS</a>。</p><p>先来看看HHRouter的Api。它提供的方法非常清晰。</p><p>ViewController提供了2个方法。map是用来设置路由规则，matchController是用来匹配路由规则的，匹配争取之后返回对应的UIViewController。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>map:</span>(NSString <span style=color:#f92672>*</span>)route <span style=color:#a6e22e>toControllerClass:</span>(<span style=color:#66d9ef>Class</span>)controllerClass;
- (UIViewController <span style=color:#f92672>*</span>)<span style=color:#a6e22e>matchController:</span>(NSString <span style=color:#f92672>*</span>)route;



</code></pre></div><p>block闭包提供了三个方法，map也是设置路由规则，matchBlock：是用来匹配路由，找到指定的block，但是不会调用该block。callBlock:是找到指定的block，找到以后就立即调用。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>map:</span>(NSString <span style=color:#f92672>*</span>)route <span style=color:#a6e22e>toBlock:</span>(HHRouterBlock)block;

- (HHRouterBlock)<span style=color:#a6e22e>matchBlock:</span>(NSString <span style=color:#f92672>*</span>)route;
- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>callBlock:</span>(NSString <span style=color:#f92672>*</span>)route;

</code></pre></div><p>matchBlock:和callBlock:的区别就在于前者不会自动调用闭包。所以matchBlock:方法找到对应的block之后，如果想调用，需要手动调用一次。</p><p>除去上面这些方法，HHRouter还为我们提供了一个特殊的方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (HHRouteType)<span style=color:#a6e22e>canRoute:</span>(NSString <span style=color:#f92672>*</span>)route;



</code></pre></div><p>这个方法就是用来找到执行路由规则对应的RouteType，RouteType总共就3种:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>NS_ENUM</span> (NSInteger, HHRouteType) {
    HHRouteTypeNone <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
    HHRouteTypeViewController <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
    HHRouteTypeBlock <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
};

</code></pre></div><p>再来看看HHRouter是如何管理路由规则的。整个HHRouter就是由一个NSMutableDictionary *routes控制的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>HHRouter</span> ()
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>strong</span>, <span style=color:#66d9ef>nonatomic</span>) NSMutableDictionary <span style=color:#f92672>*</span>routes;
<span style=color:#66d9ef>@end</span>


</code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_26.png alt></p><p>别看只有这一个看似“简单”的字典数据结构，但是HHRouter路由设计的还是很精妙的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>map:</span>(NSString <span style=color:#f92672>*</span>)route <span style=color:#a6e22e>toBlock:</span>(HHRouterBlock)block
{
    NSMutableDictionary <span style=color:#f92672>*</span>subRoutes <span style=color:#f92672>=</span> [self subRoutesToRoute:route];
    subRoutes[<span style=color:#e6db74>@&#34;_&#34;</span>] <span style=color:#f92672>=</span> [block <span style=color:#66d9ef>copy</span>];
}

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>map:</span>(NSString <span style=color:#f92672>*</span>)route <span style=color:#a6e22e>toControllerClass:</span>(<span style=color:#66d9ef>Class</span>)controllerClass
{
    NSMutableDictionary <span style=color:#f92672>*</span>subRoutes <span style=color:#f92672>=</span> [self subRoutesToRoute:route];
    subRoutes[<span style=color:#e6db74>@&#34;_&#34;</span>] <span style=color:#f92672>=</span> controllerClass;
}


</code></pre></div><p>上面两个方法分别是block闭包和ViewController设置路由规则调用的方法实体。不管是ViewController还是block闭包，设置规则的时候都会调用subRoutesToRoute:方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (NSMutableDictionary <span style=color:#f92672>*</span>)<span style=color:#a6e22e>subRoutesToRoute:</span>(NSString <span style=color:#f92672>*</span>)route
{
    NSArray <span style=color:#f92672>*</span>pathComponents <span style=color:#f92672>=</span> [self pathComponentsFromRoute:route];

    NSInteger index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    NSMutableDictionary <span style=color:#f92672>*</span>subRoutes <span style=color:#f92672>=</span> self.routes;

    <span style=color:#66d9ef>while</span> (index <span style=color:#f92672>&lt;</span> pathComponents.count) {
        NSString <span style=color:#f92672>*</span>pathComponent <span style=color:#f92672>=</span> pathComponents[index];
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>[subRoutes objectForKey:pathComponent]) {
            subRoutes[pathComponent] <span style=color:#f92672>=</span> [[NSMutableDictionary alloc] init];
        }
        subRoutes <span style=color:#f92672>=</span> subRoutes[pathComponent];
        index<span style=color:#f92672>++</span>;
    }
    
    <span style=color:#66d9ef>return</span> subRoutes;
}


</code></pre></div><p>上面这段函数就是来构造路由匹配规则的字典。</p><p>举个例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
[[HHRouter shared] map:<span style=color:#e6db74>@&#34;/user/:userId/&#34;</span>
         toControllerClass:[UserViewController <span style=color:#66d9ef>class</span>]];
[[HHRouter shared] map:<span style=color:#e6db74>@&#34;/story/:storyId/&#34;</span>
         toControllerClass:[StoryViewController <span style=color:#66d9ef>class</span>]];
[[HHRouter shared] map:<span style=color:#e6db74>@&#34;/user/:userId/story/?a=0&#34;</span>
         toControllerClass:[StoryListViewController <span style=color:#66d9ef>class</span>]];

</code></pre></div><p>设置3条规则以后，按照上面构造路由匹配规则的字典的方法，该路由规则字典就会变成这个样子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>{<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#a6e22e>story</span> =     {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>        &#34;:storyId&#34; =         {</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>            &#34;_&#34; = StoryViewController;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>        };<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    };<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#a6e22e>user</span> =     {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>        &#34;:userId&#34; =         {</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>            &#34;_&#34; = UserViewController;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>            <span style=color:#a6e22e>story</span> =             {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>                &#34;_&#34; = StoryListViewController;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>            };<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>        };<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    };<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>路由规则字典生成之后，等到匹配的时候就会遍历这个字典。</p><p>假设这时候有一条路由过来：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
  [[[HHRouter shared] matchController:<span style=color:#e6db74>@&#34;hhrouter20://user/1/&#34;</span>] <span style=color:#66d9ef>class</span>],


</code></pre></div><p>HHRouter对这条路由的处理方式是先匹配前面的scheme，如果连scheme都不正确的话，会直接导致后面匹配失败。</p><p>然后再进行路由匹配，最后生成的参数字典如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

{
    <span style=color:#e6db74>&#34;controller_class&#34;</span> <span style=color:#f92672>=</span> UserViewController;
    route <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/user/1/&#34;</span>;
    userId <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
}

</code></pre></div><p>具体的路由参数匹配的函数在</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (NSDictionary <span style=color:#f92672>*</span>)<span style=color:#a6e22e>paramsInRoute:</span>(NSString <span style=color:#f92672>*</span>)route


</code></pre></div><p>这个方法里面实现的。这个方法就是按照路由匹配规则，把传进来的URL的参数都一一解析出来，带？号的也都会解析成字典。这个方法没什么难度，就不在赘述了。</p><p>ViewController 的字典里面默认还会加上2项：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#e6db74>&#34;controller_class&#34;</span> <span style=color:#f92672>=</span> 
route <span style=color:#f92672>=</span> 

</code></pre></div><p>route里面都会保存传过来的完整的URL。</p><p>如果传进来的路由后面带访问字符串呢？那我们再来看看：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
[[HHRouter shared] matchController:<span style=color:#e6db74>@&#34;/user/1/?a=b&amp;c=d&#34;</span>]


</code></pre></div><p>那么解析出所有的参数字典会是下面的样子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
{
    a <span style=color:#f92672>=</span> b;
    c <span style=color:#f92672>=</span> d;
    <span style=color:#e6db74>&#34;controller_class&#34;</span> <span style=color:#f92672>=</span> UserViewController;
    route <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/user/1/?a=b&amp;c=d&#34;</span>;
    userId <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
}

</code></pre></div><p>同理，如果是一个block闭包的情况呢？</p><p>还是先添加一条block闭包的路由规则：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

[[HHRouter shared] map:<span style=color:#e6db74>@&#34;/user/add/&#34;</span>
                   toBlock:<span style=color:#f92672>^</span><span style=color:#66d9ef>id</span>(NSDictionary<span style=color:#f92672>*</span> params) {
                   }];


</code></pre></div><p>这条规则对应的会生成一个路由规则的字典。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
{
    story <span style=color:#f92672>=</span>     {
        <span style=color:#e6db74>&#34;:storyId&#34;</span> <span style=color:#f92672>=</span>         {
            <span style=color:#e6db74>&#34;_&#34;</span> <span style=color:#f92672>=</span> StoryViewController;
        };
    };
    user <span style=color:#f92672>=</span>     {
        <span style=color:#e6db74>&#34;:userId&#34;</span> <span style=color:#f92672>=</span>         {
            <span style=color:#e6db74>&#34;_&#34;</span> <span style=color:#f92672>=</span> UserViewController;
            story <span style=color:#f92672>=</span>             {
                <span style=color:#e6db74>&#34;_&#34;</span> <span style=color:#f92672>=</span> StoryListViewController;
            };
        };
        add <span style=color:#f92672>=</span>         {
            <span style=color:#e6db74>&#34;_&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&lt;__NSMallocBlock__: 0x600000240480&gt;&#34;</span>;
        };
    };
}



</code></pre></div><p>注意”_”后面跟着是一个block。</p><p>匹配block闭包的方式有两种。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>// 1.第一种方式匹配到对应的block之后，还需要手动调用一次闭包。
</span><span style=color:#75715e></span>    HHRouterBlock block <span style=color:#f92672>=</span> [[HHRouter shared] matchBlock:<span style=color:#e6db74>@&#34;/user/add/?a=1&amp;b=2&#34;</span>];
    block(nil);


<span style=color:#75715e>// 2.第二种方式匹配block之后自动会调用改闭包。
</span><span style=color:#75715e></span>    [[HHRouter shared] callBlock:<span style=color:#e6db74>@&#34;/user/add/?a=1&amp;b=2&#34;</span>];


</code></pre></div><p>匹配出来的参数字典是如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
{
    a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
    block <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&lt;__NSMallocBlock__: 0x600000056b90&gt;&#34;</span>;
    route <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/user/add/?a=1&amp;b=2&#34;</span>;
}


</code></pre></div><p>block的字典里面会默认加上下面这2项：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
block <span style=color:#f92672>=</span> 
route <span style=color:#f92672>=</span> 

</code></pre></div><p>route里面都会保存传过来的完整的URL。</p><p>生成的参数字典最终会被绑定到ViewController的Associated Object关联对象上。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>setParams:</span>(NSDictionary <span style=color:#f92672>*</span>)paramsDictionary
{
    objc_setAssociatedObject(self, <span style=color:#f92672>&amp;</span>kAssociatedParamsObjectKey, paramsDictionary, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (NSDictionary <span style=color:#f92672>*</span>)<span style=color:#a6e22e>params</span>
{
    <span style=color:#66d9ef>return</span> objc_getAssociatedObject(self, <span style=color:#f92672>&amp;</span>kAssociatedParamsObjectKey);
}


</code></pre></div><p>这个绑定的过程是在match匹配完成的时候进行的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>


- (UIViewController <span style=color:#f92672>*</span>)<span style=color:#a6e22e>matchController:</span>(NSString <span style=color:#f92672>*</span>)route
{
    NSDictionary <span style=color:#f92672>*</span>params <span style=color:#f92672>=</span> [self paramsInRoute:route];
    <span style=color:#66d9ef>Class</span> controllerClass <span style=color:#f92672>=</span> params[<span style=color:#e6db74>@&#34;controller_class&#34;</span>];

    UIViewController <span style=color:#f92672>*</span>viewController <span style=color:#f92672>=</span> [[controllerClass alloc] init];

    <span style=color:#66d9ef>if</span> ([viewController respondsToSelector:<span style=color:#66d9ef>@selector</span>(setParams:)]) {
        [viewController performSelector:<span style=color:#66d9ef>@selector</span>(setParams:)
                             withObject:[params <span style=color:#66d9ef>copy</span>]];
    }
    <span style=color:#66d9ef>return</span> viewController;
}


</code></pre></div><p>最终得到的ViewController也是我们想要的。相应的参数都在它绑定的params属性的字典里面。</p><p>将上述过程图解出来，如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_27.png alt></p><h4 id=4mgjrouterhttpsgithubcommogujiemgjrouter-star-633>（4）<strong><a href=https://github.com/mogujie/MGJRouter>MGJRouter</a></strong> Star 633</h4><p>这是蘑菇街的一个路由的方法。</p><p>这个库的由来：</p><p>JLRoutes 的问题主要在于查找 URL 的实现不够高效，通过遍历而不是匹配。还有就是功能偏多。</p><p>HHRouter 的 URL 查找是基于匹配，所以会更高效，MGJRouter 也是采用的这种方法，但它跟 ViewController 绑定地过于紧密，一定程度上降低了灵活性。</p><p>于是就有了 MGJRouter。</p><p>从数据结构来看，MGJRouter还是和HHRouter一模一样的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>MGJRouter</span> ()
<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>) NSMutableDictionary <span style=color:#f92672>*</span>routes;
<span style=color:#66d9ef>@end</span>

</code></pre></div><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_28.png alt></p><p>那么我们就来看看它对HHRouter做了哪些优化改进。</p><h5 id=1mgjrouter支持openurl时可以传一些-userinfo-过去>1.MGJRouter支持openURL时，可以传一些 userinfo 过去</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
[MGJRouter openURL:<span style=color:#e6db74>@&#34;mgj://category/travel&#34;</span> withUserInfo:<span style=color:#ae81ff>@{</span><span style=color:#e6db74>@&#34;user_id&#34;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>@1900</span><span style=color:#ae81ff>}</span> completion:nil];


</code></pre></div><p>这个对比HHRouter，仅仅只是写法上的一个语法糖，在HHRouter中虽然不支持带字典的参数，但是在URL后面可以用URL Query Parameter来弥补。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

    <span style=color:#66d9ef>if</span> (parameters) {
        MGJRouterHandler handler <span style=color:#f92672>=</span> parameters[<span style=color:#e6db74>@&#34;block&#34;</span>];
        <span style=color:#66d9ef>if</span> (completion) {
            parameters[MGJRouterParameterCompletion] <span style=color:#f92672>=</span> completion;
        }
        <span style=color:#66d9ef>if</span> (userInfo) {
            parameters[MGJRouterParameterUserInfo] <span style=color:#f92672>=</span> userInfo;
        }
        <span style=color:#66d9ef>if</span> (handler) {
            [parameters removeObjectForKey:<span style=color:#e6db74>@&#34;block&#34;</span>];
            handler(parameters);
        }
    }


</code></pre></div><p>MGJRouter对userInfo的处理是直接把它封装到Key = MGJRouterParameterUserInfo对应的Value里面。</p><h5 id=2支持中文的url>2.支持中文的URL。</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    [parameters enumerateKeysAndObjectsUsingBlock:<span style=color:#f92672>^</span>(<span style=color:#66d9ef>id</span> key, NSString <span style=color:#f92672>*</span>obj, <span style=color:#66d9ef>BOOL</span> <span style=color:#f92672>*</span>stop) {
        <span style=color:#66d9ef>if</span> ([obj isKindOfClass:[NSString <span style=color:#66d9ef>class</span>]]) {
            parameters[key] <span style=color:#f92672>=</span> [obj stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
        }
    }];


</code></pre></div><p>这里就是需要注意一下编码。</p><h5 id=3定义一个全局的-url-pattern-作为-fallback>3.定义一个全局的 URL Pattern 作为 Fallback。</h5><p>这一点是模仿的JLRoutes的匹配不到会自动降级到global的思想。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
    <span style=color:#66d9ef>if</span> (parameters) {
        MGJRouterHandler handler <span style=color:#f92672>=</span> parameters[<span style=color:#e6db74>@&#34;block&#34;</span>];
        <span style=color:#66d9ef>if</span> (handler) {
            [parameters removeObjectForKey:<span style=color:#e6db74>@&#34;block&#34;</span>];
            handler(parameters);
        }
    }


</code></pre></div><p>parameters字典里面会先存储下一个路由规则，存在block闭包中，在匹配的时候会取出这个handler，降级匹配到这个闭包中，进行最终的处理。</p><h5 id=4当-openurl-结束时可以执行-completion-block>4.当 OpenURL 结束时，可以执行 Completion Block。</h5><p>在MGJRouter里面，作者对原来的HHRouter字典里面存储的路由规则的结构进行了改造。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
NSString <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> MGJRouterParameterURL <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;MGJRouterParameterURL&#34;</span>;
NSString <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> MGJRouterParameterCompletion <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;MGJRouterParameterCompletion&#34;</span>;
NSString <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> MGJRouterParameterUserInfo <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;MGJRouterParameterUserInfo&#34;</span>;

</code></pre></div><p>这3个key会分别保存一些信息：</p><p>MGJRouterParameterURL保存的传进来的完整的URL信息。
MGJRouterParameterCompletion保存的是completion闭包。
MGJRouterParameterUserInfo保存的是UserInfo字典。</p><p>举个例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

    [MGJRouter registerURLPattern:<span style=color:#e6db74>@&#34;ele://name/:name&#34;</span> toHandler:<span style=color:#f92672>^</span>(NSDictionary <span style=color:#f92672>*</span>routerParameters) {
        <span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>completion)(NSString <span style=color:#f92672>*</span>) <span style=color:#f92672>=</span> routerParameters[MGJRouterParameterCompletion];
        <span style=color:#66d9ef>if</span> (completion) {
            completion(<span style=color:#e6db74>@&#34;完成了&#34;</span>);
        }
    }];
    
    [MGJRouter openURL:<span style=color:#e6db74>@&#34;ele://name/halfrost/?age=20&#34;</span> withUserInfo:<span style=color:#ae81ff>@{</span><span style=color:#e6db74>@&#34;user_id&#34;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>@1900</span><span style=color:#ae81ff>}</span> completion:<span style=color:#f92672>^</span>(<span style=color:#66d9ef>id</span> result) {
        NSLog(<span style=color:#e6db74>@&#34;result = %@&#34;</span>,result);
    }];


</code></pre></div><p>上面的URL会匹配成功，那么生成的参数字典结构如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
{
    MGJRouterParameterCompletion <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&lt;__NSGlobalBlock__: 0x107ffe680&gt;&#34;</span>;
    MGJRouterParameterURL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ele://name/halfrost/?age=20&#34;</span>;
    MGJRouterParameterUserInfo <span style=color:#f92672>=</span>     {
        <span style=color:#e6db74>&#34;user_id&#34;</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1900</span>;
    };
    age <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
    block <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&lt;__NSMallocBlock__: 0x608000252120&gt;&#34;</span>;
    name <span style=color:#f92672>=</span> halfrost;
}


</code></pre></div><h5 id=5可以统一管理url>5.可以统一管理URL</h5><p>这个功能非常有用。</p><p>URL 的处理一不小心，就容易散落在项目的各个角落，不容易管理。比如注册时的 pattern 是 mgj://beauty/:id，然后 open 时就是 mgj://beauty/123，这样到时候 url 有改动，处理起来就会很麻烦，不好统一管理。</p><p>所以 MGJRouter 提供了一个类方法来处理这个问题。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#75715e>#define TEMPLATE_URL @&#34;qq:</span><span style=color:#75715e>//name/:name&#34;
</span><span style=color:#75715e></span>
[MGJRouter registerURLPattern:TEMPLATE_URL  toHandler:<span style=color:#f92672>^</span>(NSDictionary <span style=color:#f92672>*</span>routerParameters) {
    NSLog(<span style=color:#e6db74>@&#34;routerParameters[name]:%@&#34;</span>, routerParameters[<span style=color:#e6db74>@&#34;name&#34;</span>]); <span style=color:#75715e>// halfrost
</span><span style=color:#75715e></span>}];

[MGJRouter openURL:[MGJRouter generateURLWithPattern:TEMPLATE_URL parameters:<span style=color:#ae81ff>@[</span><span style=color:#e6db74>@&#34;halfrost&#34;</span><span style=color:#ae81ff>]</span>]];
}


</code></pre></div><p>generateURLWithPattern:函数会对我们定义的宏里面的所有的:进行替换，替换成后面的字符串数组，依次赋值。</p><p>将上述过程图解出来，如下：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_29.png alt></p><p>蘑菇街为了区分开页面间调用和组件间调用，于是想出了一种新的方法。用Protocol的方法来进行组件间的调用。</p><p>每个组件之间都有一个 Entry，这个 Entry，主要做了三件事：</p><ol><li>注册这个组件关心的 URL</li><li>注册这个组件能够被调用的方法/属性</li><li>在 App 生命周期的不同阶段做不同的响应</li></ol><p>页面间的openURL调用就是如下的样子：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_30.png alt></p><p>每个组件间都会向MGJRouter注册，组件间相互调用或者是其他的App都可以通过openURL:方法打开一个界面或者调用一个组件。</p><p>在组件间的调用，蘑菇街采用了Protocol的方式。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_31.png alt></p><p>[ModuleManager registerClass:ClassA forProtocol:ProtocolA] 的结果就是在 MM 内部维护的 dict 里新加了一个映射关系。</p><p>[ModuleManager classForProtocol:ProtocolA] 的返回结果就是之前在 MM 内部 dict 里 protocol 对应的 class，使用方不需要关心这个 class 是个什么东东，反正实现了 ProtocolA 协议，拿来用就行。</p><p>这里需要有一个公共的地方来容纳这些 public protocl，也就是图中的 PublicProtocl.h。</p><p>我猜测，大概实现可能是下面的样子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>ModuleProtocolManager</span> : <span style=color:#a6e22e>NSObject</span>

+ (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>registServiceProvide:</span>(<span style=color:#66d9ef>id</span>)provide <span style=color:#a6e22e>forProtocol:</span>(Protocol<span style=color:#f92672>*</span>)protocol;
+ (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>serviceProvideForProtocol:</span>(Protocol <span style=color:#f92672>*</span>)protocol;

<span style=color:#66d9ef>@end</span>

</code></pre></div><p>然后这个是一个单例，在里面注册各个协议：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>ModuleProtocolManager</span> ()

<span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>) NSMutableDictionary <span style=color:#f92672>*</span>serviceProvideSource;
<span style=color:#66d9ef>@end</span>

<span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>ModuleProtocolManager</span>

+ (ModuleProtocolManager <span style=color:#f92672>*</span>)<span style=color:#a6e22e>sharedInstance</span>
{
    <span style=color:#66d9ef>static</span> ModuleProtocolManager <span style=color:#f92672>*</span> instance;
    <span style=color:#66d9ef>static</span> dispatch_once_t onceToken;
    dispatch_once(<span style=color:#f92672>&amp;</span>onceToken, <span style=color:#f92672>^</span>{
        instance <span style=color:#f92672>=</span> [[self alloc] init];
    });
    <span style=color:#66d9ef>return</span> instance;
}

- (<span style=color:#66d9ef>instancetype</span>)<span style=color:#a6e22e>init</span>
{
    self <span style=color:#f92672>=</span> [super init];
    <span style=color:#66d9ef>if</span> (self) {
        _serviceProvideSource <span style=color:#f92672>=</span> [[NSMutableDictionary alloc] init];
    }
    <span style=color:#66d9ef>return</span> self;
}

+ (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>registServiceProvide:</span>(<span style=color:#66d9ef>id</span>)provide <span style=color:#a6e22e>forProtocol:</span>(Protocol<span style=color:#f92672>*</span>)protocol
{
    <span style=color:#66d9ef>if</span> (provide <span style=color:#f92672>==</span> nil <span style=color:#f92672>||</span> protocol <span style=color:#f92672>==</span> nil)
        <span style=color:#66d9ef>return</span>;
    [[self sharedInstance].serviceProvideSource setObject:provide forKey:NSStringFromProtocol(protocol)];
}

+ (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>serviceProvideForProtocol:</span>(Protocol <span style=color:#f92672>*</span>)protocol
{
    <span style=color:#66d9ef>return</span> [[self sharedInstance].serviceProvideSource objectForKey:NSStringFromProtocol(protocol)];
}



</code></pre></div><p>在ModuleProtocolManager中用一个字典保存每个注册的protocol。现在再来猜猜ModuleEntry的实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#75715e>#import &lt;Foundation/Foundation.h&gt;
</span><span style=color:#75715e>#import &lt;UIKit/UIKit.h&gt;
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>@protocol</span> <span style=color:#a6e22e>DetailModuleEntryProtocol</span> <span style=color:#f92672>&lt;</span>NSObject<span style=color:#f92672>&gt;</span>

<span style=color:#66d9ef>@required</span>;
- (UIViewController <span style=color:#f92672>*</span>)<span style=color:#a6e22e>detailViewControllerWithId:</span>(NSString<span style=color:#f92672>*</span>)Id <span style=color:#a6e22e>Name:</span>(NSString <span style=color:#f92672>*</span>)name;
<span style=color:#66d9ef>@end</span>


</code></pre></div><p>然后每个模块内都有一个和暴露到外面的协议相连接的“接头”。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#75715e>#import &lt;Foundation/Foundation.h&gt;
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>DetailModuleEntry</span> : <span style=color:#a6e22e>NSObject</span>
<span style=color:#66d9ef>@end</span>


</code></pre></div><p>在它的实现中，需要引入3个外部文件，一个是ModuleProtocolManager，一个是DetailModuleEntryProtocol，最后一个是所在模块需要跳转或者调用的组件或者页面。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>

<span style=color:#75715e>#import &#34;DetailModuleEntry.h&#34;
</span><span style=color:#75715e></span>
<span style=color:#75715e>#import &lt;DetailModuleEntryProtocol/DetailModuleEntryProtocol.h&gt;
</span><span style=color:#75715e>#import &lt;ModuleProtocolManager/ModuleProtocolManager.h&gt;
</span><span style=color:#75715e>#import &#34;DetailViewController.h&#34;
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>DetailModuleEntry</span>()<span style=color:#f92672>&lt;</span>DetailModuleEntryProtocol<span style=color:#f92672>&gt;</span>

<span style=color:#66d9ef>@end</span>

<span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>DetailModuleEntry</span>

+ (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>load</span>
{
    [ModuleProtocolManager registServiceProvide:[[self alloc] init] forProtocol:@protocol(DetailModuleEntryProtocol)];
}

- (UIViewController <span style=color:#f92672>*</span>)<span style=color:#a6e22e>detailViewControllerWithId:</span>(NSString<span style=color:#f92672>*</span>)Id <span style=color:#a6e22e>Name:</span>(NSString <span style=color:#f92672>*</span>)name
{
    DetailViewController <span style=color:#f92672>*</span>detailVC <span style=color:#f92672>=</span> [[DetailViewController alloc] initWithId:<span style=color:#66d9ef>id</span> Name:name];
    <span style=color:#66d9ef>return</span> detailVC;
}

<span style=color:#66d9ef>@end</span>


</code></pre></div><p>至此基于Protocol的方案就完成了。如果需要调用某个组件或者跳转某个页面，只要先从ModuleProtocolManager的字典里面根据对应的ModuleEntryProtocol找到对应的DetailModuleEntry，找到了DetailModuleEntry就是找到了组件或者页面的“入口”了。再把参数传进去即可。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>


- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>didClickDetailButton:</span>(UIButton <span style=color:#f92672>*</span>)button
{
    <span style=color:#66d9ef>id</span><span style=color:#f92672>&lt;</span> DetailModuleEntryProtocol <span style=color:#f92672>&gt;</span> DetailModuleEntry <span style=color:#f92672>=</span> [ModuleProtocolManager serviceProvideForProtocol:@protocol(DetailModuleEntryProtocol)];
    UIViewController <span style=color:#f92672>*</span>detailVC <span style=color:#f92672>=</span> [DetailModuleEntry detailViewControllerWithId:@<span style=color:#960050;background-color:#1e0010>“详情界面”</span> Name:@<span style=color:#960050;background-color:#1e0010>“我的购物车”</span>];
    [self.navigationController pushViewController:detailVC animated:YES];
    
}


</code></pre></div><p>这样就可以调用到组件或者界面了。</p><p>如果组件之间有相同的接口，那么还可以进一步的把这些接口都抽离出来。这些抽离出来的接口变成“元接口”，它们是可以足够支撑起整个组件一层的。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_32.png alt></p><h4 id=5ctmediatorhttpsgithubcomcasatwyctmediator--star-803>（5）<strong><a href=https://github.com/casatwy/CTMediator>CTMediator</a></strong> Star 803</h4><p>再来说说@casatwy的方案，这方案是基于Mediator的。</p><p>传统的中间人Mediator的模式是这样的：</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_33.png alt></p><p>这种模式每个页面或者组件都会依赖中间者，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator还是会依赖其他组件。那么这是最终方案了么？</p><p>看看@casatwy是怎么继续优化的。</p><p>主要思想是利用了Target-Action简单粗暴的思想，利用Runtime解决解耦的问题。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (<span style=color:#66d9ef>id</span>)<span style=color:#a6e22e>performTarget:</span>(NSString <span style=color:#f92672>*</span>)targetName <span style=color:#a6e22e>action:</span>(NSString <span style=color:#f92672>*</span>)actionName <span style=color:#a6e22e>params:</span>(NSDictionary <span style=color:#f92672>*</span>)params <span style=color:#a6e22e>shouldCacheTarget:</span>(<span style=color:#66d9ef>BOOL</span>)shouldCacheTarget
{
    
    NSString <span style=color:#f92672>*</span>targetClassString <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;Target_%@&#34;</span>, targetName];
    NSString <span style=color:#f92672>*</span>actionString <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;Action_%@:&#34;</span>, actionName];
    <span style=color:#66d9ef>Class</span> targetClass;
    
    NSObject <span style=color:#f92672>*</span>target <span style=color:#f92672>=</span> self.cachedTarget[targetClassString];
    <span style=color:#66d9ef>if</span> (target <span style=color:#f92672>==</span> nil) {
        targetClass <span style=color:#f92672>=</span> NSClassFromString(targetClassString);
        target <span style=color:#f92672>=</span> [[targetClass alloc] init];
    }
    
    <span style=color:#66d9ef>SEL</span> action <span style=color:#f92672>=</span> NSSelectorFromString(actionString);
    
    <span style=color:#66d9ef>if</span> (target <span style=color:#f92672>==</span> nil) {
        <span style=color:#75715e>// 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> nil;
    }
    
    <span style=color:#66d9ef>if</span> (shouldCacheTarget) {
        self.cachedTarget[targetClassString] <span style=color:#f92672>=</span> target;
    }

    <span style=color:#66d9ef>if</span> ([target respondsToSelector:action]) {
<span style=color:#75715e>#pragma clang diagnostic push
</span><span style=color:#75715e>#pragma clang diagnostic ignored &#34;-Warc-performSelector-leaks&#34;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> [target performSelector:action withObject:params];
<span style=color:#75715e>#pragma clang diagnostic pop
</span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> {
        <span style=color:#75715e>// 有可能target是Swift对象
</span><span style=color:#75715e></span>        actionString <span style=color:#f92672>=</span> [NSString stringWithFormat:<span style=color:#e6db74>@&#34;Action_%@WithParams:&#34;</span>, actionName];
        action <span style=color:#f92672>=</span> NSSelectorFromString(actionString);
        <span style=color:#66d9ef>if</span> ([target respondsToSelector:action]) {
<span style=color:#75715e>#pragma clang diagnostic push
</span><span style=color:#75715e>#pragma clang diagnostic ignored &#34;-Warc-performSelector-leaks&#34;
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> [target performSelector:action withObject:params];
<span style=color:#75715e>#pragma clang diagnostic pop
</span><span style=color:#75715e></span>        } <span style=color:#66d9ef>else</span> {
            <span style=color:#75715e>// 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>SEL</span> action <span style=color:#f92672>=</span> NSSelectorFromString(<span style=color:#e6db74>@&#34;notFound:&#34;</span>);
            <span style=color:#66d9ef>if</span> ([target respondsToSelector:action]) {
<span style=color:#75715e>#pragma clang diagnostic push
</span><span style=color:#75715e>#pragma clang diagnostic ignored &#34;-Warc-performSelector-leaks&#34;
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>return</span> [target performSelector:action withObject:params];
<span style=color:#75715e>#pragma clang diagnostic pop
</span><span style=color:#75715e></span>            } <span style=color:#66d9ef>else</span> {
                <span style=color:#75715e>// 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。
</span><span style=color:#75715e></span>                [self.cachedTarget removeObjectForKey:targetClassString];
                <span style=color:#66d9ef>return</span> nil;
            }
        }
    }
}



</code></pre></div><p>targetName就是调用接口的Object，actionName就是调用方法的SEL，params是参数，shouldCacheTarget代表是否需要缓存，如果需要缓存就把target存起来，Key是targetClassString，Value是target。</p><p>通过这种方式进行改造的，外面调用的方法都很统一，都是调用performTarget: action: params: shouldCacheTarget:。第三个参数是一个字典，这个字典里面可以传很多参数，只要Key-Value写好就可以了。处理错误的方式也统一在一个地方了，target没有，或者是target无法响应相应的方法，都可以在Mediator这里进行统一出错处理。</p><p>但是在实际开发过程中，不管是界面调用，组件间调用，在Mediator中需要定义很多方法。于是作者又想出了建议我们用Category的方法，对Mediator的所有方法进行拆分，这样就就可以不会导致Mediator这个类过于庞大了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>
- (UIViewController <span style=color:#f92672>*</span>)<span style=color:#a6e22e>CTMediator_viewControllerForDetail</span>
{
    UIViewController <span style=color:#f92672>*</span>viewController <span style=color:#f92672>=</span> [self performTarget:kCTMediatorTargetA
                                                    action:kCTMediatorActionNativFetchDetailViewController
                                                    params:<span style=color:#ae81ff>@{</span><span style=color:#e6db74>@&#34;key&#34;</span><span style=color:#f92672>:</span><span style=color:#e6db74>@&#34;value&#34;</span><span style=color:#ae81ff>}</span>
                                         shouldCacheTarget:NO
                                        ];
    <span style=color:#66d9ef>if</span> ([viewController isKindOfClass:[UIViewController <span style=color:#66d9ef>class</span>]]) {
        <span style=color:#75715e>// view controller 交付出去之后，可以由外界选择是push还是present
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> viewController;
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#75715e>// 这里处理异常场景，具体如何处理取决于产品
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> [[UIViewController alloc] init];
    }
}



- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>CTMediator_presentImage:</span>(UIImage <span style=color:#f92672>*</span>)image
{
    <span style=color:#66d9ef>if</span> (image) {
        [self performTarget:kCTMediatorTargetA
                     action:kCTMediatorActionNativePresentImage
                     params:<span style=color:#ae81ff>@{</span><span style=color:#e6db74>@&#34;image&#34;</span><span style=color:#f92672>:</span>image<span style=color:#ae81ff>}</span>
          shouldCacheTarget:NO];
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#75715e>// 这里处理image为nil的场景，如何处理取决于产品
</span><span style=color:#75715e></span>        [self performTarget:kCTMediatorTargetA
                     action:kCTMediatorActionNativeNoImage
                     params:<span style=color:#ae81ff>@{</span><span style=color:#e6db74>@&#34;image&#34;</span><span style=color:#f92672>:</span>[UIImage imageNamed:<span style=color:#e6db74>@&#34;noImage&#34;</span>]<span style=color:#ae81ff>}</span>
          shouldCacheTarget:NO];
    }
}

</code></pre></div><p>把这些具体的方法一个个的都写在Category里面就好了，调用的方式都非常的一致，都是调用performTarget: action: params: shouldCacheTarget:方法。</p><p>最终去掉了中间者Mediator对组件的依赖，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator不依赖其他任何组件。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_34.png alt></p><h4 id=6一些并没有开源的方案>（6）一些并没有开源的方案</h4><p>除了上面开源的路由方案，还有一些并没有开源的设计精美的方案。这里可以和大家一起分析交流一下。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_35.png alt></p><p>这个方案是Uber 骑手App的一个方案。</p><p>Uber在发现MVC的一些弊端之后：比如动辄上万行巨胖无比的VC，无法进行单元测试等缺点后，于是考虑把架构换成VIPER。但是VIPER也有一定的弊端。因为它的iOS特定的结构，意味着iOS必须为Android做出一些妥协的权衡。以视图为驱动的应用程序逻辑，代表应用程序状态由视图驱动，整个应用程序都锁定在视图树上。由操作应用程序状态所关联的业务逻辑的改变，就必须经过Presenter。因此会暴露业务逻辑。最终导致了视图树和业务树进行了紧紧的耦合。这样想实现一个紧紧只有业务逻辑的Node节点或者紧紧只有视图逻辑的Node节点就非常的困难了。</p><p>通过改进VIPER架构，吸收其优秀的特点，改进其缺点，就形成了Uber 骑手App的全新架构——Riblets(肋骨)。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_36.png alt></p><p>在这个新的架构中，即使是相似的逻辑也会被区分成很小很小，相互独立，可以单独进行测试的组件。每个组件都有非常明确的用途。使用这些一小块一小块的Riblets(肋骨)，最终把整个App拼接成一颗Riblets(肋骨)树。</p><p>通过抽象，一个Riblets(肋骨)被定义成一下6个更小的组件，这些组件各自有各自的职责。通过一个Riblets(肋骨)进一步的抽象业务逻辑和视图逻辑。</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_37.png alt></p><p>一个Riblets(肋骨)被设计成这样，那和之前的VIPER和MVC有什么区别呢？最大的区别在路由上面。</p><p>Riblets(肋骨)内的Router不再是视图逻辑驱动的，现在变成了业务逻辑驱动。这一重大改变就导致了整个App不再是由表现形式驱动，现在变成了由数据流驱动。</p><p>每一个Riblet都是由一个路由Router，一个关联器Interactor，一个构造器Builder和它们相关的组件构成的。所以它的命名（Router - Interactor - Builder，Rib）也由此得来。当然还可以有可选的展示器Presenter和视图View。路由Router和关联器Interactor处理业务逻辑，展示器Presenter和视图View处理视图逻辑。</p><p>重点分析一下Riblet里面路由的职责。</p><h5 id=1路由的职责>1.路由的职责</h5><p>在整个App的结构树中，路由的职责是用来关联和取消关联其他子Riblet的。至于决定是由关联器Interactor传递过来的。在状态转换过程中，关联和取消关联子Riblet的时候，路由也会影响到关联器Interactor的生命周期。路由只包含2个业务逻辑：</p><p>1.提供关联和取消关联其他路由的方法。
2.在多个孩子之间决定最终状态的状态转换逻辑。</p><h5 id=2拼装>2.拼装</h5><p>每一个Riblets只有一对Router路由和Interactor关联器。但是它们可以有多对视图。Riblets只处理业务逻辑，不处理视图相关的部分。Riblets可以拥有单一的视图（一个Presenter展示器和一个View视图），也可以拥有多个视图（一个Presenter展示器和多个View视图，或者多个Presenter展示器和多个View视图），甚至也可以能没有视图（没有Presenter展示器也没有View视图）。这种设计可以有助于业务逻辑树的构建，也可以和视图树做到很好的分离。</p><p>举个例子，骑手的Riblet是一个没有视图的Riblet，它用来检查当前用户是否有一个激活的路线。如果骑手确定了路线，那么这个Riblet就会关联到路线的Riblet上面。路线的Riblet会在地图上显示出路线图。如果没有确定路线，骑手的Riblet就会被关联到请求的Riblet上。请求的Riblet会在屏幕上显示等待被呼叫。像骑手的Riblet这样没有任何视图逻辑的Riblet，它分开了业务逻辑，在驱动App和支撑模块化架构起了重大作用。</p><h5 id=3riblets是如何工作的>3.Riblets是如何工作的</h5><p>Riblet中的数据流</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_38.png alt></p><p>在这个新的架构中，数据流动是单向的。Data数据流从service服务流到Model Stream生成Model流。Model流再从Model Stream流动到Interactor关联器。Interactor关联器，scheduler调度器，远程推送都可以想Service触发变化来引起Model Stream的改动。Model Stream生成不可改动的models。这个强制的要求就导致关联器只能通过Service层改变App的状态。</p><p>举两个例子：</p><ol><li><p>数据从后台到视图View上<br>一个状态的改变，引起服务器后台触发推送到App。数据就被Push到App，然后生成不可变的数据流。关联器收到model之后，把它传递给展示器Presenter。展示器Presenter把model转换成view model传递给视图View。</p></li><li><p>数据从视图到服务器后台<br>当用户点击了一个按钮，比如登录按钮。视图View就会触发UI事件传递给展示器Presenter。展示器Presenter调用关联器Interactor登录方法。关联器Interactor又会调用Service call的实际登录方法。请求网络之后会把数据pull到后台服务器。</p></li></ol><p>Riblet间的数据流</p><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_39.png alt></p><p>当一个关联器Interactor在处理业务逻辑的工程中，需要调用其他Riblet的事件的时候，关联器Interactor需要和子关联器Interactor进行关联。见上图5个步骤。</p><p>如果调用方法是从子调用父类，父类的Interactor的接口通常被定义成监听者listener。如果调用方法是从父类调用到子类，那么子类的接口通常是一个delegate，实现父类的一些Protocol。</p><p>在Riblet的方案中，路由Router仅仅只是用来维护一个树型关系，而关联器Interactor才担当的是用来决定触发组件间的逻辑跳转的角色。</p><h3 id=五-各个方案优缺点>五. 各个方案优缺点</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_40.png alt></p><p>经过上面的分析，可以发现，路由的设计思路是从URLRoute ->Protocol-class ->Target-Action一步步的深入的过程。这也是逐渐深入本质的过程。</p><h4 id=1-urlroute注册方案的优缺点>1. URLRoute注册方案的优缺点</h4><p>首先URLRoute也许是借鉴前端Router和系统App内跳转的方式想出来的方法。它通过URL来请求资源。不管是H5，RN，Weex，iOS界面或者组件请求资源的方式就都统一了。URL里面也会带上参数，这样调用什么界面或者组件都可以。所以这种方式是最容易，也是最先可以想到的。</p><p>URLRoute的优点很多，最大的优点就是服务器可以动态的控制页面跳转，可以统一处理页面出问题之后的错误处理，可以统一三端，iOS，Android，H5 / RN / Weex 的请求方式。</p><p>但是这种方式也需要看不同公司的需求。如果公司里面已经完成了服务器端动态下发的脚手架工具，前端也完成了Native端如果出现错误了，可以随时替换相同业务界面的需求，那么这个时候可能选择URLRoute的几率会更大。</p><p>但是如果公司里面H5没有做相关出现问题后能替换的界面，H5开发人员觉得这是给他们增添负担。如果公司也没有完成服务器动态下发路由规则的那套系统，那么公司可能就不会采用URLRoute的方式。因为URLRoute带来的少量动态性，公司是可以用JSPatch来做到。线上出现bug了，可以立即用JSPatch修掉，而不采用URLRoute去做。</p><p>所以选择URLRoute这种方案，也要看公司的发展情况和人员分配，技术选型方面。</p><p>URLRoute方案也是存在一些缺点的，首先URL的map规则是需要注册的，它们会在load方法里面写。写在load方法里面是会影响App启动速度的。</p><p>其次是大量的硬编码。URL链接里面关于组件和页面的名字都是硬编码，参数也都是硬编码。而且每个URL参数字段都必须要一个文档进行维护，这个对于业务开发人员也是一个负担。而且URL短连接散落在整个App四处，维护起来实在有点麻烦，虽然蘑菇街想到了用宏统一管理这些链接，但是还是解决不了硬编码的问题。</p><p>真正一个好的路由是在无形当中服务整个App的，是一个无感知的过程，从这一点来说，略有点缺失。</p><p>最后一个缺点是，对于传递NSObject的参数，URL是不够友好的，它最多是传递一个字典。</p><h4 id=2-protocol-class注册方案的优缺点>2. Protocol-Class注册方案的优缺点</h4><p>Protocol-Class方案的优点，这个方案没有硬编码。</p><p>Protocol-Class方案也是存在一些缺点的，每个Protocol都要向ModuleManager进行注册。</p><p>这种方案ModuleEntry是同时需要依赖ModuleManager和组件里面的页面或者组件两者的。当然ModuleEntry也是会依赖ModuleEntryProtocol的，但是这个依赖是可以去掉的，比如用Runtime的方法NSProtocolFromString，加上硬编码是可以去掉对Protocol的依赖的。但是考虑到硬编码的方式对出现bug，后期维护都是不友好的，所以对Protocol的依赖还是不要去除。</p><p>最后一个缺点是组件方法的调用是分散在各处的，没有统一的入口，也就没法做组件不存在时或者出现错误时的统一处理。</p><h4 id=3-target-action方案的优缺点>3. Target-Action方案的优缺点</h4><p>Target-Action方案的优点，充分的利用Runtime的特性，无需注册这一步。Target-Action方案只有存在组件依赖Mediator这一层依赖关系。在Mediator中维护针对Mediator的Category，每个category对应一个Target，Categroy中的方法对应Action场景。Target-Action方案也统一了所有组件间调用入口。</p><p>Target-Action方案也能有一定的安全保证，它对url中进行Native前缀进行验证。</p><p>Target-Action方案的缺点，Target_Action在Category中将常规参数打包成字典，在Target处再把字典拆包成常规参数，这就造成了一部分的硬编码。</p><h4 id=4-组件如何拆分>4. 组件如何拆分？</h4><p>这个问题其实应该是在打算实施组件化之前就应该考虑的问题。为何还要放在这里说呢？因为组件的拆分每个公司都有属于自己的拆分方案，按照业务线拆？按照最细小的业务功能模块拆？还是按照一个完成的功能进行拆分？这个就牵扯到了拆分粗细度的问题了。组件拆分的粗细度就会直接关系到未来路由需要解耦的程度。</p><p>假设，把登录的所有流程封装成一个组件，由于登录里面会涉及到多个页面，那么这些页面都会打包在一个组件里面。那么其他模块需要调用登录状态的时候，这时候就需要用到登录组件暴露在外面可以获取登录状态的接口。那么这个时候就可以考虑把这些接口写到Protocol里面，暴露给外面使用。或者用Target-Action的方法。这种把一个功能全部都划分成登录组件的话，划分粒度就稍微粗一点。</p><p>如果仅仅把登录状态的细小功能划分成一个元组件，那么外面想获取登录状态就直接调用这个组件就好。这种划分的粒度就非常细了。这样就会导致组件个数巨多。</p><p>所以在进行拆分组件的时候，也许当时业务并不复杂的时候，拆分成组件，相互耦合也不大。但是随着业务不管变化，之前划分的组件间耦合性越来越大，于是就会考虑继续把之前的组件再进行拆分。也许有些业务砍掉了，之前一些小的组件也许还会被组合到一起。总之，在业务没有完全固定下来之前，组件的划分可能一直进行时。</p><h3 id=六-最好的方案>六. 最好的方案</h3><p><img src=https://img.halfrost.com/Blog/ArticleImage/40_41.png alt></p><p>关于架构，我觉得抛开业务谈架构是没有意义的。因为架构是为了业务服务的，空谈架构只是一种理想的状态。所以没有最好的方案，只有最适合的方案。</p><p>最适合自己公司业务的方案才是最好的方案。分而治之，针对不同业务选择不同的方案才是最优的解决方案。如果非要笼统的采用一种方案，不同业务之间需要同一种方案，需要妥协牺牲的东西太多就不好了。</p><p>希望本文能抛砖引玉，帮助大家选择出最适合自家业务的路由方案。当然肯定会有更加优秀的方案，希望大家能多多指点我。</p><p>References:</p><p><a href=http://casatwy.com/modulization_in_action.html>在现有工程中实施基于CTMediator的组件化方案</a><br><a href=http://casatwy.com/iOS-Modulization.html>iOS应用架构谈 组件化方案</a><br><a href=http://limboy.me/tech/2016/03/10/mgj-components.html>蘑菇街 App 的组件化之路</a><br><a href=http://limboy.me/tech/2016/03/14/mgj-components-continued.html>蘑菇街 App 的组件化之路·续</a><br><a href=https://eng.uber.com/new-rider-app/>ENGINEERING THE ARCHITECTURE BEHIND UBER’S NEW RIDER APP</a></p><blockquote><p>GitHub Repo：<a href=https://github.com/halfrost/Halfrost-Field>Halfrost-Field</a></p><p>Follow: <a href=https://github.com/halfrost>halfrost · GitHub</a></p><p>Source: <a href=https://halfrost.com/ios_router/>https://halfrost.com/ios_router/</a></p></blockquote><img src=https://img.halfrost.com/wechat-qr-code.png></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=/>Home</a></li><li><a href=https://books.halfrost.com/>Books</a></li><li><a href=https://github.com/halfrost/Halfrost-Field>Github</a></li><li><a href=https://halfrost.me/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div id=toc-footer style=display:none><nav id=TableOfContents><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#目录>目录</a></li><li><a href=#一-引子>一. 引子</a></li><li><a href=#二-app路由能解决哪些问题>二. App路由能解决哪些问题</a></li><li><a href=#三-app之间跳转实现>三. App之间跳转实现</a><ul><li><a href=#1-url-scheme方式>1. URL Scheme方式</a></li><li><a href=#2-universal-links方式>2. Universal Links方式</a></li></ul></li><li><a href=#四-app内组件间路由设计>四. App内组件间路由设计</a><ul><li><a href=#1-关于页面跳转>1. 关于页面跳转</a></li><li><a href=#2-关于组件间调用>2. 关于组件间调用</a></li><li><a href=#3-如何设计一个路由>3. 如何设计一个路由</a></li><li><a href=#1jlrouteshttpsgithubcomjoeldevjlroutes-star-3189>（1）<strong><a href=https://github.com/joeldev/JLRoutes>JLRoutes</a></strong> Star 3189</a></li><li><a href=#2routable-ioshttpsgithubcomclayallsopproutable-ios-star-1415>（2）<strong><a href=https://github.com/clayallsopp/routable-ios>routable-ios</a></strong> Star 1415</a></li><li><a href=#3hhrouterhttpsgithubcomlightoryhhrouter--star-1277>（3）<strong><a href=https://github.com/lightory/HHRouter>HHRouter</a></strong> Star 1277</a></li><li><a href=#4mgjrouterhttpsgithubcommogujiemgjrouter-star-633>（4）<strong><a href=https://github.com/mogujie/MGJRouter>MGJRouter</a></strong> Star 633</a></li><li><a href=#5ctmediatorhttpsgithubcomcasatwyctmediator--star-803>（5）<strong><a href=https://github.com/casatwy/CTMediator>CTMediator</a></strong> Star 803</a></li><li><a href=#6一些并没有开源的方案>（6）一些并没有开源的方案</a></li></ul></li><li><a href=#五-各个方案优缺点>五. 各个方案优缺点</a><ul><li><a href=#1-urlroute注册方案的优缺点>1. URLRoute注册方案的优缺点</a></li><li><a href=#2-protocol-class注册方案的优缺点>2. Protocol-Class注册方案的优缺点</a></li><li><a href=#3-target-action方案的优缺点>3. Target-Action方案的优缺点</a></li><li><a href=#4-组件如何拆分>4. 组件如何拆分？</a></li></ul></li><li><a href=#六-最好的方案>六. 最好的方案</a></li></ul></li></ul></nav></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fnew.halfrost.com%2fios_router%2f"><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&text=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&title=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&is_video=false&description=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2fnew.halfrost.com%2fios_router%2f"><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&title=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&title=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&title=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-stumbleupon fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://digg.com/submit?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&title=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-digg fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&name=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90&description=%e5%89%8d%e8%a8%80%20%e9%9a%8f%e7%9d%80%e7%94%a8%e6%88%b7%e7%9a%84%e9%9c%80%e6%b1%82%e8%b6%8a%e6%9d%a5%e8%b6%8a%e5%a4%9a%ef%bc%8c%e5%af%b9App%e7%9a%84%e7%94%a8%e6%88%b7%e4%bd%93%e9%aa%8c%e4%b9%9f%e5%8f%98%e7%9a%84%e8%a6%81%e6%b1%82%e8%b6%8a%e6%9d%a5%e8%b6%8a%e9%ab%98%e3%80%82%e4%b8%ba%e4%ba%86%e6%9b%b4%e5%a5%bd%e7%9a%84%e5%ba%94%e5%af%b9%e5%90%84%e7%a7%8d%e9%9c%80%e6%b1%82%ef%bc%8c%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98%e4%bb%8e%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e7%9a%84%e8%a7%92%e5%ba%a6%ef%bc%8c%e5%b0%86App%e6%9e%b6%e6%9e%84%e7%94%b1%e5%8e%9f%e6%9d%a5%e7%ae%80%e5%8d%95%e7%9a%84MVC%e5%8f%98%e6%88%90MVVM%ef%bc%8cVIPER%e7%ad%89%e5%a4%8d%e6%9d%82%e6%9e%b6%e6%9e%84%e3%80%82%e6%9b%b4%e6%8d%a2%e9%80%82%e5%90%88%e4%b8%9a%e5%8a%a1%e7%9a%84%e6%9e%b6%e6%9e%84%ef%bc%8c%e6%98%af%e4%b8%ba%e4%ba%86%e5%90%8e%e6%9c%9f%e8%83%bd%e6%9b%b4%e5%a5%bd%e7%9a%84%e7%bb%b4%e6%8a%a4%e9%a1%b9%e7%9b%ae%e3%80%82%0a%e4%bd%86%e6%98%af%e7%94%a8%e6%88%b7%e4%be%9d%e6%97%a7%e4%b8%8d%e6%bb%a1%e6%84%8f%ef%bc%8c%e7%bb%a7%e7%bb%ad%e5%af%b9%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98%e6%8f%90%e5%87%ba%e4%ba%86%e6%9b%b4%e5%a4%9a%e6%9b%b4%e9%ab%98%e7%9a%84%e8%a6%81%e6%b1%82%ef%bc%8c%e4%b8%8d%e4%bb%85%e9%9c%80%e8%a6%81%e9%ab%98%e8%b4%a8%e9%87%8f%e7%9a%84%e7%94%a8%e6%88%b7%e4%bd%93%e9%aa%8c%ef%bc%8c%e8%bf%98%e8%a6%81%e6%b1%82%e5%bf%ab%e9%80%9f%e8%bf%ad%e4%bb%a3%ef%bc%8c%e6%9c%80%e5%a5%bd%e4%b8%80%e5%a4%a9%e5%87%ba%e4%b8%80%e4%b8%aa%e6%96%b0%e5%8a%9f%e8%83%bd%ef%bc%8c%e8%80%8c%e4%b8%94%e7%94%a8%e6%88%b7%e8%bf%98%e8%a6%81%e6%b1%82%e4%b8%8d%e6%9b%b4%e6%96%b0%e5%b0%b1%e8%83%bd%e4%bd%93%e9%aa%8c%e5%88%b0%e6%96%b0%e5%8a%9f%e8%83%bd%e3%80%82%e4%b8%ba%e4%ba%86%e6%bb%a1%e8%b6%b3%e7%94%a8%e6%88%b7%e9%9c%80%e6%b1%82%ef%bc%8c%e4%ba%8e%e6%98%af%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98%e5%b0%b1%e7%94%a8H5%ef%bc%8cReactNative%ef%bc%8cWeex%e7%ad%89%e6%8a%80%e6%9c%af%e5%af%b9%e5%b7%b2%e6%9c%89%e7%9a%84%e9%a1%b9%e7%9b%ae%e8%bf%9b%e8%a1%8c%e6%94%b9%e9%80%a0%e3%80%82%e9%a1%b9%e7%9b%ae%e6%9e%b6%e6%9e%84%e4%b9%9f%e5%8f%98%e5%be%97%e6%9b%b4%e5%8a%a0%e7%9a%84%e5%a4%8d%e6%9d%82%ef%bc%8c%e7%ba%b5%e5%90%91%e7%9a%84%e4%bc%9a%e8%bf%9b%e8%a1%8c%e5%88%86%e5%b1%82%ef%bc%8c%e7%bd%91%e7%bb%9c%e5%b1%82%ef%bc%8cUI%e5%b1%82%ef%bc%8c%e6%95%b0%e6%8d%ae%e6%8c%81%e4%b9%85%e5%b1%82%e3%80%82%e6%af%8f%e4%b8%80%e5%b1%82%e6%a8%aa%e5%90%91%e7%9a%84%e4%b9%9f%e4%bc%9a%e6%a0%b9%e6%8d%ae%e4%b8%9a%e5%8a%a1%e8%bf%9b%e8%a1%8c%e7%bb%84%e4%bb%b6%e5%8c%96%e3%80%82%e5%b0%bd%e7%ae%a1%e8%bf%99%e6%a0%b7%e5%81%9a%e4%ba%86%e4%bb%a5%e5%90%8e%e4%bc%9a%e8%ae%a9%e5%bc%80%e5%8f%91%e6%9b%b4%e5%8a%a0%e6%9c%89%e6%95%88%e7%8e%87%ef%bc%8c%e6%9b%b4%e5%8a%a0%e5%a5%bd%e7%bb%b4%e6%8a%a4%ef%bc%8c%e4%bd%86%e6%98%af%e5%a6%82%e4%bd%95%e8%a7%a3%e8%80%a6%e5%90%84%e5%b1%82%ef%bc%8c%e8%a7%a3%e8%80%a6%e5%90%84%e4%b8%aa%e7%95%8c%e9%9d%a2%e5%92%8c%e5%90%84%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%8c%e9%99%8d%e4%bd%8e%e5%90%84%e4%b8%aa%e7%bb%84%e4%bb%b6%e4%b9%8b%e9%97%b4%e7%9a%84%e8%80%a6%e5%90%88%e5%ba%a6%ef%bc%8c%e5%a6%82%e4%bd%95%e8%83%bd%e8%ae%a9%e6%95%b4%e4%b8%aa%e7%b3%bb%e7%bb%9f%e4%b8%8d%e7%ae%a1%e5%a4%9a%e4%b9%88%e5%a4%8d%e6%9d%82%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%e9%83%bd%e8%83%bd%e4%bf%9d%e6%8c%81%e2%80%9c%e9%ab%98%e5%86%85%e8%81%9a%ef%bc%8c%e4%bd%8e%e8%80%a6%e5%90%88%e2%80%9d%e7%9a%84%e7%89%b9%e7%82%b9%ef%bc%9f%e8%bf%99%e4%b8%80%e7%b3%bb%e5%88%97%e7%9a%84%e9%97%ae%e9%a2%98%e9%83%bd%e6%91%86%e5%9c%a8%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98%e9%9d%a2%e5%89%8d%ef%bc%8c%e4%ba%9f%e5%be%85%e8%a7%a3%e5%86%b3%e3%80%82%e4%bb%8a%e5%a4%a9%e5%b0%b1%e6%9d%a5%e8%b0%88%e8%b0%88%e8%a7%a3%e5%86%b3%e8%bf%99%e4%b8%aa%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%80%e4%ba%9b%e6%80%9d%e8%b7%af%e3%80%82%0a%e7%9b%ae%e5%bd%95%20%201.%e5%bc%95%e5%ad%90%202.App%e8%b7%af%e7%94%b1%e8%83%bd%e8%a7%a3%e5%86%b3%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98%203.App%e4%b9%8b%e9%97%b4%e8%b7%b3%e8%bd%ac%e5%ae%9e%e7%8e%b0%204.App%e5%86%85%e7%bb%84%e4%bb%b6%e9%97%b4%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%205.%e5%90%84%e4%b8%aa%e6%96%b9%e6%a1%88%e4%bc%98%e7%bc%ba%e7%82%b9%206.%e6%9c%80%e5%a5%bd%e7%9a%84%e6%96%b9%e6%a1%88%20%20%e4%b8%80.%20%e5%bc%95%e5%ad%90%20%e5%a4%a7%e5%89%8d%e7%ab%af%e5%8f%91%e5%b1%95%e8%bf%99%e4%b9%88%e5%a4%9a%e5%b9%b4%e4%ba%86%ef%bc%8c%e7%9b%b8%e4%bf%a1%e4%b9%9f%e4%b8%80%e5%ae%9a%e4%bc%9a%e9%81%87%e5%88%b0%e7%9b%b8%e4%bc%bc%e7%9a%84%e9%97%ae%e9%a2%98%e3%80%82%e8%bf%91%e4%b8%a4%e5%b9%b4SPA%e5%8f%91%e5%b1%95%e6%9e%81%e5%85%b6%e8%bf%85%e7%8c%9b%ef%bc%8cReact%20%e5%92%8c%20Vue%e4%b8%80%e7%9b%b4%e5%a4%84%e4%ba%8e%e9%a3%8e%e5%8f%a3%e6%b5%aa%e5%b0%96%ef%bc%8c%e9%82%a3%e6%88%91%e4%bb%ac%e5%b0%b1%e7%9c%8b%e7%9c%8b%e4%bb%96%e4%bb%ac%e6%98%af%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e5%a5%bd%e8%bf%99%e4%b8%80%e9%97%ae%e9%a2%98%e7%9a%84%e3%80%82%0a%e5%9c%a8SPA%e5%8d%95%e9%a1%b5%e9%9d%a2%e5%ba%94%e7%94%a8%ef%bc%8c%e8%b7%af%e7%94%b1%e8%b5%b7%e5%88%b0%e4%ba%86%e5%be%88%e5%85%b3%e9%94%ae%e7%9a%84%e4%bd%9c%e7%94%a8%e3%80%82%e8%b7%af%e7%94%b1%e7%9a%84%e4%bd%9c%e7%94%a8%e4%b8%bb%e8%a6%81%e6%98%af%e4%bf%9d%e8%af%81%e8%a7%86%e5%9b%be%e5%92%8c%20URL%20%e7%9a%84%e5%90%8c%e6%ad%a5%e3%80%82%e5%9c%a8%e5%89%8d%e7%ab%af%e7%9a%84%e7%9c%bc%e9%87%8c%e7%9c%8b%e6%9d%a5%ef%bc%8c%e8%a7%86%e5%9b%be%e6%98%af%e8%a2%ab%e7%9c%8b%e6%88%90%e6%98%af%e8%b5%84%e6%ba%90%e7%9a%84%e4%b8%80%e7%a7%8d%e8%a1%a8%e7%8e%b0%e3%80%82%e5%bd%93%e7%94%a8%e6%88%b7%e5%9c%a8%e9%a1%b5%e9%9d%a2%e4%b8%ad%e8%bf%9b%e8%a1%8c%e6%93%8d%e4%bd%9c%e6%97%b6%ef%bc%8c%e5%ba%94%e7%94%a8%e4%bc%9a%e5%9c%a8%e8%8b%a5%e5%b9%b2%e4%b8%aa%e4%ba%a4%e4%ba%92%e7%8a%b6%e6%80%81%e4%b8%ad%e5%88%87%e6%8d%a2%ef%bc%8c%e8%b7%af%e7%94%b1%e5%88%99%e5%8f%af%e4%bb%a5%e8%ae%b0%e5%bd%95%e4%b8%8b%e6%9f%90%e4%ba%9b%e9%87%8d%e8%a6%81%e7%9a%84%e7%8a%b6%e6%80%81%ef%bc%8c%e6%af%94%e5%a6%82%e7%94%a8%e6%88%b7%e6%9f%a5%e7%9c%8b%e4%b8%80%e4%b8%aa%e7%bd%91%e7%ab%99%ef%bc%8c%e7%94%a8%e6%88%b7%e6%98%af%e5%90%a6%e7%99%bb%e5%bd%95%e3%80%81%e5%9c%a8%e8%ae%bf%e9%97%ae%e7%bd%91%e7%ab%99%e7%9a%84%e5%93%aa%e4%b8%80%e4%b8%aa%e9%a1%b5%e9%9d%a2%e3%80%82%e8%80%8c%e8%bf%99%e4%ba%9b%e5%8f%98%e5%8c%96%e5%90%8c%e6%a0%b7%e4%bc%9a%e8%a2%ab%e8%ae%b0%e5%bd%95%e5%9c%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%9a%84%e5%8e%86%e5%8f%b2%e4%b8%ad%ef%bc%8c%e7%94%a8%e6%88%b7%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87%e6%b5%8f%e8%a7%88%e5%99%a8%e7%9a%84%e5%89%8d%e8%bf%9b%e3%80%81%e5%90%8e%e9%80%80%e6%8c%89%e9%92%ae%e5%88%87%e6%8d%a2%e7%8a%b6%e6%80%81%e3%80%82%e6%80%bb%e7%9a%84%e6%9d%a5%e8%af%b4%ef%bc%8c%e7%94%a8%e6%88%b7%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87%e6%89%8b%e5%8a%a8%e8%be%93%e5%85%a5%e6%88%96%e8%80%85%e4%b8%8e%e9%a1%b5%e9%9d%a2%e8%bf%9b%e8%a1%8c%e4%ba%a4%e4%ba%92%e6%9d%a5%e6%94%b9%e5%8f%98%20URL%ef%bc%8c%e7%84%b6%e5%90%8e%e9%80%9a%e8%bf%87%e5%90%8c%e6%ad%a5%e6%88%96%e8%80%85%e5%bc%82%e6%ad%a5%e7%9a%84%e6%96%b9%e5%bc%8f%e5%90%91%e6%9c%8d%e5%8a%a1%e7%ab%af%e5%8f%91%e9%80%81%e8%af%b7%e6%b1%82%e8%8e%b7%e5%8f%96%e8%b5%84%e6%ba%90%ef%bc%8c%e6%88%90%e5%8a%9f%e5%90%8e%e9%87%8d%e6%96%b0%e7%bb%98%e5%88%b6%20UI%ef%bc%8c%e5%8e%9f%e7%90%86%e5%a6%82%e4%b8%8b%e5%9b%be%e6%89%80%e7%a4%ba%ef%bc%9a%0areact-router%e9%80%9a%e8%bf%87%e4%bc%a0%e5%85%a5%e7%9a%84location%e5%88%b0%e6%9c%80%e7%bb%88%e6%b8%b2%e6%9f%93%e6%96%b0%e7%9a%84UI%ef%bc%8c%e6%b5%81%e7%a8%8b%e5%a6%82%e4%b8%8b%ef%bc%9a%0alocation%e7%9a%84%e6%9d%a5%e6%ba%90%e6%9c%892%e7%a7%8d%ef%bc%8c%e4%b8%80%e7%a7%8d%e6%98%af%e6%b5%8f%e8%a7%88%e5%99%a8%e7%9a%84%e5%9b%9e%e9%80%80%e5%92%8c%e5%89%8d%e8%bf%9b%ef%bc%8c%e5%8f%a6%e5%a4%96%e4%b8%80%e7%a7%8d%e6%98%af%e7%9b%b4%e6%8e%a5%e7%82%b9%e4%ba%86%e4%b8%80%e4%b8%aa%e9%93%be%e6%8e%a5%e3%80%82%e6%96%b0%e7%9a%84%20location%20%e5%af%b9%e8%b1%a1%e5%90%8e%ef%bc%8c%e8%b7%af%e7%94%b1%e5%86%85%e9%83%a8%e7%9a%84%20matchRoutes%20%e6%96%b9%e6%b3%95%e4%bc%9a%e5%8c%b9%e9%85%8d%e5%87%ba%20Route%20%e7%bb%84%e4%bb%b6%e6%a0%91%e4%b8%ad%e4%b8%8e%e5%bd%93%e5%89%8d%20location%20%e5%af%b9%e8%b1%a1%e5%8c%b9%e9%85%8d%e7%9a%84%e4%b8%80%e4%b8%aa%e5%ad%90%e9%9b%86%ef%bc%8c%e5%b9%b6%e4%b8%94%e5%be%97%e5%88%b0%e4%ba%86%20nextState%ef%bc%8c%e5%9c%a8this.setState%28nextState%29%20%e6%97%b6%e5%b0%b1%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e9%87%8d%e6%96%b0%e6%b8%b2%e6%9f%93%20Router%20%e7%bb%84%e4%bb%b6%e3%80%82%0a%e5%a4%a7%e5%89%8d%e7%ab%af%e7%9a%84%e5%81%9a%e6%b3%95%e5%a4%a7%e6%a6%82%e6%98%af%e8%bf%99%e6%a0%b7%e7%9a%84%ef%bc%8c%e6%88%91%e4%bb%ac%e5%8f%af%e4%bb%a5%e6%8a%8a%e8%bf%99%e4%ba%9b%e6%80%9d%e6%83%b3%e5%80%9f%e9%89%b4%e5%88%b0iOS%e8%bf%99%e8%be%b9%e6%9d%a5%e3%80%82%e4%b8%8a%e5%9b%be%e4%b8%ad%e7%9a%84Back%20%2f%20Forward%20%e5%9c%a8iOS%e8%bf%99%e8%be%b9%e5%be%88%e5%a4%9a%e6%83%85%e5%86%b5%e4%b8%8b%e9%83%bd%e5%8f%af%e4%bb%a5%e8%a2%abUINavgation%e6%89%80%e7%ae%a1%e7%90%86%e3%80%82%e6%89%80%e4%bb%a5iOS%e7%9a%84Router%e4%b8%bb%e8%a6%81%e5%a4%84%e7%90%86%e7%bb%bf%e8%89%b2%e7%9a%84%e9%82%a3%e4%b8%80%e5%9d%97%e3%80%82%0a%e4%ba%8c.%20App%e8%b7%af%e7%94%b1%e8%83%bd%e8%a7%a3%e5%86%b3%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98%20%e6%97%a2%e7%84%b6%e5%89%8d%e7%ab%af%e8%83%bd%e5%9c%a8SPA%e4%b8%8a%e8%a7%a3%e5%86%b3URL%e5%92%8cUI%e7%9a%84%e5%90%8c%e6%ad%a5%e9%97%ae%e9%a2%98%ef%bc%8c%e9%82%a3%e8%bf%99%e7%a7%8d%e6%80%9d%e6%83%b3%e5%8f%af%e4%bb%a5%e5%9c%a8App%e4%b8%8a%e8%a7%a3%e5%86%b3%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98%e5%91%a2%ef%bc%9f%0a%e6%80%9d%e8%80%83%e5%a6%82%e4%b8%8b%e7%9a%84%e9%97%ae%e9%a2%98%ef%bc%8c%e5%b9%b3%e6%97%b6%e6%88%91%e4%bb%ac%e5%bc%80%e5%8f%91%e4%b8%ad%e6%98%af%e5%a6%82%e4%bd%95%e4%bc%98%e9%9b%85%e7%9a%84%e8%a7%a3%e5%86%b3%e7%9a%84%ef%bc%9a%0a1.3D-Touch%e5%8a%9f%e8%83%bd%e6%88%96%e8%80%85%e7%82%b9%e5%87%bb%e6%8e%a8%e9%80%81%e6%b6%88%e6%81%af%ef%bc%8c%e8%a6%81%e6%b1%82%e5%a4%96%e9%83%a8%e8%b7%b3%e8%bd%ac%e5%88%b0App%e5%86%85%e9%83%a8%e4%b8%80%e4%b8%aa%e5%be%88%e6%b7%b1%e5%b1%82%e6%ac%a1%e7%9a%84%e4%b8%80%e4%b8%aa%e7%95%8c%e9%9d%a2%e3%80%82%0a%e6%af%94%e5%a6%82%e5%be%ae%e4%bf%a1%e7%9a%843D-Touch%e5%8f%af%e4%bb%a5%e7%9b%b4%e6%8e%a5%e8%b7%b3%e8%bd%ac%e5%88%b0%e2%80%9c%e6%88%91%e7%9a%84%e4%ba%8c%e7%bb%b4%e7%a0%81%e2%80%9d%e3%80%82%e2%80%9c%e6%88%91%e7%9a%84%e4%ba%8c%e7%bb%b4%e7%a0%81%e2%80%9d%e7%95%8c%e9%9d%a2%e5%9c%a8%e6%88%91%e7%9a%84%e9%87%8c%e9%9d%a2%e7%9a%84%e7%ac%ac%e4%b8%89%e7%ba%a7%e7%95%8c%e9%9d%a2%e3%80%82%e6%88%96%e8%80%85%e5%86%8d%e6%9e%81%e7%ab%af%e4%b8%80%e7%82%b9%ef%bc%8c%e4%ba%a7%e5%93%81%e9%9c%80%e6%b1%82%e7%bb%99%e4%ba%86%e6%9b%b4%e5%8a%a0%e5%8f%98%e6%80%81%e7%9a%84%e9%9c%80%e6%b1%82%ef%bc%8c%e8%a6%81%e6%b1%82%e8%b7%b3%e8%bd%ac%e5%88%b0App%e5%86%85%e9%83%a8%e7%ac%ac%e5%8d%81%e5%b1%82%e7%9a%84%e7%95%8c%e9%9d%a2%ef%bc%8c%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86%ef%bc%9f%0a2.%e8%87%aa%e5%ae%b6%e7%9a%84%e4%b8%80%e7%b3%bb%e5%88%97App%e4%b9%8b%e9%97%b4%e5%a6%82%e4%bd%95%e7%9b%b8%e4%ba%92%e8%b7%b3%e8%bd%ac%ef%bc%9f%0a%e5%a6%82%e6%9e%9c%e8%87%aa%e5%b7%b1App%e6%9c%89%e5%87%a0%e4%b8%aa%ef%bc%8c%e7%9b%b8%e4%ba%92%e4%b9%8b%e9%97%b4%e8%bf%98%e6%83%b3%e7%9b%b8%e4%ba%92%e8%b7%b3%e8%bd%ac%ef%bc%8c%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86%ef%bc%9f%0a3.%e5%a6%82%e4%bd%95%e8%a7%a3%e9%99%a4App%e7%bb%84%e4%bb%b6%e4%b9%8b%e9%97%b4%e5%92%8cApp%e9%a1%b5%e9%9d%a2%e4%b9%8b%e9%97%b4%e7%9a%84%e8%80%a6%e5%90%88%e6%80%a7%ef%bc%9f%0a%e9%9a%8f%e7%9d%80%e9%a1%b9%e7%9b%ae%e8%b6%8a%e6%9d%a5%e8%b6%8a%e5%a4%8d%e6%9d%82%ef%bc%8c%e5%90%84%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%8c%e5%90%84%e4%b8%aa%e9%a1%b5%e9%9d%a2%e4%b9%8b%e9%97%b4%e7%9a%84%e8%b7%b3%e8%bd%ac%e9%80%bb%e8%be%91%e5%85%b3%e8%81%94%e6%80%a7%e8%b6%8a%e6%9d%a5%e8%b6%8a%e5%a4%9a%ef%bc%8c%e5%a6%82%e4%bd%95%e8%83%bd%e4%bc%98%e9%9b%85%e7%9a%84%e8%a7%a3%e9%99%a4%e5%90%84%e4%b8%aa%e7%bb%84%e4%bb%b6%e5%92%8c%e9%a1%b5%e9%9d%a2%e4%b9%8b%e9%97%b4%e7%9a%84%e8%80%a6%e5%90%88%e6%80%a7%ef%bc%9f%0a4.%e5%a6%82%e4%bd%95%e8%83%bd%e7%bb%9f%e4%b8%80iOS%e5%92%8cAndroid%e4%b8%a4%e7%ab%af%e7%9a%84%e9%a1%b5%e9%9d%a2%e8%b7%b3%e8%bd%ac%e9%80%bb%e8%be%91%ef%bc%9f%e7%94%9a%e8%87%b3%e5%a6%82%e4%bd%95%e8%83%bd%e7%bb%9f%e4%b8%80%e4%b8%89%e7%ab%af%e7%9a%84%e8%af%b7%e6%b1%82%e8%b5%84%e6%ba%90%e7%9a%84%e6%96%b9%e5%bc%8f%ef%bc%9f%0a%e9%a1%b9%e7%9b%ae%e9%87%8c%e9%9d%a2%e6%9f%90%e4%ba%9b%e6%a8%a1%e5%9d%97%e4%bc%9a%e6%b7%b7%e5%90%88ReactNative%ef%bc%8cWeex%ef%bc%8cH5%e7%95%8c%e9%9d%a2%ef%bc%8c%e8%bf%99%e4%ba%9b%e7%95%8c%e9%9d%a2%e8%bf%98%e4%bc%9a%e8%b0%83%e7%94%a8Native%e7%9a%84%e7%95%8c%e9%9d%a2%ef%bc%8c%e4%bb%a5%e5%8f%8aNative%e7%9a%84%e7%bb%84%e4%bb%b6%e3%80%82%e9%82%a3%e4%b9%88%ef%bc%8c%e5%a6%82%e4%bd%95%e8%83%bd%e7%bb%9f%e4%b8%80Web%e7%ab%af%e5%92%8cNative%e7%ab%af%e8%af%b7%e6%b1%82%e8%b5%84%e6%ba%90%e7%9a%84%e6%96%b9%e5%bc%8f%ef%bc%9f%0a5.%e5%a6%82%e6%9e%9c%e4%bd%bf%e7%94%a8%e4%ba%86%e5%8a%a8%e6%80%81%e4%b8%8b%e5%8f%91%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e6%9d%a5%e9%85%8d%e7%bd%aeApp%e7%9a%84%e8%b7%b3%e8%bd%ac%e9%80%bb%e8%be%91%ef%bc%8c%e9%82%a3%e4%b9%88%e5%a6%82%e6%9e%9c%e5%81%9a%e5%88%b0iOS%e5%92%8cAndroid%e4%b8%a4%e8%be%b9%e5%8f%aa%e8%a6%81%e5%85%b1%e7%94%a8%e4%b8%80%e5%a5%97%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%ef%bc%9f%0a6.%e5%a6%82%e6%9e%9cApp%e5%87%ba%e7%8e%b0bug%e4%ba%86%ef%bc%8c%e5%a6%82%e4%bd%95%e4%b8%8d%e7%94%a8JSPatch%ef%bc%8c%e5%b0%b1%e8%83%bd%e5%81%9a%e5%88%b0%e7%ae%80%e5%8d%95%e7%9a%84%e7%83%ad%e4%bf%ae%e5%a4%8d%e5%8a%9f%e8%83%bd%ef%bc%9f%0a%e6%af%94%e5%a6%82App%e4%b8%8a%e7%ba%bf%e7%aa%81%e7%84%b6%e9%81%87%e5%88%b0%e4%ba%86%e7%b4%a7%e6%80%a5bug%ef%bc%8c%e8%83%bd%e5%90%a6%e6%8a%8a%e9%a1%b5%e9%9d%a2%e5%8a%a8%e6%80%81%e9%99%8d%e7%ba%a7%e6%88%90H5%ef%bc%8cReactNative%ef%bc%8cWeex%ef%bc%9f%e6%88%96%e8%80%85%e6%98%af%e7%9b%b4%e6%8e%a5%e6%8d%a2%e6%88%90%e4%b8%80%e4%b8%aa%e6%9c%ac%e5%9c%b0%e7%9a%84%e9%94%99%e8%af%af%e7%95%8c%e9%9d%a2%ef%bc%9f%0a7.%e5%a6%82%e4%bd%95%e5%9c%a8%e6%af%8f%e4%b8%aa%e7%bb%84%e4%bb%b6%e9%97%b4%e8%b0%83%e7%94%a8%e5%92%8c%e9%a1%b5%e9%9d%a2%e8%b7%b3%e8%bd%ac%e6%97%b6%e9%83%bd%e8%bf%9b%e8%a1%8c%e5%9f%8b%e7%82%b9%e7%bb%9f%e8%ae%a1%ef%bc%9f%e6%af%8f%e4%b8%aa%e8%b7%b3%e8%bd%ac%e7%9a%84%e5%9c%b0%e6%96%b9%e9%83%bd%e6%89%8b%e5%86%99%e4%bb%a3%e7%a0%81%e5%9f%8b%e7%82%b9%ef%bc%9f%e5%88%a9%e7%94%a8Runtime%20AOP%20%ef%bc%9f%0a8.%e5%a6%82%e4%bd%95%e5%9c%a8%e6%af%8f%e4%b8%aa%e7%bb%84%e4%bb%b6%e9%97%b4%e8%b0%83%e7%94%a8%e7%9a%84%e8%bf%87%e7%a8%8b%e4%b8%ad%ef%bc%8c%e5%8a%a0%e5%85%a5%e8%b0%83%e7%94%a8%e7%9a%84%e9%80%bb%e8%be%91%e6%a3%80%e6%9f%a5%ef%bc%8c%e4%bb%a4%e7%89%8c%e6%9c%ba%e5%88%b6%ef%bc%8c%e9%85%8d%e5%90%88%e7%81%b0%e5%ba%a6%e8%bf%9b%e8%a1%8c%e9%a3%8e%e6%8e%a7%e9%80%bb%e8%be%91%ef%bc%9f%0a9.%e5%a6%82%e4%bd%95%e5%9c%a8App%e4%bb%bb%e4%bd%95%e7%95%8c%e9%9d%a2%e9%83%bd%e5%8f%af%e4%bb%a5%e8%b0%83%e7%94%a8%e5%90%8c%e4%b8%80%e4%b8%aa%e7%95%8c%e9%9d%a2%e6%88%96%e8%80%85%e5%90%8c%e4%b8%80%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9f%e5%8f%aa%e8%83%bd%e5%9c%a8AppDelegate%e9%87%8c%e9%9d%a2%e6%b3%a8%e5%86%8c%e5%8d%95%e4%be%8b%e6%9d%a5%e5%ae%9e%e7%8e%b0%ef%bc%9f%0a%e6%af%94%e5%a6%82App%e5%87%ba%e7%8e%b0%e9%97%ae%e9%a2%98%e4%ba%86%ef%bc%8c%e7%94%a8%e6%88%b7%e5%8f%af%e8%83%bd%e5%9c%a8%e4%bb%bb%e4%bd%95%e7%95%8c%e9%9d%a2%ef%bc%8c%e5%a6%82%e4%bd%95%e9%9a%8f%e6%97%b6%e9%9a%8f%e5%9c%b0%e7%9a%84%e8%ae%a9%e7%94%a8%e6%88%b7%e5%bc%ba%e5%88%b6%e7%99%bb%e5%87%ba%ef%bc%9f%e6%88%96%e8%80%85%e5%bc%ba%e5%88%b6%e9%83%bd%e8%b7%b3%e8%bd%ac%e5%88%b0%e5%90%8c%e4%b8%80%e4%b8%aa%e6%9c%ac%e5%9c%b0%e7%9a%84error%e7%95%8c%e9%9d%a2%ef%bc%9f%e6%88%96%e8%80%85%e8%b7%b3%e8%bd%ac%e5%88%b0%e7%9b%b8%e5%ba%94%e7%9a%84H5%ef%bc%8cReactNative%ef%bc%8cWeex%e7%95%8c%e9%9d%a2%ef%bc%9f%e5%a6%82%e4%bd%95%e8%ae%a9%e7%94%a8%e6%88%b7%e5%9c%a8%e4%bb%bb%e4%bd%95%e7%95%8c%e9%9d%a2%ef%bc%8c%e9%9a%8f%e6%97%b6%e9%9a%8f%e5%9c%b0%e7%9a%84%e5%bc%b9%e5%87%ba%e4%b8%80%e4%b8%aaView%20%ef%bc%9f%0a%e4%bb%a5%e4%b8%8a%e8%bf%99%e4%ba%9b%e9%97%ae%e9%a2%98%e5%85%b6%e5%ae%9e%e9%83%bd%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87%e5%9c%a8App%e7%ab%af%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e8%b7%af%e7%94%b1%e6%9d%a5%e8%a7%a3%e5%86%b3%e3%80%82%e9%82%a3%e4%b9%88%e6%88%91%e4%bb%ac%e6%80%8e%e4%b9%88%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e8%b7%af%e7%94%b1%e5%91%a2%ef%bc%9f%0a%e4%b8%89.%20App%e4%b9%8b%e9%97%b4%e8%b7%b3%e8%bd%ac%e5%ae%9e%e7%8e%b0%20%e5%9c%a8%e8%b0%88App%e5%86%85%e9%83%a8%e7%9a%84%e8%b7%af%e7%94%b1%e4%b9%8b%e5%89%8d%ef%bc%8c%e5%85%88%e6%9d%a5%e8%b0%88%e8%b0%88%e5%9c%a8iOS%e7%b3%bb%e7%bb%9f%e9%97%b4%ef%bc%8c%e4%b8%8d%e5%90%8cApp%e4%b9%8b%e9%97%b4%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e8%b7%b3%e8%bd%ac%e7%9a%84%e3%80%82%0a1.%20URL%20Scheme%e6%96%b9%e5%bc%8f%20iOS%e7%b3%bb%e7%bb%9f%e6%98%af%e9%bb%98%e8%ae%a4%e6%94%af%e6%8c%81URL%20Scheme%e7%9a%84%ef%bc%8c%e5%85%b7%e4%bd%93%e8%a7%81%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%e3%80%82"><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fnew.halfrost.com%2fios_router%2f&t=iOS%20%e7%bb%84%e4%bb%b6%e5%8c%96%20%e2%80%94%e2%80%94%20%e8%b7%af%e7%94%b1%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu class=icon href=# onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden=true></i>Menu</a>
<a id=toc class=icon href=# onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden=true></i>TOC</a>
<a id=share class=icon href=# onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden=true></i>share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i>Top</a></div></div></div><footer id=footer><div class=footer-left><p class=copyright style=float:left;margin-bottom:0><a href=https://github.com/halfrost/Halfrost-Field class=github-repo style=height:18px><span class=gadget-github></span>Star</a>
Copyright &copy;halfrost 2016 - 2021
<a href=http://www.miit.gov.cn/>鄂ICP备16014744号</a></p><br><p class="copyright statistics" style=margin-bottom:20px><span id=busuanzi_container_site_pv>Cumulative Page Views <span id=busuanzi_value_site_pv></span>| Unique Visitors <span id=busuanzi_value_site_uv></span></span></p></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/main.min.f870a4d110314b9e50e65f8ac982dc1c9c376c8f1a5083d39c62cfc49073f011.js></script><script async src=/prism.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}};</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></html>